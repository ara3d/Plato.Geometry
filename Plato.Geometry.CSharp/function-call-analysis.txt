Function call analysis
0.
  Callsite: MapRange(n, (\(ParameterDef=i$5601:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1069:, $1070:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
1.
  Callsite: MapRange(n, (\(ParameterDef=i$5619:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1072:, $1073:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
2.
  Callsite: NumRows(PointGrid(x))
  Args: $115:constraint=(IArray2D, Vector3D)
  Possible Return Types: Integer
  Callable function count: 5
  Best function count: 3
    Function = IGeometry_18:Library.NumRows(x: QuadGrid3D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.NumRows(xs: (Array2D, $1047:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array2D, $1047:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.NumRows(xs: (Array3D, $1049:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array3D, $1049:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = IArray2D_30:Concept.NumRows(xs: $5:constraint=(IArray2D, $4:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$5:constraint=(IArray2D, $4:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = IArray3D_32:Concept.NumRows(xs: $11:constraint=(IArray3D, $10:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$11:constraint=(IArray3D, $10:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
3.
  Callsite: NumRows(xs)
  Args: (IArray2D, $615:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumRows(xs: $5:constraint=(IArray2D, $4:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$5:constraint=(IArray2D, $4:) <= (IArray2D, $615:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumRows(xs: $11:constraint=(IArray3D, $10:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$11:constraint=(IArray3D, $10:) <= (IArray2D, $615:) = UnknownParamIsTypeVar
4.
  Callsite: NumColumns(PointGrid(x))
  Args: $115:constraint=(IArray2D, Vector3D)
  Possible Return Types: Integer
  Callable function count: 5
  Best function count: 3
    Function = IGeometry_18:Library.NumColumns(x: QuadGrid3D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.NumColumns(xs: (Array2D, $1048:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array2D, $1048:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.NumColumns(xs: (Array3D, $1050:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array3D, $1050:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= $115:constraint=(IArray2D, Vector3D) = UnknownArgIsTypeVar
5.
  Callsite: NumColumns(xs)
  Args: (IArray2D, $615:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray2D, $615:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray2D, $615:) = UnknownParamIsTypeVar
6.
  Callsite: NumColumns(xs)
  Args: (IArray2D, $617:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray2D, $617:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray2D, $617:) = UnknownParamIsTypeVar
7.
  Callsite: NumRows(xs)
  Args: (IArray3D, $616:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumRows(xs: $5:constraint=(IArray2D, $4:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$5:constraint=(IArray2D, $4:) <= (IArray3D, $616:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumRows(xs: $11:constraint=(IArray3D, $10:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$11:constraint=(IArray3D, $10:) <= (IArray3D, $616:) = UnknownParamIsTypeVar
8.
  Callsite: NumColumns(xs)
  Args: (IArray3D, $616:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray3D, $616:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray3D, $616:) = UnknownParamIsTypeVar
9.
  Callsite: MapComponents(x, (\(ParameterDef=i$9005:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1077:, $1078:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
10.
  Callsite: Lesser(Count(xs), Count(ys))
  Args: Integer, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
11.
  Callsite: MapRange(Lesser(Count(xs), Count(ys)), (\(ParameterDef=i$6273:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $1083:, (Function1, $1084:, $1085:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
12.
  Callsite: Lesser(Count(xs), Count(ys))
  Args: Integer, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
13.
  Callsite: Lesser(Lesser(Count(xs), Count(ys)), Count(zs))
  Args: $1087:, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
14.
  Callsite: MapRange(Lesser(Lesser(Count(xs), Count(ys)), Count(zs)), (\(ParameterDef=i$6345:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $1088:, (Function1, $1089:, $1090:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
15.
  Callsite: Zip(Components(x), Components(y), f)
  Args: $24:constraint=(IArray, Number), $24:constraint=(IArray, Number), (Function2, Number, Number, Number)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
16.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$9165:Concept:IAny, ParameterDef=b$9167:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: IVector, IVector, (Function2, $1080:, $1081:, $1082:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
17.
  Callsite: X(Column1)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
18.
  Callsite: ToVector4D(v, 0)
  Args: Vector3D, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
19.
  Callsite: Multiply(Vector4D(q), scalar)
  Args: Vector4D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
20.
  Callsite: X(Column2)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
21.
  Callsite: Y(Column1)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
22.
  Callsite: X(Column3)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
23.
  Callsite: Z(Column1)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
24.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$9082:Concept:IAny, ParameterDef=b$9084:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: INumerical, INumerical, (Function2, $1108:, $1109:, $1110:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
25.
  Callsite: Y(Column2)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
26.
  Callsite: Z(Column2)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
27.
  Callsite: Y(Column3)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
28.
  Callsite: Z(Column3)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
29.
  Callsite: CreateFromRows(Matrix4x4, row1, row2, row3, Tuple4(0, 0, 0, 1))
  Args: IAny, Vector3D, Vector3D, Vector3D, (Tuple4, $1153:, $1154:, $1155:, $1156:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
30.
  Callsite: CreateFromRows(Matrix4x4, Tuple4(Add(Multiply(M11(a), M11(b)), Add(Multiply(M12(a), M21(b)), Add(Multiply(M13(a), M31(b)), Multiply(M14(a), M41(b))))), Add(Multiply(M11(a), M12(b)), Add(Multiply(M12(a), M22(b)), Add(Multiply(M13(a), M32(b)), Multiply(M14(a), M42(b))))), Add(Multiply(M11(a), M13(b)), Add(Multiply(M12(a), M23(b)), Add(Multiply(M13(a), M33(b)), Multiply(M14(a), M43(b))))), Add(Multiply(M11(a), M14(b)), Add(Multiply(M12(a), M24(b)), Add(Multiply(M13(a), M34(b)), Multiply(M14(a), M44(b)))))), Tuple4(Add(Multiply(M21(a), M11(b)), Add(Multiply(M22(a), M21(b)), Add(Multiply(M23(a), M31(b)), Multiply(M24(a), M41(b))))), Add(Multiply(M21(a), M12(b)), Add(Multiply(M22(a), M22(b)), Add(Multiply(M23(a), M32(b)), Multiply(M24(a), M42(b))))), Add(Multiply(M21(a), M13(b)), Add(Multiply(M22(a), M23(b)), Add(Multiply(M23(a), M33(b)), Multiply(M24(a), M43(b))))), Add(Multiply(M21(a), M14(b)), Add(Multiply(M22(a), M24(b)), Add(Multiply(M23(a), M34(b)), Multiply(M24(a), M44(b)))))), Tuple4(Add(Multiply(M31(a), M11(b)), Add(Multiply(M32(a), M21(b)), Add(Multiply(M33(a), M31(b)), Multiply(M34(a), M41(b))))), Add(Multiply(M31(a), M12(b)), Add(Multiply(M32(a), M22(b)), Add(Multiply(M33(a), M32(b)), Multiply(M34(a), M42(b))))), Add(Multiply(M31(a), M13(b)), Add(Multiply(M32(a), M23(b)), Add(Multiply(M33(a), M33(b)), Multiply(M34(a), M43(b))))), Add(Multiply(M31(a), M14(b)), Add(Multiply(M32(a), M24(b)), Add(Multiply(M33(a), M34(b)), Multiply(M34(a), M44(b)))))), Tuple4(Add(Multiply(M41(a), M11(b)), Add(Multiply(M42(a), M21(b)), Add(Multiply(M43(a), M31(b)), Multiply(M44(a), M41(b))))), Add(Multiply(M41(a), M12(b)), Add(Multiply(M42(a), M22(b)), Add(Multiply(M43(a), M32(b)), Multiply(M44(a), M42(b))))), Add(Multiply(M41(a), M13(b)), Add(Multiply(M42(a), M23(b)), Add(Multiply(M43(a), M33(b)), Multiply(M44(a), M43(b))))), Add(Multiply(M41(a), M14(b)), Add(Multiply(M42(a), M24(b)), Add(Multiply(M43(a), M34(b)), Multiply(M44(a), M44(b)))))))
  Args: IAny, (Tuple4, $1117:, $1118:, $1119:, $1120:), (Tuple4, $1121:, $1122:, $1123:, $1124:), (Tuple4, $1125:, $1126:, $1127:, $1128:), (Tuple4, $1129:, $1130:, $1131:, $1132:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
31.
  Callsite: Multiply(Column1(m), s)
  Args: Vector4D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
32.
  Callsite: Multiply(Column2(m), s)
  Args: Vector4D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
33.
  Callsite: Multiply(Column3(m), s)
  Args: Vector4D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
34.
  Callsite: Multiply(Column4(m), s)
  Args: Vector4D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
35.
  Callsite: MapRange(Count(xs), (\(ParameterDef=i$6222:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1166:, $1167:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
36.
  Callsite: NumColumns(xs)
  Args: (IArray2D, $742:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray2D, $742:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray2D, $742:) = UnknownParamIsTypeVar
37.
  Callsite: NumRows(xs)
  Args: (IArray2D, $742:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumRows(xs: $5:constraint=(IArray2D, $4:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$5:constraint=(IArray2D, $4:) <= (IArray2D, $742:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumRows(xs: $11:constraint=(IArray3D, $10:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$11:constraint=(IArray3D, $10:) <= (IArray2D, $742:) = UnknownParamIsTypeVar
38.
  Callsite: MakeArray2D(NumColumns(xs), NumRows(xs), (\(ParameterDef=a$6857:Concept:IAny, ParameterDef=b$6859:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: Integer, Integer, (Function2, $1169:, $1170:, $1171:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
39.
  Callsite: Map(Components(x), f)
  Args: $24:constraint=(IArray, Number), (Function1, Number, Number)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
40.
  Callsite: MapComponents(x, (\(ParameterDef=i$9055:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1075:, $1076:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
41.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$9227:Concept:IAny, ParameterDef=b$9229:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: IVector, IVector, (Function2, $1175:, $1176:, $1177:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
42.
  Callsite: NumColumns(xs)
  Args: (IArray2D, $617:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray2D, $617:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray2D, $617:) = UnknownParamIsTypeVar
43.
  Callsite: MapComponents(x, (\(ParameterDef=i$9030:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1179:, $1180:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
44.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$9196:Concept:IAny, ParameterDef=b$9198:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: IVector, IVector, (Function2, $1182:, $1183:, $1184:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
45.
  Callsite: Divide(Vector4D(q), scalar)
  Args: Vector4D, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
46.
  Callsite: Divide(Column1(m), s)
  Args: Vector4D, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
47.
  Callsite: Divide(Column2(m), s)
  Args: Vector4D, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
48.
  Callsite: Divide(Column3(m), s)
  Args: Vector4D, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
49.
  Callsite: Divide(Column4(m), s)
  Args: Vector4D, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Vector4D = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
50.
  Callsite: NumColumns(xs)
  Args: (IArray3D, $619:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray3D, $619:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray3D, $619:) = UnknownParamIsTypeVar
51.
  Callsite: NumColumns(xs)
  Args: (IArray3D, $619:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray3D, $619:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray3D, $619:) = UnknownParamIsTypeVar
52.
  Callsite: Zip(FieldValues(a), FieldValues(b), (\(ParameterDef=a0$8765:Concept:IAny, ParameterDef=b0$8767:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: $21:constraint=(IArray, Dynamic), $21:constraint=(IArray, Dynamic), (Function2, $1190:, $1191:, $1192:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
53.
  Callsite: All(Zip(FieldValues(a), FieldValues(b), (\(ParameterDef=a0$8765:Concept:IAny, ParameterDef=b0$8767:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>), (\(ParameterDef=x$8788:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $1193:, (Function1, $1194:, $1195:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
54.
  Callsite: Radians(Multiply(x, TwoPi))
  Args: $36:constraint=IMultiplicative
  Possible Return Types: Angle, Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Radians(x: Number): Angle
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Angle_126:ConcreteType.Radians(self: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:Angle <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
55.
  Callsite: Turns(Divide(Number(n), NumPoints(x)))
  Args: $38:constraint=IDivisible
  Possible Return Types: Angle, Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Turns(x: Number): Angle
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $38:constraint=IDivisible = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Turns(x: Angle): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $38:constraint=IDivisible = UnknownArgIsTypeVar
56.
  Callsite: At(Components(x), n)
  Args: $24:constraint=(IArray, Number), Integer
  Possible Return Types: Number, Vector2D, Character, $1053:
  Callable function count: 10
  Best function count: 7
    Function = ArrayLibrary_0:Library.At(xs: (IArray2D, $617:), i: Integer): $618:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray2D, $617:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = ArrayLibrary_0:Library.At(xs: (IArray3D, $619:), i: Integer): $620:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray3D, $619:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(c: Complex, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = c:Complex <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector2D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector2D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector3D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector3D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector4D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector4D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(x: RegularPolygon, n: Integer): Vector2D
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:RegularPolygon <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(x: String, y: Integer): Character
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:String <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(xs: (Array, $1052:), n: Integer): $1053:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = xs:(Array, $1052:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IArray_28:Concept.At(xs: $3:constraint=(IArray, $2:), n: Integer): $2:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:$3:constraint=(IArray, $2:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
57.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$9113:Concept:IAny, ParameterDef=b$9115:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: INumerical, INumerical, (Function2, $1203:, $1204:, $1205:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
58.
  Callsite: MapRange(count, (\(ParameterDef=i$5915:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1207:, $1208:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
59.
  Callsite: MapRange(Divide(Count(xs), size), (\(ParameterDef=i$5862:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1210:, $1211:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
60.
  Callsite: MapRange(Count(xs), (\(ParameterDef=i$6413:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1213:, $1214:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
61.
  Callsite: Zip(Drop(xs, 1), Skip(xs, 1), f)
  Args: $651:constraint=(IArray, $650:), $642:constraint=(IArray, $641:), (Function2, $695:, $696:, $697:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
62.
  Callsite: Zip(xs, Shift(xs, 1), f)
  Args: (IArray, $700:), $693:constraint=(IArray, $692:), (Function2, $701:, $702:, $703:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
63.
  Callsite: WithNextAndBeginning(xs, f)
  Args: (IArray, $706:), (Function2, $707:, $708:, $709:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
64.
  Callsite: WithNext(xs, f)
  Args: (IArray, $706:), (Function2, $707:, $708:, $709:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
65.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$8655:Concept:IAny, ParameterDef=b$8657:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: INumerical, INumerical, (Function2, $1220:, $1221:, $1222:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
66.
  Callsite: GreaterThanOrEquals(x, y)
  Args: Number, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
67.
  Callsite: ZipComponents(x, y, (\(ParameterDef=a$8686:Concept:IAny, ParameterDef=b$8688:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: INumerical, INumerical, (Function2, $1225:, $1226:, $1227:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
68.
  Callsite: FromOne(t)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
69.
  Callsite: Multiply(a, FromOne(t))
  Args: IInterpolatable, $1229:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IInterpolatable = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1229: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IInterpolatable = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1229: = UnknownArgIsTypeVar
70.
  Callsite: Multiply(b, t)
  Args: IInterpolatable, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IInterpolatable = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IInterpolatable = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
71.
  Callsite: Add(Multiply(a, FromOne(t)), Multiply(b, t))
  Args: $35:constraint=IScalarArithmetic, $35:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
72.
  Callsite: Divide(Add(A(t), Add(B(t), C(t))), 3)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
73.
  Callsite: Divide(Add(A(t), Add(B(t), C(t))), 3)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
74.
  Callsite: Divide(Add(A(q), Add(B(q), Add(C(q), D(q)))), 4)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
75.
  Callsite: Divide(Add(A(q), Add(B(q), Add(C(q), D(q)))), 4)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
76.
  Callsite: Divide(x, 2)
  Args: IScalarArithmetic, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
77.
  Callsite: Subtract(Max(x), Min(x))
  Args: $49:, $47:
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $49: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $47: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $49: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $47: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $49: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $47: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $49: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $47: = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $49: = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $47: = UnknownArgIsTypeVar
78.
  Callsite: Subtract(End(x), Start(x))
  Args: $45:, $43:
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $45: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $43: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $45: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $43: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $45: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $43: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $45: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $43: = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $45: = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $43: = UnknownArgIsTypeVar
79.
  Callsite: Half(Width(x))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
80.
  Callsite: Half(Height(x))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
81.
  Callsite: Map(Range(x), (\(ParameterDef=i$7651:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $612:constraint=(IArray, Integer), (Function1, $1248:, $1249:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
82.
  Callsite: Map(Fractions(n), (\(ParameterDef=x$14425:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $785:constraint=(IArray, Number), (Function1, $1251:, $1252:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
83.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17393:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Line2D), (Function1, $1260:, $1261:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
84.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17412:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Line3D), (Function1, $1263:, $1264:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
85.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17431:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Triangle2D), (Function1, $1266:, $1267:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
86.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17450:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Triangle3D), (Function1, $1269:, $1270:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
87.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17469:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad2D), (Function1, $1272:, $1273:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
88.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17488:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad3D), (Function1, $1275:, $1276:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
89.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$14925:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $861:constraint=(IArray, (IArray, Vector2D)), (Function1, $1278:, $1279:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
90.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$14971:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $862:constraint=(IArray, (IArray, Vector3D)), (Function1, $1281:, $1282:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
91.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17615:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad2D), (Function1, $1286:, $1287:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
92.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17637:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad3D), (Function1, $1289:, $1290:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
93.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$15017:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $861:constraint=(IArray, (IArray, Vector2D)), (Function1, $1292:, $1293:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
94.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$15070:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $862:constraint=(IArray, (IArray, Vector3D)), (Function1, $1295:, $1296:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
95.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17901:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $869:constraint=(IArray, Quad2D), (Function1, $1298:, $1299:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
96.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17925:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $870:constraint=(IArray, Quad3D), (Function1, $1301:, $1302:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
97.
  Callsite: FlatMap(Triangles(xs), (\(ParameterDef=x$17709:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $867:constraint=(IArray, Triangle2D), (Function1, $1304:, $1305:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
98.
  Callsite: FlatMap(Triangles(xs), (\(ParameterDef=x$17733:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $868:constraint=(IArray, Triangle3D), (Function1, $1307:, $1308:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
99.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17757:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $869:constraint=(IArray, Quad2D), (Function1, $1310:, $1311:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
100.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17781:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $870:constraint=(IArray, Quad3D), (Function1, $1313:, $1314:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
101.
  Callsite: NumColumns(xs)
  Args: (IArray2D, $895:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumColumns(xs: $7:constraint=(IArray2D, $6:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$7:constraint=(IArray2D, $6:) <= (IArray2D, $895:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumColumns(xs: $13:constraint=(IArray3D, $12:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$13:constraint=(IArray3D, $12:) <= (IArray2D, $895:) = UnknownParamIsTypeVar
102.
  Callsite: NumRows(xs)
  Args: (IArray2D, $895:)
  Possible Return Types: Integer
  Callable function count: 2
  Best function count: 2
    Function = IArray2D_30:Concept.NumRows(xs: $5:constraint=(IArray2D, $4:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$5:constraint=(IArray2D, $4:) <= (IArray2D, $895:) = UnknownParamIsTypeVar
    Function = IArray3D_32:Concept.NumRows(xs: $11:constraint=(IArray3D, $10:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$11:constraint=(IArray3D, $10:) <= (IArray2D, $895:) = UnknownParamIsTypeVar
103.
  Callsite: FlatMap(AllQuadFaceIndices(PointGrid(x), ClosedX(x), ClosedY(x)), (\(ParameterDef=x$16763:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $896:constraint=(IArray2D, Integer4), (Function1, $1316:, $1317:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
104.
  Callsite: Indices(Points(x))
  Args: $931:constraint=(IArray, Vector3D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
105.
  Callsite: Indices(Points(x))
  Args: $930:constraint=(IArray, Vector2D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $930:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
106.
  Callsite: Indices(Points(x))
  Args: $929:constraint=(IArray, Vector3D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
107.
  Callsite: Indices(Points(x))
  Args: $928:constraint=(IArray, Vector2D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $928:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
108.
  Callsite: Indices(Points(x))
  Args: $927:constraint=(IArray, Vector3D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $927:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
109.
  Callsite: Indices(Points(x))
  Args: $926:constraint=(IArray, Vector2D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $926:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
110.
  Callsite: Map(Slices(Indices(g), PrimitiveSize(g)), (\(ParameterDef=xs$14797:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $633:constraint=(IArray, (IArray, $632:)), (Function1, $1319:, $1320:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
111.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$14886:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $862:constraint=(IArray, (IArray, Vector3D)), (Function1, $1322:, $1323:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
112.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17517:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Triangle2D), (Function1, $1329:, $1330:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
113.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17539:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Triangle3D), (Function1, $1332:, $1333:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
114.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17561:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad2D), (Function1, $1335:, $1336:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
115.
  Callsite: FlatMap(xs, (\(ParameterDef=x$17583:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Quad3D), (Function1, $1338:, $1339:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
116.
  Callsite: FlatMap(Triangles(xs), (\(ParameterDef=x$17805:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $867:constraint=(IArray, Triangle2D), (Function1, $1341:, $1342:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
117.
  Callsite: FlatMap(Triangles(xs), (\(ParameterDef=x$17829:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $868:constraint=(IArray, Triangle3D), (Function1, $1344:, $1345:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
118.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17853:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $869:constraint=(IArray, Quad2D), (Function1, $1347:, $1348:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
119.
  Callsite: FlatMap(Quads(xs), (\(ParameterDef=x$17877:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $870:constraint=(IArray, Quad3D), (Function1, $1350:, $1351:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
120.
  Callsite: Points(xs)
  Args: IPolyLine2D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IPolyLine2D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IPolyLine2D = UnknownParamIsTypeVar
121.
  Callsite: WithNext(Points(xs), (\(ParameterDef=a$17949:Concept:IAny, ParameterDef=b$17951:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>, Closed(xs))
  Args: $70:constraint=(IArray, Vector2D), (Function2, $1353:, $1354:, $1355:), Boolean
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
122.
  Callsite: Points(xs)
  Args: IPolyLine3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IPolyLine3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IPolyLine3D = UnknownParamIsTypeVar
123.
  Callsite: WithNext(Points(xs), (\(ParameterDef=a$17987:Concept:IAny, ParameterDef=b$17989:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>, Closed(xs))
  Args: $70:constraint=(IArray, Vector2D), (Function2, $1357:, $1358:, $1359:), Boolean
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
124.
  Callsite: FlatMap(Lines(xs), (\(ParameterDef=x$17685:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $866:constraint=(IArray, Line3D), (Function1, $1361:, $1362:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
125.
  Callsite: Points(x)
  Args: IPointArray3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IPointArray3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IPointArray3D = UnknownParamIsTypeVar
126.
  Callsite: Indices(Points(x))
  Args: $70:constraint=(IArray, Vector2D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
127.
  Callsite: Map(Slices(Indices(g), PrimitiveSize(g)), (\(ParameterDef=xs$14763:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $633:constraint=(IArray, (IArray, $632:)), (Function1, $1364:, $1365:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
128.
  Callsite: Map(AllFaceVertices(x), (\(ParameterDef=xs$14847:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $861:constraint=(IArray, (IArray, Vector2D)), (Function1, $1367:, $1368:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
129.
  Callsite: FlatMap(Lines(xs), (\(ParameterDef=x$17661:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $865:constraint=(IArray, Line2D), (Function1, $1370:, $1371:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
130.
  Callsite: Points(x)
  Args: IPointArray2D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IPointArray2D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IPointArray2D = UnknownParamIsTypeVar
131.
  Callsite: Indices(Points(x))
  Args: $70:constraint=(IArray, Vector2D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $70:constraint=(IArray, Vector2D) = UnknownArgIsTypeVar
132.
  Callsite: Map(Indices(self), (\(ParameterDef=i$6529:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $614:constraint=(IArray, Integer), (Function1, $1373:, $1374:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
133.
  Callsite: MakeArray2D(Count(columns), Count(rows), (\(ParameterDef=i$6579:Concept:IAny, ParameterDef=j$6581:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: Integer, Integer, (Function2, $1376:, $1377:, $1378:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
134.
  Callsite: Map(Indices(self), (\(ParameterDef=i$6621:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $614:constraint=(IArray, Integer), (Function1, $1380:, $1381:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
135.
  Callsite: MapRange(Add(Count(xs), Count(ys)), (\(ParameterDef=i$6674:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1383:, $1384:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
136.
  Callsite: MapRange(Add(Count(self), 1), (\(ParameterDef=i$6734:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1386:, $1387:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
137.
  Callsite: MapRange(Add(Count(self), 1), (\(ParameterDef=i$6783:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: Integer, (Function1, $1389:, $1390:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
138.
  Callsite: Zip(Components(x), Components(a), Components(b), (\(ParameterDef=x0$8487:Concept:IAny, ParameterDef=a0$8489:Concept:IAny, ParameterDef=b0$8491:Concept:IAny) -> ConcreteType:Function3<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>)
  Args: $24:constraint=(IArray, Number), $24:constraint=(IArray, Number), $24:constraint=(IArray, Number), (Function3, $1392:, $1393:, $1394:, $1395:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
139.
  Callsite: All(Zip(Components(x), Components(a), Components(b), (\(ParameterDef=x0$8487:Concept:IAny, ParameterDef=a0$8489:Concept:IAny, ParameterDef=b0$8491:Concept:IAny) -> ConcreteType:Function3<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>), (\(ParameterDef=x0$8516:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $1396:, (Function1, $1397:, $1398:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
140.
  Callsite: Between(value, Min(x), Max(x))
  Args: $754:, $47:, $49:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Between(self: IReal, min: IReal, max: IReal): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = self:IReal <= $754: = UnknownArgIsTypeVar
      Argument 1 = min:IReal <= $47: = UnknownArgIsTypeVar
      Argument 2 = max:IReal <= $49: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Between(x: INumerical, a: INumerical, b: INumerical): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $754: = UnknownArgIsTypeVar
      Argument 1 = a:INumerical <= $47: = UnknownArgIsTypeVar
      Argument 2 = b:INumerical <= $49: = UnknownArgIsTypeVar
141.
  Callsite: Between(value, Start(x), End(x))
  Args: $952:, $43:, $45:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Between(self: IReal, min: IReal, max: IReal): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = self:IReal <= $952: = UnknownArgIsTypeVar
      Argument 1 = min:IReal <= $43: = UnknownArgIsTypeVar
      Argument 2 = max:IReal <= $45: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Between(x: INumerical, a: INumerical, b: INumerical): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $952: = UnknownArgIsTypeVar
      Argument 1 = a:INumerical <= $43: = UnknownArgIsTypeVar
      Argument 2 = b:INumerical <= $45: = UnknownArgIsTypeVar
142.
  Callsite: Contains(x, Start(y))
  Args: (IInterval, $953:), $43:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $953:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $43: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $953:) = FitEquality
      Argument 1 = y:(IInterval, $954:) <= $43: = UnknownArgIsTypeVar
143.
  Callsite: Contains(x, End(y))
  Args: (IInterval, $953:), $45:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $953:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $45: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $953:) = FitEquality
      Argument 1 = y:(IInterval, $954:) <= $45: = UnknownArgIsTypeVar
144.
  Callsite: Contains(x, Min(y))
  Args: (IBounds, $755:), $47:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $755:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $47: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $755:) = FitEquality
      Argument 1 = y:(IBounds, $756:) <= $47: = UnknownArgIsTypeVar
145.
  Callsite: Contains(x, Max(y))
  Args: (IBounds, $755:), $49:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $755:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $49: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $755:) = FitEquality
      Argument 1 = y:(IBounds, $756:) <= $49: = UnknownArgIsTypeVar
146.
  Callsite: Contains(x, Min(y))
  Args: (IBounds, $757:), $47:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $757:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $47: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $757:) = FitConceptInheritsConcept
      Argument 1 = y:(IBounds, $756:) <= $47: = UnknownArgIsTypeVar
147.
  Callsite: Contains(x, Max(y))
  Args: (IBounds, $757:), $49:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $757:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $49: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $757:) = FitConceptInheritsConcept
      Argument 1 = y:(IBounds, $756:) <= $49: = UnknownArgIsTypeVar
148.
  Callsite: Contains(y, Min(x))
  Args: (IBounds, $758:), $47:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $758:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $47: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $758:) = FitConceptInheritsConcept
      Argument 1 = y:(IBounds, $756:) <= $47: = UnknownArgIsTypeVar
149.
  Callsite: Contains(y, Max(x))
  Args: (IBounds, $758:), $49:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Contains(x: (IBounds, $753:), value: $754:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $753:) <= (IBounds, $758:) = FitConceptInheritsConcept
      Argument 1 = value:$754: <= $49: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Contains(x: (IBounds, $755:), y: (IBounds, $756:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $755:) <= (IBounds, $758:) = FitConceptInheritsConcept
      Argument 1 = y:(IBounds, $756:) <= $49: = UnknownArgIsTypeVar
150.
  Callsite: Subtract(c, Half(Size(x)))
  Args: $760:, $792:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $760: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $760: = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
151.
  Callsite: Add(c, Half(Size(x)))
  Args: $760:, $792:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $760: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $760: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $760: = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
152.
  Callsite: Zip(Components(x), Components(a), Components(b), (\(ParameterDef=x0$8570:Concept:IAny, ParameterDef=a0$8572:Concept:IAny, ParameterDef=b0$8574:Concept:IAny) -> ConcreteType:Function3<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>)
  Args: $24:constraint=(IArray, Number), $24:constraint=(IArray, Number), $24:constraint=(IArray, Number), (Function3, $1402:, $1403:, $1404:, $1405:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
153.
  Callsite: Clamp(x, Start(y))
  Args: (IInterval, $983:), $43:
  Possible Return Types: $986:constraint=(IInterval, $985:), $989:
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Clamp(x: (IInterval, $983:), y: (IInterval, $984:)): $986:constraint=(IInterval, $985:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $983:) <= (IInterval, $983:) = FitEquality
      Argument 1 = y:(IInterval, $984:) <= $43: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Clamp(x: (IInterval, $987:), value: $988:): $989:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $987:) <= (IInterval, $983:) = FitConceptInheritsConcept
      Argument 1 = value:$988: <= $43: = UnknownArgIsTypeVar
154.
  Callsite: Clamp(x, End(y))
  Args: (IInterval, $983:), $45:
  Possible Return Types: $986:constraint=(IInterval, $985:), $989:
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Clamp(x: (IInterval, $983:), y: (IInterval, $984:)): $986:constraint=(IInterval, $985:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $983:) <= (IInterval, $983:) = FitEquality
      Argument 1 = y:(IInterval, $984:) <= $45: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Clamp(x: (IInterval, $987:), value: $988:): $989:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $987:) <= (IInterval, $983:) = FitConceptInheritsConcept
      Argument 1 = value:$988: <= $45: = UnknownArgIsTypeVar
155.
  Callsite: Clamp(x, Min(y))
  Args: (IBounds, $763:), $47:
  Possible Return Types: $766:constraint=(IBounds, $765:), $769:
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Clamp(x: (IBounds, $763:), y: (IBounds, $764:)): $766:constraint=(IBounds, $765:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $763:) <= (IBounds, $763:) = FitEquality
      Argument 1 = y:(IBounds, $764:) <= $47: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Clamp(x: (IBounds, $767:), value: $768:): $769:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $767:) <= (IBounds, $763:) = FitConceptInheritsConcept
      Argument 1 = value:$768: <= $47: = UnknownArgIsTypeVar
156.
  Callsite: Clamp(x, Max(y))
  Args: (IBounds, $763:), $49:
  Possible Return Types: $766:constraint=(IBounds, $765:), $769:
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Clamp(x: (IBounds, $763:), y: (IBounds, $764:)): $766:constraint=(IBounds, $765:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $763:) <= (IBounds, $763:) = FitEquality
      Argument 1 = y:(IBounds, $764:) <= $49: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Clamp(x: (IBounds, $767:), value: $768:): $769:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $767:) <= (IBounds, $763:) = FitConceptInheritsConcept
      Argument 1 = value:$768: <= $49: = UnknownArgIsTypeVar
157.
  Callsite: Include(x, Min(y))
  Args: (IBounds, $774:), $47:
  Possible Return Types: $773:constraint=(IBounds, $772:), $777:constraint=(IBounds, $776:)
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Include(x: (IBounds, $770:), value: $771:): $773:constraint=(IBounds, $772:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $770:) <= (IBounds, $774:) = FitConceptInheritsConcept
      Argument 1 = value:$771: <= $47: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Include(x: (IBounds, $774:), y: (IBounds, $775:)): $777:constraint=(IBounds, $776:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $774:) <= (IBounds, $774:) = FitEquality
      Argument 1 = y:(IBounds, $775:) <= $47: = UnknownArgIsTypeVar
158.
  Callsite: Include(Include(x, Min(y)), Max(y))
  Args: $773:constraint=(IBounds, $772:), $49:
  Possible Return Types: $773:constraint=(IBounds, $772:), $777:constraint=(IBounds, $776:)
  Callable function count: 2
  Best function count: 2
    Function = IBounds_2:Library.Include(x: (IBounds, $770:), value: $771:): $773:constraint=(IBounds, $772:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $770:) <= $773:constraint=(IBounds, $772:) = UnknownArgIsTypeVar
      Argument 1 = value:$771: <= $49: = UnknownArgIsTypeVar
    Function = IBounds_2:Library.Include(x: (IBounds, $774:), y: (IBounds, $775:)): $777:constraint=(IBounds, $776:)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IBounds, $774:) <= $773:constraint=(IBounds, $772:) = UnknownArgIsTypeVar
      Argument 1 = y:(IBounds, $775:) <= $49: = UnknownArgIsTypeVar
159.
  Callsite: Multiply(x, 2)
  Args: IScalarArithmetic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
160.
  Callsite: Twice(Pi)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
161.
  Callsite: Half(Pi)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
162.
  Callsite: Divide(Pi, 180)
  Args: IAny, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IAny = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IAny = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
163.
  Callsite: MapComponents(x, (\(ParameterDef=i$8254:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1430:, $1431:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
164.
  Callsite: MapComponents(x, (\(ParameterDef=a$9140:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1433:, $1434:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
165.
  Callsite: Reduce(v, 0, (\(ParameterDef=a$13903:Concept:IAny, ParameterDef=b$13905:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: IVector, Number, (Function2, $1440:, $1441:, $1442:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
166.
  Callsite: MagnitudeSquared(Vector4D(q))
  Args: Vector4D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
167.
  Callsite: Pow(E, x)
  Args: IAny, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
168.
  Callsite: Square(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
169.
  Callsite: Twice(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
170.
  Callsite: Multiply(Square(x), Subtract(3, Twice(x)))
  Args: $1446:, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1446: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1446: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1446: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1446: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1446: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1446: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
171.
  Callsite: MapComponents(x, (\(ParameterDef=i$8236:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1448:, $1449:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
172.
  Callsite: MapComponents(x, (\(ParameterDef=i$8630:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1451:, $1452:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
173.
  Callsite: Abs(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
174.
  Callsite: Abs(y)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
175.
  Callsite: Abs(Subtract(x, y))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
176.
  Callsite: Abs(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
177.
  Callsite: LessThan(Abs(x), Epsilon)
  Args: $1457:, IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
178.
  Callsite: AlmostEqual(x, 0)
  Args: Number, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
179.
  Callsite: AlmostEqual(x, 1)
  Args: Number, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
180.
  Callsite: MapComponents(n, (\(ParameterDef=c$8713:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1461:, $1462:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
181.
  Callsite: Map(Range(x), (\(ParameterDef=i$7682:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $612:constraint=(IArray, Integer), (Function1, $1464:, $1465:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
182.
  Callsite: Value(x)
  Args: IReal
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
183.
  Callsite: Divide(x, 4)
  Args: IScalarArithmetic, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
184.
  Callsite: Divide(x, 8)
  Args: IScalarArithmetic, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
185.
  Callsite: Divide(x, 16)
  Args: IScalarArithmetic, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
186.
  Callsite: Divide(x, 10)
  Args: IScalarArithmetic, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
187.
  Callsite: Multiply(x, 100)
  Args: IScalarArithmetic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
188.
  Callsite: Multiply(x, 1000)
  Args: IScalarArithmetic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IScalarArithmetic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
189.
  Callsite: Count(Components(x))
  Args: $24:constraint=(IArray, Number)
  Possible Return Types: Integer
  Callable function count: 10
  Best function count: 7
    Function = ArrayLibrary_0:Library.Count(xs: (IArray2D, $615:)): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray2D, $615:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = ArrayLibrary_0:Library.Count(xs: (IArray3D, $616:)): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray3D, $616:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(c: Complex): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = c:Complex <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector2D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector2D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector3D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector3D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector4D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector4D <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(x: RegularPolygon): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:RegularPolygon <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Count(x: String): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:String <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Count(xs: (Array, $1046:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array, $1046:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
    Function = IArray_28:Concept.Count(xs: $1:constraint=(IArray, $0:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$1:constraint=(IArray, $0:) <= $24:constraint=(IArray, Number) = UnknownArgIsTypeVar
190.
  Callsite: MapComponents(x, (\(ParameterDef=x$8396:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1468:, $1469:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
191.
  Callsite: MapComponents(x, (\(ParameterDef=x$8417:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1471:, $1472:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
192.
  Callsite: All(Components(x), predicate)
  Args: $24:constraint=(IArray, Number), (Function1, Number, Boolean)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
193.
  Callsite: Any(Components(x), predicate)
  Args: $24:constraint=(IArray, Number), (Function1, Number, Boolean)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
194.
  Callsite: MapComponents(n, (\(ParameterDef=c$8734:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: INumerical, (Function1, $1476:, $1477:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
195.
  Callsite: Compare(ToNumber(a), ToNumber(b))
  Args: Number, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
196.
  Callsite: Multiply(Add(v1, Subtract(v2, v1)), X(uv))
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
197.
  Callsite: Multiply(Subtract(v3, v1), Y(uv))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
198.
  Callsite: Map(LinearSpace(count), (\(ParameterDef=x$18508:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $990:constraint=(IArray, Number), (Function1, $1480:, $1481:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
199.
  Callsite: Map(LinearSpace(numPoints), (\(ParameterDef=x$9339:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $990:constraint=(IArray, Number), (Function1, $1483:, $1484:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
200.
  Callsite: Map(LinearSpace(numPoints), (\(ParameterDef=x$9367:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $990:constraint=(IArray, Number), (Function1, $1486:, $1487:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
201.
  Callsite: Sqr(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
202.
  Callsite: Cube(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
203.
  Callsite: Sqr(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
204.
  Callsite: Sqr(x)
  Args: IMultiplicative
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
205.
  Callsite: Parabola(x)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
206.
  Callsite: Cube(Subtract(1, t))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
207.
  Callsite: Multiply(a, Cube(Subtract(1, t)))
  Args: IAlgebraic, $1498:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1498: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1498: = UnknownArgIsTypeVar
208.
  Callsite: Sqr(Subtract(1, t))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
209.
  Callsite: Multiply(Sqr(Subtract(1, t)), t)
  Args: $1499:, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1499: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1499: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1499: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1499: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1499: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1499: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
210.
  Callsite: Multiply(b, Multiply(3, Multiply(Sqr(Subtract(1, t)), t)))
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
211.
  Callsite: Sqr(t)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
212.
  Callsite: Multiply(c, Multiply(3, Multiply(Subtract(1, t), Sqr(t))))
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
213.
  Callsite: Cube(t)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
214.
  Callsite: Multiply(d, Cube(t))
  Args: IAlgebraic, $1501:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1501: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1501: = UnknownArgIsTypeVar
215.
  Callsite: Add(Multiply(c, Multiply(3, Multiply(Subtract(1, t), Sqr(t)))), Multiply(d, Cube(t)))
  Args: $35:constraint=IScalarArithmetic, $35:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
216.
  Callsite: Sqr(Subtract(1, t))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
217.
  Callsite: Multiply(Subtract(b, a), Multiply(3, Sqr(Subtract(1, t))))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
218.
  Callsite: Multiply(Subtract(c, b), Multiply(6, Multiply(Subtract(1, t), t)))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
219.
  Callsite: Sqr(t)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
220.
  Callsite: Multiply(Subtract(d, c), Multiply(3, Sqr(t)))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
221.
  Callsite: Multiply(b, 2)
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
222.
  Callsite: Multiply(Subtract(c, Add(Multiply(b, 2), a)), Multiply(6, Subtract(1, t)))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
223.
  Callsite: Multiply(c, 2)
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
224.
  Callsite: Multiply(Subtract(d, Add(Multiply(c, 2), a)), Multiply(6, t))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
225.
  Callsite: Sqr(Subtract(1, t))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
226.
  Callsite: Multiply(a, Sqr(Subtract(1, t)))
  Args: IAlgebraic, $1504:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1504: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1504: = UnknownArgIsTypeVar
227.
  Callsite: Multiply(b, Multiply(2, Multiply(Subtract(1, t), t)))
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
228.
  Callsite: Sqr(t)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
229.
  Callsite: Multiply(c, Sqr(t))
  Args: IAlgebraic, $1505:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1505: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1505: = UnknownArgIsTypeVar
230.
  Callsite: Add(Multiply(b, Multiply(2, Multiply(Subtract(1, t), t))), Multiply(c, Sqr(t)))
  Args: $35:constraint=IScalarArithmetic, $35:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
231.
  Callsite: Multiply(Subtract(b, b), Multiply(2, Subtract(1, t)))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
232.
  Callsite: Multiply(Subtract(c, b), Multiply(2, t))
  Args: $31:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
233.
  Callsite: Multiply(b, 2)
  Args: IAlgebraic, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAlgebraic = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
234.
  Callsite: Multiply(Turns(t), numTurns)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
235.
  Callsite: Cos(Multiply(Turns(t), numTurns))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
236.
  Callsite: Multiply(Turns(t), numTurns)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
237.
  Callsite: Sin(Multiply(Turns(t), numTurns))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
238.
  Callsite: New(Vector2D, Cos(Multiply(Turns(t), numTurns)), Sin(Multiply(Turns(t), numTurns)))
  Args: Type, Number, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
239.
  Callsite: Lerp(r, R, t)
  Args: Number, Number, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
240.
  Callsite: Multiply(New(Vector2D, Cos(Multiply(Turns(t), numTurns)), Sin(Multiply(Turns(t), numTurns))), Lerp(r, R, t))
  Args: $1506:, $1507:
  Possible Return Types: Number, Integer, Vector3D, Matrix4x4, Quaternion
  Callable function count: 12
  Best function count: 7
    Function = INumerical_4:Library.Multiply(x: INumberLike, y: INumberLike): $787:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumberLike <= $1506: = UnknownArgIsTypeVar
      Argument 1 = y:INumberLike <= $1507: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1506: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= $1507: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Multiply(x: IVector, y: IVector): $830:constraint=IVector
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IVector <= $1506: = UnknownArgIsTypeVar
      Argument 1 = y:IVector <= $1507: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1506: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $1507: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Multiply(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $1506: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $1507: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, v: Vector3D): Vector3D
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1506: = UnknownArgIsTypeVar
      Argument 1 = v:Vector3D <= $1507: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1506: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= $1507: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Multiply(a: Matrix4x4, b: Matrix4x4): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = a:Matrix4x4 <= $1506: = UnknownArgIsTypeVar
      Argument 1 = b:Matrix4x4 <= $1507: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1506: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= $1507: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Multiply(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $1506: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $1507: = UnknownArgIsTypeVar
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1506: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= $1507: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1506: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1507: = UnknownArgIsTypeVar
241.
  Callsite: QuadraticBezier(A(curve), B(curve), C(curve), t)
  Args: Vector2D, Vector2D, Vector2D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
242.
  Callsite: QuadraticBezier(A(curve), B(curve), C(curve), t)
  Args: Vector2D, Vector2D, Vector2D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
243.
  Callsite: Multiply(UnitCircle(t), radius)
  Args: Vector2D, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector2D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector2D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
244.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
245.
  Callsite: Cos(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
246.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
247.
  Callsite: Sin(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
248.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
249.
  Callsite: Cos(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
250.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
251.
  Callsite: Sin(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
252.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
253.
  Callsite: Cos(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
254.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
255.
  Callsite: Sin(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
256.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
257.
  Callsite: Cos(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
258.
  Callsite: Divide(t, r)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
259.
  Callsite: Sin(Divide(t, r))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
260.
  Callsite: Divide(t, 6)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
261.
  Callsite: Exp(Cos(t))
  Args: Number
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Exp(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Exp(x: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
262.
  Callsite: Multiply(t, 4)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
263.
  Callsite: Cos(Multiply(t, 4))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
264.
  Callsite: Divide(t, 12)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
265.
  Callsite: Sin(Divide(t, 12))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
266.
  Callsite: Multiply(t, Subtract(Exp(Cos(t)), Subtract(Multiply(2, Cos(Multiply(t, 4))), Pow(Sin(Divide(t, 12)), 5))))
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
267.
  Callsite: Sin(Multiply(t, Subtract(Exp(Cos(t)), Subtract(Multiply(2, Cos(Multiply(t, 4))), Pow(Sin(Divide(t, 12)), 5)))))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
268.
  Callsite: Exp(Cos(t))
  Args: Number
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Exp(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Exp(x: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
269.
  Callsite: Multiply(t, 4)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
270.
  Callsite: Cos(Multiply(t, 4))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
271.
  Callsite: Divide(t, 12)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
272.
  Callsite: Sin(Divide(t, 12))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
273.
  Callsite: Multiply(t, Subtract(Exp(Cos(t)), Subtract(Multiply(2, Cos(Multiply(t, 4))), Pow(Sin(Divide(t, 12)), 5))))
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
274.
  Callsite: Cos(Multiply(t, Subtract(Exp(Cos(t)), Subtract(Multiply(2, Cos(Multiply(t, 4))), Pow(Sin(Divide(t, 12)), 5)))))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
275.
  Callsite: Sin(Add(t, d))
  Args: $30:constraint=IAdditive
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $30:constraint=IAdditive = UnknownArgIsTypeVar
276.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
277.
  Callsite: Cos(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
278.
  Callsite: Divide(t, 3)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
279.
  Callsite: Cube(Sec(Divide(t, 3)))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
280.
  Callsite: Rose(t, K(curve))
  Args: Angle, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
281.
  Callsite: Sqr(a)
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
282.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
283.
  Callsite: Cos(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
284.
  Callsite: Multiply(Sqr(a), Cos(Multiply(t, 2)))
  Args: $1524:, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1524: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1524: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1524: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1524: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1524: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1524: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
285.
  Callsite: Divide(t, 3)
  Args: Angle, Number
  Possible Return Types: $34:constraint=IScalarArithmetic, $38:constraint=IDivisible
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
286.
  Callsite: Cos(Divide(t, 3))
  Args: $34:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $34:constraint=IScalarArithmetic = UnknownArgIsTypeVar
287.
  Callsite: Multiply(t, n)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
288.
  Callsite: Cos(Multiply(t, n))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
289.
  Callsite: Sqr(Turns(t))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
290.
  Callsite: Exp(Multiply(Radians(t), k))
  Args: Number
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Exp(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Exp(x: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= Number = FitEquality
291.
  Callsite: TorusKnot(t, P(curve), Q(curve))
  Args: Angle, Integer, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
292.
  Callsite: Multiply(TorusKnot(t, P(curve), Q(curve)), Radius(curve))
  Args: $1528:, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1528: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1528: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1528: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1528: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1528: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1528: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
293.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
294.
  Callsite: Sin(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
295.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
296.
  Callsite: Cos(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
297.
  Callsite: Multiply(t, 3)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
298.
  Callsite: Sin(Multiply(t, 3))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
299.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
300.
  Callsite: Cos(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
301.
  Callsite: Multiply(t, 3)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
302.
  Callsite: Cos(Multiply(t, 3))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
303.
  Callsite: Multiply(t, 2)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
304.
  Callsite: Cos(Multiply(t, 2))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
305.
  Callsite: Multiply(t, 3)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
306.
  Callsite: Sin(Multiply(t, 3))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
307.
  Callsite: Multiply(t, 4)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
308.
  Callsite: Sin(Multiply(t, 4))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
309.
  Callsite: Multiply(t, revs)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
310.
  Callsite: Sin(Multiply(t, revs))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Sin(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Sin(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
311.
  Callsite: Multiply(t, revs)
  Args: Angle, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Angle = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Angle = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
312.
  Callsite: Cos(Multiply(t, revs))
  Args: $35:constraint=IScalarArithmetic
  Possible Return Types: Number
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Cos(x: Number): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Cos(x: Angle): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Angle <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
313.
  Callsite: GetPoint(curve, Turns(t))
  Args: IAngularCurve2D, Angle
  Possible Return Types: Vector2D, Vector3D
  Callable function count: 2
  Best function count: 2
    Function = IAngularCurve2D_160:Concept.GetPoint(curve: $52:constraint=IAngularCurve2D, t: Angle): Vector2D
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = curve:$52:constraint=IAngularCurve2D <= IAngularCurve2D = UnknownParamIsTypeVar
      Argument 1 = t:Angle <= Angle = FitEquality
    Function = IAngularCurve3D_210:Concept.GetPoint(curve: $54:constraint=IAngularCurve3D, t: Angle): Vector3D
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = curve:$54:constraint=IAngularCurve3D <= IAngularCurve2D = UnknownParamIsTypeVar
      Argument 1 = t:Angle <= Angle = FitEquality
314.
  Callsite: Dot(Vector4D(q1), Vector4D(q2))
  Args: Vector4D, Vector4D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
315.
  Callsite: Magnitude(Vector4D(q))
  Args: Vector4D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
316.
  Callsite: Angle(Direction(a), Direction(b))
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
317.
  Callsite: New(Vector2D, Cos(Angle(coord)), Sin(Angle(coord)))
  Args: Type, Number, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
318.
  Callsite: Multiply(New(Vector2D, Cos(Angle(coord)), Sin(Angle(coord))), Radius(coord))
  Args: $1544:, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Multiply(x: INumerical, s: Number): $824:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $1544: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Multiply(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $1544: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $1544: = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Multiply(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $1544: = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= $1544: = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= $1544: = UnknownArgIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
319.
  Callsite: QuadraticBezier(A(curve), B(curve), C(curve), t)
  Args: Vector3D, Vector3D, Vector3D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
320.
  Callsite: QuadraticBezier(A(curve), B(curve), C(curve), t)
  Args: Vector3D, Vector3D, Vector3D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
321.
  Callsite: GetPoint(curve, Turns(t))
  Args: IAngularCurve3D, Angle
  Possible Return Types: Vector2D, Vector3D
  Callable function count: 2
  Best function count: 2
    Function = IAngularCurve2D_160:Concept.GetPoint(curve: $52:constraint=IAngularCurve2D, t: Angle): Vector2D
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = curve:$52:constraint=IAngularCurve2D <= IAngularCurve3D = UnknownParamIsTypeVar
      Argument 1 = t:Angle <= Angle = FitEquality
    Function = IAngularCurve3D_210:Concept.GetPoint(curve: $54:constraint=IAngularCurve3D, t: Angle): Vector3D
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = curve:$54:constraint=IAngularCurve3D <= IAngularCurve3D = UnknownParamIsTypeVar
      Argument 1 = t:Angle <= Angle = FitEquality
322.
  Callsite: Length(Subtract(B(x), A(x)))
  Args: $31:constraint=IAdditive
  Possible Return Types: Number, Length
  Callable function count: 4
  Best function count: 3
    Function = IGeometry_18:Library.Length(x: Line2D): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Line2D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Length(x: Line3D): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Line3D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Length(a: IVector): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:IVector <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = Length_128:ConcreteType.Length(Meters: Number): Length
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = Meters:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
323.
  Callsite: Length(Subtract(B(x), A(x)))
  Args: $31:constraint=IAdditive
  Possible Return Types: Number, Length
  Callable function count: 4
  Best function count: 3
    Function = IGeometry_18:Library.Length(x: Line2D): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Line2D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Length(x: Line3D): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Line3D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Length(a: IVector): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:IVector <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = Length_128:ConcreteType.Length(Meters: Number): Length
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = Meters:Number <= $31:constraint=IAdditive = UnknownArgIsTypeVar
324.
  Callsite: GreaterThan(MagnitudeSquared(x), 0)
  Args: Number, Integer
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
325.
  Callsite: Normalize(Vector4D(q))
  Args: Vector4D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
326.
  Callsite: Normalize(Direction(x))
  Args: Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
327.
  Callsite: Min(A(x), B(x))
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
328.
  Callsite: Max(A(x), B(x))
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
329.
  Callsite: Half(Add(Multiply(X(A(t)), Subtract(Y(C(t)), Y(B(t)))), Add(Multiply(X(B(t)), Subtract(Y(A(t)), Y(C(t)))), Multiply(X(C(t)), Subtract(Y(B(t)), Y(A(t)))))))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
330.
  Callsite: Barycentric(A(t), B(t), C(t), uv)
  Args: Vector3D, Vector3D, Vector3D, Vector2D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
331.
  Callsite: Barycentric(A(t), B(t), C(t), uv)
  Args: Vector3D, Vector3D, Vector3D, Vector2D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
332.
  Callsite: Barycentric(A(t), B(t), C(t), uv)
  Args: Vector2D, Vector2D, Vector2D, Vector2D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
333.
  Callsite: Cross(Subtract(B(t), A(t)), Subtract(C(t), A(t)))
  Args: $31:constraint=IAdditive, $31:constraint=IAdditive
  Possible Return Types: Number, Vector3D
  Callable function count: 2
  Best function count: 2
    Function = IGeometry_18:Library.Cross(a: Vector2D, b: Vector2D): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = a:Vector2D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:Vector2D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Cross(a: Vector3D, b: Vector3D): Vector3D
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = a:Vector3D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:Vector3D <= $31:constraint=IAdditive = UnknownArgIsTypeVar
334.
  Callsite: Normalize(Cross(Subtract(B(t), A(t)), Subtract(C(t), A(t))))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
335.
  Callsite: Dot(Normal(t), A(t))
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
336.
  Callsite: Divide(Add(a, b), 2)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
337.
  Callsite: Divide(Add(a, b), 2)
  Args: $30:constraint=IAdditive, Number
  Possible Return Types: Number, Matrix4x4, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Divide(x: INumerical, s: Number): $825:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumerical <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Intrinsics_22:Library.Divide(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = y:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(m: Matrix4x4, s: Number): Matrix4x4
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = m:Matrix4x4 <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = s:Number <= Number = FitEquality
    Function = Transforms_26:Library.Divide(q: Quaternion, scalar: Number): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q:Quaternion <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = scalar:Number <= Number = FitEquality
    Function = IScalarArithmetic_58:Concept.Divide(self: $34:constraint=IScalarArithmetic, other: Number): $34:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$34:constraint=IScalarArithmetic <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IDivisible_70:Concept.Divide(a: $38:constraint=IDivisible, b: $38:constraint=IDivisible): $38:constraint=IDivisible
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$38:constraint=IDivisible <= $30:constraint=IAdditive = UnknownArgIsTypeVar
      Argument 1 = b:$38:constraint=IDivisible <= Number = UnknownParamIsTypeVar
338.
  Callsite: Dot(Normal(p), v)
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
339.
  Callsite: Multiply(Normal(p), Dot(Normal(p), v))
  Args: Vector3D, $1689:
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= Vector3D = UnknownParamIsTypeVar
      Argument 1 = other:Number <= $1689: = UnknownArgIsTypeVar
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= Vector3D = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= $1689: = UnknownArgIsTypeVar
340.
  Callsite: Dot(Cross(a, b), c)
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
341.
  Callsite: Dot(a, b)
  Args: Vector3D, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
342.
  Callsite: Abs(Dot(a, b))
  Args: $1697:
  Possible Return Types: $790:constraint=IReal, $814:constraint=INumerical
  Callable function count: 2
  Best function count: 2
    Function = INumerical_4:Library.Abs(x: IReal): $790:constraint=IReal
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IReal <= $1697: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Abs(x: INumerical): $814:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $1697: = UnknownArgIsTypeVar
343.
  Callsite: GreaterThan(Abs(Dot(a, b)), Subtract(1, 1E-06))
  Args: $790:constraint=IReal, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
344.
  Callsite: MaxValue(Vector3D)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
345.
  Callsite: MinValue(Vector3D)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
346.
  Callsite: Empty(Bounds3D)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
347.
  Callsite: Reduce(xs, Empty(Bounds3D), (\(ParameterDef=a$14387:Concept:IAny, ParameterDef=b$14389:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: (IArray, Vector3D), $1710:, (Function2, $1711:, $1712:, $1713:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
348.
  Callsite: Lerp(A(x), B(x), t)
  Args: Vector2D, Vector2D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
349.
  Callsite: Lerp(A(x), B(x), t)
  Args: Vector3D, Vector3D, Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
350.
  Callsite: Count(Indices(g))
  Args: $86:constraint=(IArray, Integer)
  Possible Return Types: Integer
  Callable function count: 10
  Best function count: 7
    Function = ArrayLibrary_0:Library.Count(xs: (IArray2D, $615:)): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray2D, $615:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = ArrayLibrary_0:Library.Count(xs: (IArray3D, $616:)): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray3D, $616:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(c: Complex): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = c:Complex <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector2D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector2D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector3D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector3D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(v: Vector4D): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = v:Vector4D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Count(x: RegularPolygon): Integer
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:RegularPolygon <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Count(x: String): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:String <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Count(xs: (Array, $1046:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(Array, $1046:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
    Function = IArray_28:Concept.Count(xs: $1:constraint=(IArray, $0:)): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:$1:constraint=(IArray, $0:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
351.
  Callsite: Map(FaceIndices(g, f), (\(ParameterDef=i$14588:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $855:constraint=(IArray, Integer), (Function1, $1717:, $1718:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
352.
  Callsite: Map(FaceIndices(g, f), (\(ParameterDef=i$14618:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $855:constraint=(IArray, Integer), (Function1, $1720:, $1721:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
353.
  Callsite: Points(g)
  Args: IIndexedGeometry2D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IIndexedGeometry2D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IIndexedGeometry2D = UnknownParamIsTypeVar
354.
  Callsite: At(Indices(g), n)
  Args: $86:constraint=(IArray, Integer), Integer
  Possible Return Types: Number, Vector2D, Character, $1053:
  Callable function count: 10
  Best function count: 7
    Function = ArrayLibrary_0:Library.At(xs: (IArray2D, $617:), i: Integer): $618:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray2D, $617:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = ArrayLibrary_0:Library.At(xs: (IArray3D, $619:), i: Integer): $620:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray3D, $619:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(c: Complex, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = c:Complex <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector2D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector2D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector3D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector3D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector4D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector4D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(x: RegularPolygon, n: Integer): Vector2D
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:RegularPolygon <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(x: String, y: Integer): Character
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:String <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(xs: (Array, $1052:), n: Integer): $1053:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = xs:(Array, $1052:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IArray_28:Concept.At(xs: $3:constraint=(IArray, $2:), n: Integer): $2:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:$3:constraint=(IArray, $2:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
355.
  Callsite: At(Points(g), At(Indices(g), n))
  Args: $70:constraint=(IArray, Vector2D), Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
356.
  Callsite: Points(g)
  Args: IIndexedGeometry3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IIndexedGeometry3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IIndexedGeometry3D = UnknownParamIsTypeVar
357.
  Callsite: At(Indices(g), n)
  Args: $86:constraint=(IArray, Integer), Integer
  Possible Return Types: Number, Vector2D, Character, $1053:
  Callable function count: 10
  Best function count: 7
    Function = ArrayLibrary_0:Library.At(xs: (IArray2D, $617:), i: Integer): $618:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray2D, $617:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = ArrayLibrary_0:Library.At(xs: (IArray3D, $619:), i: Integer): $620:
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:(IArray3D, $619:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = i:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(c: Complex, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = c:Complex <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector2D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector2D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector3D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector3D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(v: Vector4D, n: Integer): Number
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector4D <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IGeometry_18:Library.At(x: RegularPolygon, n: Integer): Vector2D
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:RegularPolygon <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(x: String, y: Integer): Character
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:String <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= Integer = FitEquality
    Function = Intrinsics_22:Library.At(xs: (Array, $1052:), n: Integer): $1053:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = xs:(Array, $1052:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
    Function = IArray_28:Concept.At(xs: $3:constraint=(IArray, $2:), n: Integer): $2:
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = xs:$3:constraint=(IArray, $2:) <= $86:constraint=(IArray, Integer) = UnknownArgIsTypeVar
      Argument 1 = n:Integer <= Integer = FitEquality
358.
  Callsite: At(Points(g), At(Indices(g), n))
  Args: $70:constraint=(IArray, Vector2D), Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
359.
  Callsite: Map(xs, (\(ParameterDef=i$14703:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Integer), (Function1, $1725:, $1726:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
360.
  Callsite: Map(xs, (\(ParameterDef=i$14729:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: (IArray, Integer), (Function1, $1728:, $1729:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
361.
  Callsite: Points(g)
  Args: ITriangleMesh3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= ITriangleMesh3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= ITriangleMesh3D = UnknownParamIsTypeVar
362.
  Callsite: FlatMap(AllFaceIndices(g), (\(ParameterDef=a$15242:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $858:constraint=(IArray, (IArray, Integer)), (Function1, $1731:, $1732:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
363.
  Callsite: Points(g)
  Args: IQuadMesh3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IQuadMesh3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IQuadMesh3D = UnknownParamIsTypeVar
364.
  Callsite: FlatMap(AllFaceIndices(g), (\(ParameterDef=a$15295:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $858:constraint=(IArray, (IArray, Integer)), (Function1, $1736:, $1737:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
365.
  Callsite: Indices(Points(self))
  Args: $931:constraint=(IArray, Vector3D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $931:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
366.
  Callsite: Indices(Points(g))
  Args: $929:constraint=(IArray, Vector3D)
  Possible Return Types: $894:constraint=(IArray, Integer), $92:constraint=(IArray, Integer), $94:constraint=(IArray, Integer), $96:constraint=(IArray, Integer)
  Callable function count: 14
  Best function count: 4
    Function = ArrayLibrary_0:Library.Indices(xs: (IArray, $613:)): $614:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = xs:(IArray, $613:) <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray2D): $871:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IPointArray3D): $872:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IPointArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray2D): $873:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ILineArray3D): $874:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ILineArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray2D): $875:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: ITriangleArray3D): $876:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:ITriangleArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray2D): $877:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray2D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: IQuadArray3D): $878:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:IQuadArray3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IGeometry_18:Library.Indices(x: QuadGrid3D): $894:constraint=(IArray, Integer)
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:QuadGrid3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = IIndexedGeometry_332:Concept.Indices(x: $85:constraint=IIndexedGeometry): $86:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$85:constraint=IIndexedGeometry <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = LineMesh3D_412:ConcreteType.Indices(self: LineMesh3D): $92:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:LineMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = TriangleMesh3D_414:ConcreteType.Indices(self: TriangleMesh3D): $94:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:TriangleMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
    Function = QuadMesh3D_416:ConcreteType.Indices(self: QuadMesh3D): $96:constraint=(IArray, Integer)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:QuadMesh3D <= $929:constraint=(IArray, Vector3D) = UnknownArgIsTypeVar
367.
  Callsite: Points(g)
  Args: IQuadMesh3D
  Possible Return Types: $70:constraint=(IArray, Vector2D), $72:constraint=(IArray, Vector3D)
  Callable function count: 2
  Best function count: 2
    Function = IPointGeometry2D_312:Concept.Points(x: $69:constraint=IPointGeometry2D): $70:constraint=(IArray, Vector2D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$69:constraint=IPointGeometry2D <= IQuadMesh3D = UnknownParamIsTypeVar
    Function = IPointGeometry3D_314:Concept.Points(x: $71:constraint=IPointGeometry3D): $72:constraint=(IArray, Vector3D)
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:$71:constraint=IPointGeometry3D <= IQuadMesh3D = UnknownParamIsTypeVar
368.
  Callsite: FlatMap(AllFaceIndices(g), (\(ParameterDef=a$15535:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $858:constraint=(IArray, (IArray, Integer)), (Function1, $1748:, $1749:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
369.
  Callsite: Map(Points(x), (\(ParameterDef=p$15728:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $97:constraint=(IArray, Vector2D), (Function1, $1753:, $1754:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
370.
  Callsite: Map(Points(x), f)
  Args: $91:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
371.
  Callsite: Map(Points(x), f)
  Args: $93:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
372.
  Callsite: Map(Points(x), f)
  Args: $95:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
373.
  Callsite: Map(Points(x), f)
  Args: $98:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
374.
  Callsite: Map(Lines(x), (\(ParameterDef=l$16549:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $105:constraint=(IArray, Line3D), (Function1, $1785:, $1786:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
375.
  Callsite: Map(Triangles(x), (\(ParameterDef=t$16585:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $109:constraint=(IArray, Triangle3D), (Function1, $1788:, $1789:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
376.
  Callsite: Map(Points(x), f)
  Args: $101:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
377.
  Callsite: Map(Quads(x), (\(ParameterDef=q$16643:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $113:constraint=(IArray, Quad3D), (Function1, $1792:, $1793:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
378.
  Callsite: Map(PointGrid(x), f)
  Args: $115:constraint=(IArray2D, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
379.
  Callsite: New(QuadGrid3D, Map(PointGrid(x), f), ClosedX(x), ClosedY(x))
  Args: Type, $1795:, Boolean, Boolean
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
380.
  Callsite: Map(Corners(x), f)
  Args: $848:constraint=(IArray, Vector3D), (Function1, Vector3D, Vector3D)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
381.
  Callsite: Deform(x, (\(ParameterDef=v$15801:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1771:, $1772:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
382.
  Callsite: Deform(x, (\(ParameterDef=p$15826:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1799:, $1800:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
383.
  Callsite: Deform(x, q)
  Args: IDeformable3D, Quaternion
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
384.
  Callsite: Deform(x, (\(ParameterDef=p$15862:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1803:, $1804:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
385.
  Callsite: Deform(x, (\(ParameterDef=p$15887:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1806:, $1807:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
386.
  Callsite: AxisAngle(v, theta)
  Args: Vector3D, Angle
  Possible Return Types: AxisAngle
  Callable function count: 2
  Best function count: 2
    Function = Transforms_26:Library.AxisAngle(v: Vector3D, a: Angle): AxisAngle
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = v:Vector3D <= Vector3D = FitEquality
      Argument 1 = a:Angle <= Angle = FitEquality
    Function = AxisAngle_550:ConcreteType.AxisAngle(Axis: Vector3D, Angle: Angle): AxisAngle
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = Axis:Vector3D <= Vector3D = FitEquality
      Argument 1 = Angle:Angle <= Angle = FitEquality
387.
  Callsite: Rotation(XAxis3D, theta)
  Args: IAny, Angle
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
388.
  Callsite: Rotation(YAxis3D, theta)
  Args: IAny, Angle
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
389.
  Callsite: Rotation(ZAxis3D, theta)
  Args: IAny, Angle
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
390.
  Callsite: Deform(x, (\(ParameterDef=p$15954:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1814:, $1815:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
391.
  Callsite: Deform(x, (\(ParameterDef=p$15986:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1817:, $1818:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
392.
  Callsite: Deform(x, (\(ParameterDef=p$16018:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1820:, $1821:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
393.
  Callsite: Deform(x, (\(ParameterDef=p$16050:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1823:, $1824:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
394.
  Callsite: Deform(x, (\(ParameterDef=p$16082:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1826:, $1827:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
395.
  Callsite: Deform(x, (\(ParameterDef=p$16114:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: IDeformable3D, (Function1, $1829:, $1830:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
396.
  Callsite: Half(Sqrt(3))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
397.
  Callsite: Negative(Half(Sqrt(3)))
  Args: $1832:
  Possible Return Types: Number, Integer
  Callable function count: 4
  Best function count: 2
    Function = INumerical_4:Library.Negative(x: INumerical): $829:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $1832: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Negative(x: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Number <= $1832: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Negative(x: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:Integer <= $1832: = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Negative(self: $32:constraint=IAdditive): $32:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = self:$32:constraint=IAdditive <= $1832: = UnknownArgIsTypeVar
398.
  Callsite: Half(Sqrt(3))
  Args: Number
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
399.
  Callsite: Zip(xs, ys, (\(ParameterDef=a$18028:Concept:IAny, ParameterDef=b$18030:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: (IArray, Vector2D), (IArray, Vector2D), (Function2, $1920:, $1921:, $1922:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
400.
  Callsite: Zip(xs, ys, (\(ParameterDef=a$18064:Concept:IAny, ParameterDef=b$18066:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: (IArray, Vector3D), (IArray, Vector3D), (Function2, $1924:, $1925:, $1926:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
401.
  Callsite: Contains(x, Start(y))
  Args: (IInterval, $955:), $43:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $955:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $43: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $955:) = FitConceptInheritsConcept
      Argument 1 = y:(IInterval, $954:) <= $43: = UnknownArgIsTypeVar
402.
  Callsite: Contains(x, End(y))
  Args: (IInterval, $955:), $45:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $955:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $45: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $955:) = FitConceptInheritsConcept
      Argument 1 = y:(IInterval, $954:) <= $45: = UnknownArgIsTypeVar
403.
  Callsite: Contains(y, Start(x))
  Args: (IInterval, $956:), $43:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $956:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $43: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $956:) = FitConceptInheritsConcept
      Argument 1 = y:(IInterval, $954:) <= $43: = UnknownArgIsTypeVar
404.
  Callsite: Contains(y, End(x))
  Args: (IInterval, $956:), $45:
  Possible Return Types: Boolean
  Callable function count: 2
  Best function count: 2
    Function = IInterval_20:Library.Contains(x: (IInterval, $951:), value: $952:): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $951:) <= (IInterval, $956:) = FitConceptInheritsConcept
      Argument 1 = value:$952: <= $45: = UnknownArgIsTypeVar
    Function = IInterval_20:Library.Contains(x: (IInterval, $953:), y: (IInterval, $954:)): Boolean
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:(IInterval, $953:) <= (IInterval, $956:) = FitConceptInheritsConcept
      Argument 1 = y:(IInterval, $954:) <= $45: = UnknownArgIsTypeVar
405.
  Callsite: Add(v, Size(x))
  Args: $970:, $943:
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $970: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $943: = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $970: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $943: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $970: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $943: = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $970: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $943: = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $970: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $943: = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $970: = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $943: = UnknownArgIsTypeVar
406.
  Callsite: Subtract(c, Half(Size(x)))
  Args: $980:, $792:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $980: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $980: = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
407.
  Callsite: Add(c, Half(Size(x)))
  Args: $980:, $792:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $980: = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $980: = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $980: = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $792:constraint=IScalarArithmetic = UnknownArgIsTypeVar
408.
  Callsite: Map(LinearSpaceExclusive(count), (\(ParameterDef=x$18538:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $991:constraint=(IArray, Number), (Function1, $1936:, $1937:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
409.
  Callsite: Map(LinearSpace(count), (\(ParameterDef=x$18564:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $990:constraint=(IArray, Number), (Function1, $1939:, $1940:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
410.
  Callsite: Map(LinearSpaceExclusive(count), (\(ParameterDef=x$18590:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $991:constraint=(IArray, Number), (Function1, $1942:, $1943:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
411.
  Callsite: Map(GeometricSpace(count), (\(ParameterDef=x$18620:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $998:constraint=(IArray, Number), (Function1, $1945:, $1946:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
412.
  Callsite: Map(GeometricSpaceExclusive(count), (\(ParameterDef=x$18650:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $999:constraint=(IArray, Number), (Function1, $1948:, $1949:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
413.
  Callsite: WithNext(LinearSpace(Add(count, 1)), (\(ParameterDef=a$18681:Concept:IAny, ParameterDef=b$18683:Concept:IAny) -> ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2>)
  Args: $990:constraint=(IArray, Number), (Function2, $1951:, $1952:, $1953:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
414.
  Callsite: Map(Intervals(count), (\(ParameterDef=i$18764:Concept:IAny) -> ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$T1>)
  Args: $1006:constraint=(IArray, NumberInterval), (Function1, $1957:, $1958:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
415.
  Callsite: CreateFromRows(Matrix4x4, Row1(m), Row2(m), Row3(m), Tuple4(X(v), Y(v), Z(v), 1))
  Args: IAny, Vector4D, Vector4D, Vector4D, (Tuple4, $1981:, $1982:, $1983:, $1984:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
416.
  Callsite: WithTranslation(Identity, v)
  Args: IAny, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
417.
  Callsite: CreateTranslation(Matrix4x4, v)
  Args: IAny, Vector3D
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
418.
  Callsite: CreateFromRows(Matrix4x4, Row1(m), Row2(m), Row3(m), Tuple4(0, 0, 0, 1))
  Args: IAny, Vector3D, Vector3D, Vector3D, (Tuple4, $1991:, $1992:, $1993:, $1994:)
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
419.
  Callsite: Identity(Matrix4x4)
  Args: IAny
  Possible Return Types: 
  Callable function count: 0
  Best function count: 0
420.
  Callsite: Quaternion(r)
  Args: Rotation3D
  Possible Return Types: Quaternion
  Callable function count: 2
  Best function count: 2
    Function = Rotation3D_554:ConcreteType.Quaternion(self: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:Rotation3D <= Rotation3D = FitEquality
    Function = Rotation3D_554:ConcreteType.Quaternion(arg: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = arg:Rotation3D <= Rotation3D = FitEquality
421.
  Callsite: Subtract(Multiply(M22, M33), Multiply(M23, M32))
  Args: $36:constraint=IMultiplicative, $36:constraint=IMultiplicative
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
422.
  Callsite: Multiply(M11, Subtract(Multiply(M22, M33), Multiply(M23, M32)))
  Args: IAny, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAny = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAny = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
423.
  Callsite: Subtract(Multiply(M21, M33), Multiply(M23, M31))
  Args: $36:constraint=IMultiplicative, $36:constraint=IMultiplicative
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
424.
  Callsite: Multiply(M12, Subtract(Multiply(M21, M33), Multiply(M23, M31)))
  Args: IAny, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAny = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAny = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
425.
  Callsite: Subtract(Multiply(M21, M32), Multiply(M22, M31))
  Args: $36:constraint=IMultiplicative, $36:constraint=IMultiplicative
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 5
  Best function count: 3
    Function = INumerical_4:Library.Subtract(x: INumerical, y: INumerical): $828:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Subtract(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Subtract(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Subtract(a: $31:constraint=IAdditive, b: $31:constraint=IAdditive): $31:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
      Argument 1 = b:$31:constraint=IAdditive <= $36:constraint=IMultiplicative = UnknownArgIsTypeVar
426.
  Callsite: Multiply(M13, Subtract(Multiply(M21, M32), Multiply(M22, M31)))
  Args: IAny, Number
  Possible Return Types: $35:constraint=IScalarArithmetic, $36:constraint=IMultiplicative
  Callable function count: 2
  Best function count: 2
    Function = IScalarArithmetic_58:Concept.Multiply(self: $35:constraint=IScalarArithmetic, other: Number): $35:constraint=IScalarArithmetic
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:$35:constraint=IScalarArithmetic <= IAny = UnknownParamIsTypeVar
      Argument 1 = other:Number <= Number = FitEquality
    Function = IMultiplicative_60:Concept.Multiply(a: $36:constraint=IMultiplicative, b: $36:constraint=IMultiplicative): $36:constraint=IMultiplicative
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$36:constraint=IMultiplicative <= IAny = UnknownParamIsTypeVar
      Argument 1 = b:$36:constraint=IMultiplicative <= Number = UnknownParamIsTypeVar
427.
  Callsite: Add(Multiply(M12, Subtract(Multiply(M21, M33), Multiply(M23, M31))), Multiply(M13, Subtract(Multiply(M21, M32), Multiply(M22, M31))))
  Args: $35:constraint=IScalarArithmetic, $35:constraint=IScalarArithmetic
  Possible Return Types: Number, Integer, Quaternion
  Callable function count: 6
  Best function count: 3
    Function = INumerical_4:Library.Add(x: INumberLike, y: Number): $822:constraint=INumberLike
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 1
      Argument 0 = x:INumberLike <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = INumerical_4:Library.Add(x: INumerical, y: INumerical): $827:constraint=INumerical
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 0
      Argument 0 = x:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:INumerical <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Number, y: Number): Number
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Number <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Intrinsics_22:Library.Add(x: Integer, y: Integer): Integer
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 2
      Argument 0 = x:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = y:Integer <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = Transforms_26:Library.Add(q1: Quaternion, q2: Quaternion): Quaternion
    Callable = True, Has body = True, Arity Matches = True, # Concrete type = 2
      Argument 0 = q1:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = q2:Quaternion <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
    Function = IAdditive_56:Concept.Add(a: $30:constraint=IAdditive, b: $30:constraint=IAdditive): $30:constraint=IAdditive
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 0
      Argument 0 = a:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
      Argument 1 = b:$30:constraint=IAdditive <= $35:constraint=IScalarArithmetic = UnknownArgIsTypeVar
428.
  Callsite: Quaternion(r)
  Args: Rotation3D
  Possible Return Types: Quaternion
  Callable function count: 2
  Best function count: 2
    Function = Rotation3D_554:ConcreteType.Quaternion(self: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:Rotation3D <= Rotation3D = FitEquality
    Function = Rotation3D_554:ConcreteType.Quaternion(arg: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = arg:Rotation3D <= Rotation3D = FitEquality
429.
  Callsite: Quaternion(r)
  Args: Rotation3D
  Possible Return Types: Quaternion
  Callable function count: 2
  Best function count: 2
    Function = Rotation3D_554:ConcreteType.Quaternion(self: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = self:Rotation3D <= Rotation3D = FitEquality
    Function = Rotation3D_554:ConcreteType.Quaternion(arg: Rotation3D): Quaternion
    Callable = True, Has body = False, Arity Matches = True, # Concrete type = 1
      Argument 0 = arg:Rotation3D <= Rotation3D = FitEquality
