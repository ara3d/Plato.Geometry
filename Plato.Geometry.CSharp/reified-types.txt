Reified type Unit
  Reified functions for group Unit_82:ConcreteType
    Unit_82:ConcreteType.Value(self: ConcreteType:Unit): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Unit): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Unit,n: ConcreteType:Number): ConcreteType:Unit [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Unit): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Unit,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Unit [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Unit): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Unit): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Unit): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Unit,other: ConcreteType:Number): ConcreteType:Unit [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Unit,other: ConcreteType:Number): ConcreteType:Unit [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Unit,other: ConcreteType:Number): ConcreteType:Unit [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Unit): ConcreteType:Unit [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Boolean [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Unit,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Unit> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Square(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Magnitude(x: ConcreteType:Unit): ConcreteType:Number [Library];
    INumerical_4:Library.GtZ(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.LtZ(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.GtEqZ(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.LtEqZ(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.IsPositive(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.IsNegative(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.Sign(x: ConcreteType:Unit): ConcreteType:Integer [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Inverse(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Between(self: ConcreteType:Unit,min: ConcreteType:Unit,max: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.Half(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Million(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Component(x: ConcreteType:Unit,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Unit): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Unit,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Unit [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Unit,y: ConcreteType:Unit,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Unit [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.One(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Unit): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Unit): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Unit,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Unit,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Unit,a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Unit,a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Min(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Max(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Unit): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Unit): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Unit,n: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Unit,b: ConcreteType:Unit): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Unit,y: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Unit,y: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Unit,s: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Unit,s: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Unit,s: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Add(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Unit,y: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Unit,b: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Unit,v2: ConcreteType:Unit,v3: ConcreteType:Unit,uv: ConcreteType:Vector2D): ConcreteType:Unit [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Unit): ConcreteType:Unit [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,d: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,d: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,d: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Unit,b: ConcreteType:Unit,c: ConcreteType:Unit,t: ConcreteType:Number): ConcreteType:Unit [Library];
Reified type Probability
  Reified functions for group Probability_84:ConcreteType
    Probability_84:ConcreteType.Value(self: ConcreteType:Probability): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Probability): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Probability,n: ConcreteType:Number): ConcreteType:Probability [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Probability): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Probability,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Probability [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Probability): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Probability): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Probability): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Probability,other: ConcreteType:Number): ConcreteType:Probability [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Probability,other: ConcreteType:Number): ConcreteType:Probability [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Probability,other: ConcreteType:Number): ConcreteType:Probability [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Probability [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Probability [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Probability): ConcreteType:Probability [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Probability,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Probability> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Half(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Million(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Component(x: ConcreteType:Probability,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Probability): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Probability,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Probability [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Probability,y: ConcreteType:Probability,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Probability [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.One(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Probability): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Probability): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Probability,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Probability,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Probability,a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Probability,a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Min(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Max(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Probability): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Probability): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Probability,n: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Probability,b: ConcreteType:Probability): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Probability,y: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Probability,y: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Probability,s: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Probability,s: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Probability,s: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Add(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Probability,y: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Probability): ConcreteType:Probability [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Probability,b: ConcreteType:Probability,t: ConcreteType:Number): ConcreteType:Probability [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Probability,v2: ConcreteType:Probability,v3: ConcreteType:Probability,uv: ConcreteType:Vector2D): ConcreteType:Probability [Library];
Reified type Complex
  Reified functions for group Complex_86:ConcreteType
    Complex_86:ConcreteType.IReal(self: ConcreteType:Complex): ConcreteType:Number [Field];
    Complex_86:ConcreteType.Imaginary(self: ConcreteType:Complex): ConcreteType:Number [Field];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Complex): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Complex,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Complex [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Complex): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Complex): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Complex): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Complex,other: ConcreteType:Number): ConcreteType:Complex [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Complex,other: ConcreteType:Number): ConcreteType:Complex [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Complex,other: ConcreteType:Number): ConcreteType:Complex [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Complex): ConcreteType:Complex [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Complex): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Complex,n: ConcreteType:Integer): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Complex> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Complex): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Complex): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Complex): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Complex,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Complex,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Complex,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Complex,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Complex,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Complex,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Complex): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Complex,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Complex,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Complex,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Complex,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Complex,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Complex,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Complex,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Complex,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Complex,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Complex,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Complex,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Complex,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Complex): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Complex,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Complex,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Complex,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Complex,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Square(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Half(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Million(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Component(x: ConcreteType:Complex,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Complex): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Complex,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Complex [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Complex,y: ConcreteType:Complex,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Complex [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.One(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Complex): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Complex): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Complex,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Complex,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Complex,a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Complex): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Complex,a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Min(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Max(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Boolean [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Complex,s: ConcreteType:Number): ConcreteType:Complex [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Complex,s: ConcreteType:Number): ConcreteType:Complex [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Complex,s: ConcreteType:Number): ConcreteType:Complex [Library];
    INumerical_4:Library.Add(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Complex,y: ConcreteType:Complex): ConcreteType:Complex [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Complex,b: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Complex,v2: ConcreteType:Complex,v3: ConcreteType:Complex,uv: ConcreteType:Vector2D): ConcreteType:Complex [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,d: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,d: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,d: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Complex,b: ConcreteType:Complex,c: ConcreteType:Complex,t: ConcreteType:Number): ConcreteType:Complex [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Count(c: ConcreteType:Complex): ConcreteType:Integer [Library];
    IGeometry_18:Library.At(c: ConcreteType:Complex,n: ConcreteType:Integer): ConcreteType:Number [Library];
    IGeometry_18:Library.Length(a: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.LengthSquared(a: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Sum(v: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.SumSquares(v: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.MagnitudeSquared(v: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Magnitude(v: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Dot(v1: ConcreteType:Complex,v2: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Average(v: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Normalize(x: ConcreteType:Complex): ConcreteType:Complex [Library];
    IGeometry_18:Library.Reflect(v: ConcreteType:Complex,normal: ConcreteType:Complex): ConcreteType:Complex [Library];
    IGeometry_18:Library.Project(v: ConcreteType:Complex,other: ConcreteType:Complex): ConcreteType:Complex [Library];
    IGeometry_18:Library.Distance(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.DistanceSquared(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Number [Library];
    IGeometry_18:Library.Angle(a: ConcreteType:Complex,b: ConcreteType:Complex): ConcreteType:Angle [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Complex): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Complex): ConcreteType:Complex [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Complex): ConcreteType:Complex [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Complex): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Complex,ys: ConcreteType:Complex): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Complex,ys: ConcreteType:Complex): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Complex,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Integer2
  Reified functions for group Integer2_88:ConcreteType
    Integer2_88:ConcreteType.A(self: ConcreteType:Integer2): ConcreteType:Integer [Field];
    Integer2_88:ConcreteType.B(self: ConcreteType:Integer2): ConcreteType:Integer [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Integer2): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Integer2): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Integer2): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Integer2,b: ConcreteType:Integer2): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Integer2): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Integer2,n: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer2> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Integer2): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Integer2): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Integer2): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Integer2,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Integer2,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Integer2,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Integer2,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Integer2,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Integer2,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Integer2): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Integer2,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Integer2,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Integer2,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Integer2,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer2,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer2,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Integer2,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer2,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Integer2,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer2,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Integer2,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Integer2,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Integer2): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Integer2,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Integer2,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Integer2,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Integer2,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Integer2,b: ConcreteType:Integer2): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Integer2,b: ConcreteType:Integer2): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Integer2): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer2): ConcreteType:Integer2 [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer2): ConcreteType:Integer2 [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer2): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer2,ys: ConcreteType:Integer2): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer2,ys: ConcreteType:Integer2): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Integer2,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Integer3
  Reified functions for group Integer3_90:ConcreteType
    Integer3_90:ConcreteType.A(self: ConcreteType:Integer3): ConcreteType:Integer [Field];
    Integer3_90:ConcreteType.B(self: ConcreteType:Integer3): ConcreteType:Integer [Field];
    Integer3_90:ConcreteType.C(self: ConcreteType:Integer3): ConcreteType:Integer [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Integer3): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Integer3): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Integer3): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Integer3,b: ConcreteType:Integer3): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Integer3): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Integer3,n: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer3> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Integer3): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Integer3): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Integer3): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Integer3,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Integer3,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Integer3,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Integer3,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Integer3,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Integer3,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Integer3): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Integer3,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Integer3,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Integer3,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Integer3,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer3,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer3,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Integer3,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Integer3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Integer3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Integer3,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Integer3): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Integer3,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Integer3,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Integer3,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Integer3,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Integer3,b: ConcreteType:Integer3): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Integer3,b: ConcreteType:Integer3): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Integer3): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer3): ConcreteType:Integer3 [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer3): ConcreteType:Integer3 [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer3): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer3,ys: ConcreteType:Integer3): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer3,ys: ConcreteType:Integer3): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Integer3,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Integer4
  Reified functions for group Integer4_92:ConcreteType
    Integer4_92:ConcreteType.A(self: ConcreteType:Integer4): ConcreteType:Integer [Field];
    Integer4_92:ConcreteType.B(self: ConcreteType:Integer4): ConcreteType:Integer [Field];
    Integer4_92:ConcreteType.C(self: ConcreteType:Integer4): ConcreteType:Integer [Field];
    Integer4_92:ConcreteType.D(self: ConcreteType:Integer4): ConcreteType:Integer [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Integer4): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Integer4): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Integer4): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Integer4,b: ConcreteType:Integer4): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Integer4): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Integer4,n: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer4> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Integer4): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Integer4): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Integer4): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Integer4,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Integer4,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Integer4,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Integer4,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Integer4,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Integer4,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Integer4): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Integer4,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Integer4,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Integer4,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Integer4,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer4,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Integer4,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Integer4,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Integer4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Integer4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Integer4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Integer4,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Integer4): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Integer4,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Integer4,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Integer4,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Integer4,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Integer4,b: ConcreteType:Integer4): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Integer4,b: ConcreteType:Integer4): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Integer4): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer4): ConcreteType:Integer4 [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer4): ConcreteType:Integer4 [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Integer4): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer4,ys: ConcreteType:Integer4): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Integer4,ys: ConcreteType:Integer4): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Integer4,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Color
  Reified functions for group Color_94:ConcreteType
    Color_94:ConcreteType.R(self: ConcreteType:Color): ConcreteType:Unit [Field];
    Color_94:ConcreteType.G(self: ConcreteType:Color): ConcreteType:Unit [Field];
    Color_94:ConcreteType.B(self: ConcreteType:Color): ConcreteType:Unit [Field];
    Color_94:ConcreteType.A(self: ConcreteType:Color): ConcreteType:Unit [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Color): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Color): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Color): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Color,b: ConcreteType:Color): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Color,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Color> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Color,b: ConcreteType:Color): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Color,b: ConcreteType:Color): ConcreteType:Boolean [Library];
Reified type ColorLUV
  Reified functions for group ColorLUV_96:ConcreteType
    ColorLUV_96:ConcreteType.Lightness(self: ConcreteType:ColorLUV): ConcreteType:Unit [Field];
    ColorLUV_96:ConcreteType.U(self: ConcreteType:ColorLUV): ConcreteType:Unit [Field];
    ColorLUV_96:ConcreteType.V(self: ConcreteType:ColorLUV): ConcreteType:Unit [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorLUV): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorLUV): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorLUV): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorLUV,b: ConcreteType:ColorLUV): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorLUV,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorLUV> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorLUV,b: ConcreteType:ColorLUV): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorLUV,b: ConcreteType:ColorLUV): ConcreteType:Boolean [Library];
Reified type ColorLAB
  Reified functions for group ColorLAB_98:ConcreteType
    ColorLAB_98:ConcreteType.Lightness(self: ConcreteType:ColorLAB): ConcreteType:Unit [Field];
    ColorLAB_98:ConcreteType.A(self: ConcreteType:ColorLAB): ConcreteType:Number [Field];
    ColorLAB_98:ConcreteType.B(self: ConcreteType:ColorLAB): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorLAB): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorLAB): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorLAB): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorLAB,b: ConcreteType:ColorLAB): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorLAB,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorLAB> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorLAB,b: ConcreteType:ColorLAB): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorLAB,b: ConcreteType:ColorLAB): ConcreteType:Boolean [Library];
Reified type ColorLCh
  Reified functions for group ColorLCh_100:ConcreteType
    ColorLCh_100:ConcreteType.Lightness(self: ConcreteType:ColorLCh): ConcreteType:Unit [Field];
    ColorLCh_100:ConcreteType.ChromaHue(self: ConcreteType:ColorLCh): ConcreteType:PolarCoordinate [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorLCh): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorLCh): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorLCh): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorLCh,b: ConcreteType:ColorLCh): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorLCh,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorLCh> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorLCh,b: ConcreteType:ColorLCh): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorLCh,b: ConcreteType:ColorLCh): ConcreteType:Boolean [Library];
Reified type ColorHSV
  Reified functions for group ColorHSV_102:ConcreteType
    ColorHSV_102:ConcreteType.Hue(self: ConcreteType:ColorHSV): ConcreteType:Angle [Field];
    ColorHSV_102:ConcreteType.S(self: ConcreteType:ColorHSV): ConcreteType:Unit [Field];
    ColorHSV_102:ConcreteType.V(self: ConcreteType:ColorHSV): ConcreteType:Unit [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorHSV): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorHSV): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorHSV): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorHSV,b: ConcreteType:ColorHSV): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorHSV,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorHSV> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorHSV,b: ConcreteType:ColorHSV): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorHSV,b: ConcreteType:ColorHSV): ConcreteType:Boolean [Library];
Reified type ColorHSL
  Reified functions for group ColorHSL_104:ConcreteType
    ColorHSL_104:ConcreteType.Hue(self: ConcreteType:ColorHSL): ConcreteType:Angle [Field];
    ColorHSL_104:ConcreteType.Saturation(self: ConcreteType:ColorHSL): ConcreteType:Unit [Field];
    ColorHSL_104:ConcreteType.Luminance(self: ConcreteType:ColorHSL): ConcreteType:Unit [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorHSL): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorHSL): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorHSL): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorHSL,b: ConcreteType:ColorHSL): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorHSL,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorHSL> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorHSL,b: ConcreteType:ColorHSL): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorHSL,b: ConcreteType:ColorHSL): ConcreteType:Boolean [Library];
Reified type ColorYCbCr
  Reified functions for group ColorYCbCr_106:ConcreteType
    ColorYCbCr_106:ConcreteType.Y(self: ConcreteType:ColorYCbCr): ConcreteType:Unit [Field];
    ColorYCbCr_106:ConcreteType.Cb(self: ConcreteType:ColorYCbCr): ConcreteType:Unit [Field];
    ColorYCbCr_106:ConcreteType.Cr(self: ConcreteType:ColorYCbCr): ConcreteType:Unit [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:ColorYCbCr): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:ColorYCbCr): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:ColorYCbCr): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:ColorYCbCr,b: ConcreteType:ColorYCbCr): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:ColorYCbCr,n: ConcreteType:Integer): Concept:IArray<ConcreteType:ColorYCbCr> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:ColorYCbCr,b: ConcreteType:ColorYCbCr): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:ColorYCbCr,b: ConcreteType:ColorYCbCr): ConcreteType:Boolean [Library];
Reified type SphericalCoordinate
  Reified functions for group SphericalCoordinate_108:ConcreteType
    SphericalCoordinate_108:ConcreteType.RadialDistance(self: ConcreteType:SphericalCoordinate): ConcreteType:Number [Field];
    SphericalCoordinate_108:ConcreteType.Azimuth(self: ConcreteType:SphericalCoordinate): ConcreteType:Angle [Field];
    SphericalCoordinate_108:ConcreteType.Polar(self: ConcreteType:SphericalCoordinate): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:SphericalCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:SphericalCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:SphericalCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:SphericalCoordinate,b: ConcreteType:SphericalCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:SphericalCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:SphericalCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:SphericalCoordinate,b: ConcreteType:SphericalCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:SphericalCoordinate,b: ConcreteType:SphericalCoordinate): ConcreteType:Boolean [Library];
Reified type PolarCoordinate
  Reified functions for group PolarCoordinate_110:ConcreteType
    PolarCoordinate_110:ConcreteType.Radius(self: ConcreteType:PolarCoordinate): ConcreteType:Number [Field];
    PolarCoordinate_110:ConcreteType.Angle(self: ConcreteType:PolarCoordinate): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:PolarCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:PolarCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:PolarCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:PolarCoordinate,b: ConcreteType:PolarCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:PolarCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:PolarCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:PolarCoordinate,b: ConcreteType:PolarCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:PolarCoordinate,b: ConcreteType:PolarCoordinate): ConcreteType:Boolean [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.Vector2D(coord: ConcreteType:PolarCoordinate): ConcreteType:Vector2D [Library];
Reified type LogPolarCoordinate
  Reified functions for group LogPolarCoordinate_112:ConcreteType
    LogPolarCoordinate_112:ConcreteType.Rho(self: ConcreteType:LogPolarCoordinate): ConcreteType:Number [Field];
    LogPolarCoordinate_112:ConcreteType.Azimuth(self: ConcreteType:LogPolarCoordinate): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:LogPolarCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:LogPolarCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:LogPolarCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:LogPolarCoordinate,b: ConcreteType:LogPolarCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:LogPolarCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:LogPolarCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:LogPolarCoordinate,b: ConcreteType:LogPolarCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:LogPolarCoordinate,b: ConcreteType:LogPolarCoordinate): ConcreteType:Boolean [Library];
Reified type CylindricalCoordinate
  Reified functions for group CylindricalCoordinate_114:ConcreteType
    CylindricalCoordinate_114:ConcreteType.RadialDistance(self: ConcreteType:CylindricalCoordinate): ConcreteType:Number [Field];
    CylindricalCoordinate_114:ConcreteType.Azimuth(self: ConcreteType:CylindricalCoordinate): ConcreteType:Angle [Field];
    CylindricalCoordinate_114:ConcreteType.Height(self: ConcreteType:CylindricalCoordinate): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:CylindricalCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:CylindricalCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:CylindricalCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:CylindricalCoordinate,b: ConcreteType:CylindricalCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:CylindricalCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:CylindricalCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:CylindricalCoordinate,b: ConcreteType:CylindricalCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:CylindricalCoordinate,b: ConcreteType:CylindricalCoordinate): ConcreteType:Boolean [Library];
Reified type HorizontalCoordinate
  Reified functions for group HorizontalCoordinate_116:ConcreteType
    HorizontalCoordinate_116:ConcreteType.Altitude(self: ConcreteType:HorizontalCoordinate): ConcreteType:Angle [Field];
    HorizontalCoordinate_116:ConcreteType.Azimuth(self: ConcreteType:HorizontalCoordinate): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:HorizontalCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:HorizontalCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:HorizontalCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:HorizontalCoordinate,b: ConcreteType:HorizontalCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:HorizontalCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:HorizontalCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:HorizontalCoordinate,b: ConcreteType:HorizontalCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:HorizontalCoordinate,b: ConcreteType:HorizontalCoordinate): ConcreteType:Boolean [Library];
Reified type GeoCoordinate
  Reified functions for group GeoCoordinate_118:ConcreteType
    GeoCoordinate_118:ConcreteType.Latitude(self: ConcreteType:GeoCoordinate): ConcreteType:Angle [Field];
    GeoCoordinate_118:ConcreteType.Longitude(self: ConcreteType:GeoCoordinate): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:GeoCoordinate): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:GeoCoordinate): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:GeoCoordinate): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:GeoCoordinate,b: ConcreteType:GeoCoordinate): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:GeoCoordinate,n: ConcreteType:Integer): Concept:IArray<ConcreteType:GeoCoordinate> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:GeoCoordinate,b: ConcreteType:GeoCoordinate): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:GeoCoordinate,b: ConcreteType:GeoCoordinate): ConcreteType:Boolean [Library];
Reified type GeoCoordinateWithAltitude
  Reified functions for group GeoCoordinateWithAltitude_120:ConcreteType
    GeoCoordinateWithAltitude_120:ConcreteType.ICoordinate(self: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:GeoCoordinate [Field];
    GeoCoordinateWithAltitude_120:ConcreteType.Altitude(self: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:GeoCoordinateWithAltitude): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:GeoCoordinateWithAltitude): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:GeoCoordinateWithAltitude,b: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:GeoCoordinateWithAltitude,n: ConcreteType:Integer): Concept:IArray<ConcreteType:GeoCoordinateWithAltitude> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:GeoCoordinateWithAltitude,b: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:GeoCoordinateWithAltitude,b: ConcreteType:GeoCoordinateWithAltitude): ConcreteType:Boolean [Library];
Reified type Rational
  Reified functions for group Rational_122:ConcreteType
    Rational_122:ConcreteType.Numerator(self: ConcreteType:Rational): ConcreteType:Integer [Field];
    Rational_122:ConcreteType.Denominator(self: ConcreteType:Rational): ConcreteType:Integer [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Rational): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Rational): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Rational): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Rational,b: ConcreteType:Rational): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Rational,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Rational> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Rational,b: ConcreteType:Rational): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Rational,b: ConcreteType:Rational): ConcreteType:Boolean [Library];
Reified type Fraction
  Reified functions for group Fraction_124:ConcreteType
    Fraction_124:ConcreteType.Numerator(self: ConcreteType:Fraction): ConcreteType:Number [Field];
    Fraction_124:ConcreteType.Denominator(self: ConcreteType:Fraction): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Fraction): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Fraction): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Fraction): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Fraction,b: ConcreteType:Fraction): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Fraction,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Fraction> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Fraction,b: ConcreteType:Fraction): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Fraction,b: ConcreteType:Fraction): ConcreteType:Boolean [Library];
Reified type Angle
  Reified functions for group Angle_126:ConcreteType
    Angle_126:ConcreteType.Radians(self: ConcreteType:Angle): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Angle): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Angle,n: ConcreteType:Number): ConcreteType:Angle [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Angle): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Angle,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Angle [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Angle): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Angle): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Angle): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Angle,other: ConcreteType:Number): ConcreteType:Angle [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Angle,other: ConcreteType:Number): ConcreteType:Angle [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Angle,other: ConcreteType:Number): ConcreteType:Angle [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Angle [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Angle [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Angle): ConcreteType:Angle [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Angle,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Angle> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Half(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Million(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Turns(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.Degrees(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.Gradians(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.Sec(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.Csc(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.Cot(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Component(x: ConcreteType:Angle,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Angle): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Angle,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Angle [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Angle,y: ConcreteType:Angle,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Angle [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.One(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Angle,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Angle,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Angle,a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Angle,a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Min(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Max(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Angle): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Angle,n: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Angle,b: ConcreteType:Angle): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Angle,y: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Angle,y: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Angle,s: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Angle,s: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Angle,s: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Add(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Angle,y: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Angle): ConcreteType:Angle [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Angle,b: ConcreteType:Angle,t: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Angle,v2: ConcreteType:Angle,v3: ConcreteType:Angle,uv: ConcreteType:Vector2D): ConcreteType:Angle [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.UnitCircle(t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Circle(t: ConcreteType:Angle,center: ConcreteType:Vector2D,radius: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Ellipse(t: ConcreteType:Angle,center: ConcreteType:Vector2D,size: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Epicycloid(t: ConcreteType:Angle,R: ConcreteType:Number,r: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Hypocycloid(t: ConcreteType:Angle,R: ConcreteType:Number,r: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Epitrochoid(t: ConcreteType:Angle,R: ConcreteType:Number,r: ConcreteType:Number,d: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Hypotrochoid(t: ConcreteType:Angle,R: ConcreteType:Number,r: ConcreteType:Number,d: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.ButterflyCurve(t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.ButterflyCurveSection(t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.Lissajous(t: ConcreteType:Angle,a: ConcreteType:Number,b: ConcreteType:Number,d: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.CycloidOfCeva(t: ConcreteType:Angle): ConcreteType:Number [Library];
    PolarCurves_12:Library.Limacon(t: ConcreteType:Angle,a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.Cardoid(t: ConcreteType:Angle): ConcreteType:Number [Library];
    PolarCurves_12:Library.TschirnhausenCubic(t: ConcreteType:Angle,a: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.Rose(t: ConcreteType:Angle,k: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.ArchimedeanSpiral(t: ConcreteType:Angle,a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.ConicSection(t: ConcreteType:Angle,semiLatusRectum: ConcreteType:Number,eccentricity: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.LemniscateOfBernoulli(t: ConcreteType:Angle,a: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.TrisectrixOfMaclaurin(t: ConcreteType:Angle,a: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.ConchoidOfDeSluze(t: ConcreteType:Angle,a: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.SinusoidalSpiral(t: ConcreteType:Angle,a: ConcreteType:Number,n: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.FermatsSpiral(t: ConcreteType:Angle,a: ConcreteType:Number): ConcreteType:Number [Library];
    PolarCurves_12:Library.LogarithmicSpiral(t: ConcreteType:Angle,a: ConcreteType:Number,k: ConcreteType:Number): ConcreteType:Number [Library];
  Reified functions for group AngularCurves3D_16:Library
    AngularCurves3D_16:Library.TorusKnot(t: ConcreteType:Angle,p: ConcreteType:Number,q: ConcreteType:Number): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.TrefoilKnot(t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.FigureEightKnot(t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.Helix(t: ConcreteType:Angle,revs: ConcreteType:Number): ConcreteType:Vector3D [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Cos(x: ConcreteType:Angle): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Sin(x: ConcreteType:Angle): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Tan(x: ConcreteType:Angle): ConcreteType:Number [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.XRotation(theta: ConcreteType:Angle): ConcreteType:Quaternion [Library];
    Transforms_26:Library.YRotation(theta: ConcreteType:Angle): ConcreteType:Quaternion [Library];
    Transforms_26:Library.ZRotation(theta: ConcreteType:Angle): ConcreteType:Quaternion [Library];
Reified type Length
  Reified functions for group Length_128:ConcreteType
    Length_128:ConcreteType.Meters(self: ConcreteType:Length): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Length): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Length,n: ConcreteType:Number): ConcreteType:Length [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Length): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Length,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Length [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Length): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Length): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Length): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Length,other: ConcreteType:Number): ConcreteType:Length [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Length,other: ConcreteType:Number): ConcreteType:Length [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Length,other: ConcreteType:Number): ConcreteType:Length [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Length [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Length [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Length): ConcreteType:Length [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Length,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Length> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Half(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Million(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Component(x: ConcreteType:Length,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Length): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Length,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Length [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Length,y: ConcreteType:Length,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Length [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.One(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Length): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Length): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Length,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Length,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Length,a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Length,a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Min(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Max(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Length): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Length): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Length,n: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Length,b: ConcreteType:Length): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Length,y: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Length,y: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Length,s: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Length,s: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Length,s: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Add(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Length,y: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Length): ConcreteType:Length [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Length,b: ConcreteType:Length,t: ConcreteType:Number): ConcreteType:Length [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Length,v2: ConcreteType:Length,v3: ConcreteType:Length,uv: ConcreteType:Vector2D): ConcreteType:Length [Library];
Reified type Mass
  Reified functions for group Mass_130:ConcreteType
    Mass_130:ConcreteType.Kilograms(self: ConcreteType:Mass): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Mass): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Mass,n: ConcreteType:Number): ConcreteType:Mass [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Mass): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Mass,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Mass [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Mass): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Mass): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Mass): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Mass,other: ConcreteType:Number): ConcreteType:Mass [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Mass,other: ConcreteType:Number): ConcreteType:Mass [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Mass,other: ConcreteType:Number): ConcreteType:Mass [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Mass [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Mass [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Mass): ConcreteType:Mass [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Mass,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Mass> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Half(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Million(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Component(x: ConcreteType:Mass,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Mass): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Mass,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Mass [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Mass,y: ConcreteType:Mass,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Mass [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.One(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Mass): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Mass): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Mass,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Mass,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Mass,a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Mass,a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Min(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Max(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Mass): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Mass): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Mass,n: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Mass,b: ConcreteType:Mass): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Mass,y: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Mass,y: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Mass,s: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Mass,s: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Mass,s: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Add(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Mass,y: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Mass): ConcreteType:Mass [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Mass,b: ConcreteType:Mass,t: ConcreteType:Number): ConcreteType:Mass [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Mass,v2: ConcreteType:Mass,v3: ConcreteType:Mass,uv: ConcreteType:Vector2D): ConcreteType:Mass [Library];
Reified type Temperature
  Reified functions for group Temperature_132:ConcreteType
    Temperature_132:ConcreteType.Celsius(self: ConcreteType:Temperature): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Temperature): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Temperature,n: ConcreteType:Number): ConcreteType:Temperature [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Temperature): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Temperature,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Temperature [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Temperature): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Temperature): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Temperature): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Temperature,other: ConcreteType:Number): ConcreteType:Temperature [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Temperature,other: ConcreteType:Number): ConcreteType:Temperature [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Temperature,other: ConcreteType:Number): ConcreteType:Temperature [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Temperature [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Temperature [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Temperature): ConcreteType:Temperature [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Temperature,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Temperature> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Half(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Million(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Component(x: ConcreteType:Temperature,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Temperature): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Temperature,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Temperature [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Temperature,y: ConcreteType:Temperature,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Temperature [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.One(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Temperature): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Temperature): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Temperature,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Temperature,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Temperature,a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Temperature,a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Min(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Max(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Temperature): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Temperature): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Temperature,n: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Temperature,b: ConcreteType:Temperature): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Temperature,y: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Temperature,y: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Temperature,s: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Temperature,s: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Temperature,s: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Add(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Temperature,y: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Temperature): ConcreteType:Temperature [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Temperature,b: ConcreteType:Temperature,t: ConcreteType:Number): ConcreteType:Temperature [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Temperature,v2: ConcreteType:Temperature,v3: ConcreteType:Temperature,uv: ConcreteType:Vector2D): ConcreteType:Temperature [Library];
Reified type Time
  Reified functions for group Time_134:ConcreteType
    Time_134:ConcreteType.Seconds(self: ConcreteType:Time): ConcreteType:Number [Field];
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Time): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Time,n: ConcreteType:Number): ConcreteType:Time [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Time): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Time,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Time [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Time): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Time): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Time): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Time,other: ConcreteType:Number): ConcreteType:Time [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Time,other: ConcreteType:Number): ConcreteType:Time [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Time,other: ConcreteType:Number): ConcreteType:Time [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Time [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Time [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Time): ConcreteType:Time [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Time,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Time> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Multiply(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Half(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Million(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Component(x: ConcreteType:Time,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Time): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Time,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Time [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Time,y: ConcreteType:Time,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Time [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.One(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Time): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Time): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Time,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Time,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Time,a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Time,a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Min(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Max(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Integer [Library];
    INumerical_4:Library.Number(x: ConcreteType:Time): ConcreteType:Number [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Time): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Time,n: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Time,b: ConcreteType:Time): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Time,y: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Time,y: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Time,s: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Time,s: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Time,s: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Add(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Time,y: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Time): ConcreteType:Time [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Time,b: ConcreteType:Time,t: ConcreteType:Number): ConcreteType:Time [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Time,v2: ConcreteType:Time,v3: ConcreteType:Time,uv: ConcreteType:Vector2D): ConcreteType:Time [Library];
Reified type DateTime
  Reified functions for group DateTime_136:ConcreteType
    DateTime_136:ConcreteType.Value(self: ConcreteType:DateTime): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:DateTime): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:DateTime): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:DateTime): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:DateTime,b: ConcreteType:DateTime): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:DateTime,n: ConcreteType:Integer): Concept:IArray<ConcreteType:DateTime> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:DateTime,b: ConcreteType:DateTime): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:DateTime,b: ConcreteType:DateTime): ConcreteType:Boolean [Library];
Reified type AnglePair
  Reified functions for group AnglePair_138:ConcreteType
    AnglePair_138:ConcreteType.Start(self: ConcreteType:AnglePair): ConcreteType:Angle [Field];
    AnglePair_138:ConcreteType.End(self: ConcreteType:AnglePair): ConcreteType:Angle [Field];
  Reified functions for group IInterval_78:Concept
    IInterval_78:Concept.Start(x: ConcreteType:AnglePair): ConcreteType:Angle [Concept];
    IInterval_78:Concept.End(x: ConcreteType:AnglePair): ConcreteType:Angle [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:AnglePair,b: ConcreteType:AnglePair): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:AnglePair): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:AnglePair): ConcreteType:String [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:AnglePair): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<ConcreteType:AnglePair> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:AnglePair): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:AnglePair): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:AnglePair): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:AnglePair,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:AnglePair,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:AnglePair,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:AnglePair,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:AnglePair,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:AnglePair): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:AnglePair,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:AnglePair,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:AnglePair,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:AnglePair,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:AnglePair,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:AnglePair,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:AnglePair,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:AnglePair,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:AnglePair,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:AnglePair,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:AnglePair,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:AnglePair): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:AnglePair,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:AnglePair,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:AnglePair,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:AnglePair,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:AnglePair,b: ConcreteType:AnglePair): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:AnglePair,b: ConcreteType:AnglePair): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:AnglePair): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:AnglePair): ConcreteType:AnglePair [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:AnglePair): ConcreteType:AnglePair [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:AnglePair,ys: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:AnglePair,ys: ConcreteType:AnglePair): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group IInterval_20:Library
    IInterval_20:Library.Size(x: ConcreteType:AnglePair): TypeVariable:$T [Library];
    IInterval_20:Library.Lerp(x: ConcreteType:AnglePair,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IInterval_20:Library.Reverse(x: ConcreteType:AnglePair): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Center(x: ConcreteType:AnglePair): TypeVariable:$T [Library];
    IInterval_20:Library.Contains(x: ConcreteType:AnglePair,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IInterval_20:Library.Contains(x: ConcreteType:AnglePair,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.Overlaps(x: ConcreteType:AnglePair,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.SplitAt(x: ConcreteType:AnglePair,t: ConcreteType:Number): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Split(x: ConcreteType:AnglePair): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Left(x: ConcreteType:AnglePair,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Right(x: ConcreteType:AnglePair,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.MoveTo(x: ConcreteType:AnglePair,v: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.LeftHalf(x: ConcreteType:AnglePair): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.RightHalf(x: ConcreteType:AnglePair): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Recenter(x: ConcreteType:AnglePair,c: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:AnglePair,y: Concept:IInterval<TypeVariable:$T>): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:AnglePair,value: TypeVariable:$T): TypeVariable:$T [Library];
    IInterval_20:Library.LinearSpace(interval: ConcreteType:AnglePair,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.LinearSpaceExclusive(interval: ConcreteType:AnglePair,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpace(interval: ConcreteType:AnglePair,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpaceExclusive(interval: ConcreteType:AnglePair,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:AnglePair,start: ConcreteType:Number,end: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:AnglePair,subInterval: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:AnglePair,count: ConcreteType:Integer): Concept:IArray<Concept:IInterval<TypeVariable:$T>> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:AnglePair,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type NumberInterval
  Reified functions for group NumberInterval_140:ConcreteType
    NumberInterval_140:ConcreteType.Start(self: ConcreteType:NumberInterval): ConcreteType:Number [Field];
    NumberInterval_140:ConcreteType.End(self: ConcreteType:NumberInterval): ConcreteType:Number [Field];
  Reified functions for group IInterval_78:Concept
    IInterval_78:Concept.Start(x: ConcreteType:NumberInterval): ConcreteType:Number [Concept];
    IInterval_78:Concept.End(x: ConcreteType:NumberInterval): ConcreteType:Number [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:NumberInterval,b: ConcreteType:NumberInterval): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:NumberInterval): ConcreteType:String [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:NumberInterval): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<ConcreteType:NumberInterval> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:NumberInterval): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:NumberInterval): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:NumberInterval): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:NumberInterval,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:NumberInterval,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:NumberInterval,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:NumberInterval,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:NumberInterval): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:NumberInterval,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:NumberInterval,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:NumberInterval,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:NumberInterval,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:NumberInterval,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:NumberInterval,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:NumberInterval,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:NumberInterval,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:NumberInterval,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:NumberInterval,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:NumberInterval,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:NumberInterval): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:NumberInterval,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:NumberInterval,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:NumberInterval,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:NumberInterval,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:NumberInterval,b: ConcreteType:NumberInterval): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:NumberInterval,b: ConcreteType:NumberInterval): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:NumberInterval): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:NumberInterval): ConcreteType:NumberInterval [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:NumberInterval): ConcreteType:NumberInterval [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:NumberInterval,ys: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:NumberInterval,ys: ConcreteType:NumberInterval): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group IInterval_20:Library
    IInterval_20:Library.Size(x: ConcreteType:NumberInterval): TypeVariable:$T [Library];
    IInterval_20:Library.Lerp(x: ConcreteType:NumberInterval,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IInterval_20:Library.Reverse(x: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Center(x: ConcreteType:NumberInterval): TypeVariable:$T [Library];
    IInterval_20:Library.Contains(x: ConcreteType:NumberInterval,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IInterval_20:Library.Contains(x: ConcreteType:NumberInterval,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.Overlaps(x: ConcreteType:NumberInterval,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.SplitAt(x: ConcreteType:NumberInterval,t: ConcreteType:Number): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Split(x: ConcreteType:NumberInterval): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Left(x: ConcreteType:NumberInterval,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Right(x: ConcreteType:NumberInterval,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.MoveTo(x: ConcreteType:NumberInterval,v: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.LeftHalf(x: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.RightHalf(x: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Recenter(x: ConcreteType:NumberInterval,c: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:NumberInterval,y: Concept:IInterval<TypeVariable:$T>): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:NumberInterval,value: TypeVariable:$T): TypeVariable:$T [Library];
    IInterval_20:Library.LinearSpace(interval: ConcreteType:NumberInterval,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.LinearSpaceExclusive(interval: ConcreteType:NumberInterval,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpace(interval: ConcreteType:NumberInterval,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpaceExclusive(interval: ConcreteType:NumberInterval,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:NumberInterval,start: ConcreteType:Number,end: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:NumberInterval,subInterval: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:NumberInterval,count: ConcreteType:Integer): Concept:IArray<Concept:IInterval<TypeVariable:$T>> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:NumberInterval,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type LinearEquation
  Reified functions for group LinearEquation_144:ConcreteType
    LinearEquation_144:ConcreteType.Slope(self: ConcreteType:LinearEquation): ConcreteType:Number [Field];
    LinearEquation_144:ConcreteType.YIntercept(self: ConcreteType:LinearEquation): ConcreteType:Number [Field];
  Reified functions for group IRealFunction_142:Concept
    IRealFunction_142:Concept.Eval(f: ConcreteType:LinearEquation,x: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Eval(f: ConcreteType:LinearEquation,x: ConcreteType:Number): ConcreteType:Number [Library];
Reified type Quadratic
  Reified functions for group Quadratic_146:ConcreteType
    Quadratic_146:ConcreteType.A(self: ConcreteType:Quadratic): ConcreteType:Number [Field];
    Quadratic_146:ConcreteType.B(self: ConcreteType:Quadratic): ConcreteType:Number [Field];
    Quadratic_146:ConcreteType.C(self: ConcreteType:Quadratic): ConcreteType:Number [Field];
  Reified functions for group IRealFunction_142:Concept
    IRealFunction_142:Concept.Eval(f: ConcreteType:Quadratic,x: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Eval(f: ConcreteType:Quadratic,x: ConcreteType:Number): ConcreteType:Number [Library];
Reified type Cubic
  Reified functions for group Cubic_148:ConcreteType
    Cubic_148:ConcreteType.A(self: ConcreteType:Cubic): ConcreteType:Number [Field];
    Cubic_148:ConcreteType.B(self: ConcreteType:Cubic): ConcreteType:Number [Field];
    Cubic_148:ConcreteType.C(self: ConcreteType:Cubic): ConcreteType:Number [Field];
    Cubic_148:ConcreteType.D(self: ConcreteType:Cubic): ConcreteType:Number [Field];
  Reified functions for group IRealFunction_142:Concept
    IRealFunction_142:Concept.Eval(f: ConcreteType:Cubic,x: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Eval(f: ConcreteType:Cubic,x: ConcreteType:Number): ConcreteType:Number [Library];
Reified type Parabola
  Reified functions for group IRealFunction_142:Concept
    IRealFunction_142:Concept.Eval(f: ConcreteType:Parabola,x: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Parabola): ConcreteType:Boolean [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Eval(f: ConcreteType:Parabola,x: ConcreteType:Number): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Parabola): ConcreteType:Boolean [Library];
Reified type SineWave
  Reified functions for group SineWave_152:ConcreteType
    SineWave_152:ConcreteType.Amplitude(self: ConcreteType:SineWave): ConcreteType:Number [Field];
    SineWave_152:ConcreteType.Frequency(self: ConcreteType:SineWave): ConcreteType:Number [Field];
    SineWave_152:ConcreteType.Phase(self: ConcreteType:SineWave): ConcreteType:Number [Field];
  Reified functions for group IRealFunction_142:Concept
    IRealFunction_142:Concept.Eval(f: ConcreteType:SineWave,x: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:SineWave): ConcreteType:Boolean [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Eval(f: ConcreteType:SineWave,x: ConcreteType:Number): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:SineWave): ConcreteType:Boolean [Library];
Reified type Spiral
  Reified functions for group Spiral_154:ConcreteType
    Spiral_154:ConcreteType.Radius1(self: ConcreteType:Spiral): ConcreteType:Number [Field];
    Spiral_154:ConcreteType.Radius2(self: ConcreteType:Spiral): ConcreteType:Number [Field];
    Spiral_154:ConcreteType.NumTurns(self: ConcreteType:Spiral): ConcreteType:Number [Field];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Spiral,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Spiral): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Spiral,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Spiral): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Spiral,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Spiral,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group Curves2D_8:Library
    Curves2D_8:Library.Eval(curve: ConcreteType:Spiral,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Spiral): ConcreteType:Boolean [Library];
Reified type QuadraticBezier2D
  Reified functions for group QuadraticBezier2D_156:ConcreteType
    QuadraticBezier2D_156:ConcreteType.A(self: ConcreteType:QuadraticBezier2D): ConcreteType:Vector2D [Field];
    QuadraticBezier2D_156:ConcreteType.B(self: ConcreteType:QuadraticBezier2D): ConcreteType:Vector2D [Field];
    QuadraticBezier2D_156:ConcreteType.C(self: ConcreteType:QuadraticBezier2D): ConcreteType:Vector2D [Field];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:QuadraticBezier2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:QuadraticBezier2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:QuadraticBezier2D): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:QuadraticBezier2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:QuadraticBezier2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:QuadraticBezier2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:QuadraticBezier2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:QuadraticBezier2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:QuadraticBezier2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:QuadraticBezier2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:QuadraticBezier2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:QuadraticBezier2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:QuadraticBezier2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:QuadraticBezier2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:QuadraticBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:QuadraticBezier2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:QuadraticBezier2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:QuadraticBezier2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:QuadraticBezier2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:QuadraticBezier2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:QuadraticBezier2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:QuadraticBezier2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:QuadraticBezier2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:QuadraticBezier2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group Curves2D_8:Library
    Curves2D_8:Library.Eval(curve: ConcreteType:QuadraticBezier2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:QuadraticBezier2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:QuadraticBezier2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier2D): ConcreteType:QuadraticBezier2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier2D): ConcreteType:QuadraticBezier2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:QuadraticBezier2D,ys: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:QuadraticBezier2D,ys: ConcreteType:QuadraticBezier2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:QuadraticBezier2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type CubicBezier2D
  Reified functions for group CubicBezier2D_158:ConcreteType
    CubicBezier2D_158:ConcreteType.A(self: ConcreteType:CubicBezier2D): ConcreteType:Vector2D [Field];
    CubicBezier2D_158:ConcreteType.B(self: ConcreteType:CubicBezier2D): ConcreteType:Vector2D [Field];
    CubicBezier2D_158:ConcreteType.C(self: ConcreteType:CubicBezier2D): ConcreteType:Vector2D [Field];
    CubicBezier2D_158:ConcreteType.D(self: ConcreteType:CubicBezier2D): ConcreteType:Vector2D [Field];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:CubicBezier2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:CubicBezier2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:CubicBezier2D): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:CubicBezier2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:CubicBezier2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:CubicBezier2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:CubicBezier2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:CubicBezier2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:CubicBezier2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:CubicBezier2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:CubicBezier2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:CubicBezier2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:CubicBezier2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:CubicBezier2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:CubicBezier2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:CubicBezier2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:CubicBezier2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:CubicBezier2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:CubicBezier2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:CubicBezier2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:CubicBezier2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:CubicBezier2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:CubicBezier2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:CubicBezier2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:CubicBezier2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group Curves2D_8:Library
    Curves2D_8:Library.Eval(curve: ConcreteType:CubicBezier2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:CubicBezier2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:CubicBezier2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier2D): ConcreteType:CubicBezier2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier2D): ConcreteType:CubicBezier2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:CubicBezier2D,ys: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:CubicBezier2D,ys: ConcreteType:CubicBezier2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:CubicBezier2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Circle
  Reified functions for group Circle_162:ConcreteType
    Circle_162:ConcreteType.Center(self: ConcreteType:Circle): ConcreteType:Vector2D [Field];
    Circle_162:ConcreteType.Radius(self: ConcreteType:Circle): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Circle,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Circle,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Circle): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Circle,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Circle): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Circle,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Circle,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Circle,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Circle,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Circle): ConcreteType:Boolean [Library];
Reified type Ellipse
  Reified functions for group Ellipse_164:ConcreteType
    Ellipse_164:ConcreteType.Center(self: ConcreteType:Ellipse): ConcreteType:Vector2D [Field];
    Ellipse_164:ConcreteType.Size(self: ConcreteType:Ellipse): ConcreteType:Vector2D [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Ellipse,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Ellipse,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Ellipse): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Ellipse,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Ellipse): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Ellipse,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Ellipse,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Ellipse,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Ellipse,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Ellipse): ConcreteType:Boolean [Library];
Reified type Epicycloid
  Reified functions for group Epicycloid_166:ConcreteType
    Epicycloid_166:ConcreteType.Radius1(self: ConcreteType:Epicycloid): ConcreteType:Number [Field];
    Epicycloid_166:ConcreteType.Radius2(self: ConcreteType:Epicycloid): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Epicycloid,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Epicycloid,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Epicycloid): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Epicycloid,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Epicycloid): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Epicycloid,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Epicycloid,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Epicycloid,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Epicycloid,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Epicycloid): ConcreteType:Boolean [Library];
Reified type Hypocycloid
  Reified functions for group Hypocycloid_168:ConcreteType
    Hypocycloid_168:ConcreteType.Radius1(self: ConcreteType:Hypocycloid): ConcreteType:Number [Field];
    Hypocycloid_168:ConcreteType.Radius2(self: ConcreteType:Hypocycloid): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Hypocycloid,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Hypocycloid,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Hypocycloid): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Hypocycloid,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Hypocycloid): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Hypocycloid,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Hypocycloid,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Hypocycloid,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Hypocycloid,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Hypocycloid): ConcreteType:Boolean [Library];
Reified type Epitrochoid
  Reified functions for group Epitrochoid_170:ConcreteType
    Epitrochoid_170:ConcreteType.Radius1(self: ConcreteType:Epitrochoid): ConcreteType:Number [Field];
    Epitrochoid_170:ConcreteType.Radius2(self: ConcreteType:Epitrochoid): ConcreteType:Number [Field];
    Epitrochoid_170:ConcreteType.Dist(self: ConcreteType:Epitrochoid): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Epitrochoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Epitrochoid,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Epitrochoid): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Epitrochoid,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Epitrochoid): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Epitrochoid,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Epitrochoid,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Epitrochoid,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Epitrochoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Epitrochoid): ConcreteType:Boolean [Library];
Reified type Hypotrochoid
  Reified functions for group Hypotrochoid_172:ConcreteType
    Hypotrochoid_172:ConcreteType.Radius1(self: ConcreteType:Hypotrochoid): ConcreteType:Number [Field];
    Hypotrochoid_172:ConcreteType.Radius2(self: ConcreteType:Hypotrochoid): ConcreteType:Number [Field];
    Hypotrochoid_172:ConcreteType.Dist(self: ConcreteType:Hypotrochoid): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Hypotrochoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Hypotrochoid,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Hypotrochoid): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Hypotrochoid,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Hypotrochoid): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Hypotrochoid,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Hypotrochoid,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Hypotrochoid,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Hypotrochoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Hypotrochoid): ConcreteType:Boolean [Library];
Reified type ButterflyCurve
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:ButterflyCurve,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:ButterflyCurve,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:ButterflyCurve): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:ButterflyCurve,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:ButterflyCurve): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:ButterflyCurve,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:ButterflyCurve,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:ButterflyCurve,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:ButterflyCurve,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:ButterflyCurve): ConcreteType:Boolean [Library];
Reified type Lissajous
  Reified functions for group Lissajous_176:ConcreteType
    Lissajous_176:ConcreteType.Delta(self: ConcreteType:Lissajous): ConcreteType:Angle [Field];
    Lissajous_176:ConcreteType.A(self: ConcreteType:Lissajous): ConcreteType:Number [Field];
    Lissajous_176:ConcreteType.B(self: ConcreteType:Lissajous): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Lissajous,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Lissajous,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Lissajous): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Lissajous,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Lissajous): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Lissajous,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Lissajous,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Lissajous,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    AngularCurves2D_10:Library.GetPoint(curve: ConcreteType:Lissajous,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Lissajous): ConcreteType:Boolean [Library];
Reified type CycloidOfCeva
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:CycloidOfCeva,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:CycloidOfCeva): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:CycloidOfCeva,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:CycloidOfCeva): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:CycloidOfCeva,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:CycloidOfCeva,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:CycloidOfCeva,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:CycloidOfCeva): ConcreteType:Boolean [Library];
Reified type Limacon
  Reified functions for group Limacon_182:ConcreteType
    Limacon_182:ConcreteType.A(self: ConcreteType:Limacon): ConcreteType:Number [Field];
    Limacon_182:ConcreteType.B(self: ConcreteType:Limacon): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:Limacon,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Limacon,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Limacon,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Limacon): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Limacon,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Limacon): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Limacon,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Limacon,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Limacon,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:Limacon,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:Limacon,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:Limacon,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Limacon): ConcreteType:Boolean [Library];
Reified type Cardoid
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:Cardoid,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Cardoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Cardoid,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Cardoid): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Cardoid,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Cardoid): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Cardoid,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Cardoid,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Cardoid,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:Cardoid,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:Cardoid,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:Cardoid,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Cardoid): ConcreteType:Boolean [Library];
Reified type Rose
  Reified functions for group Rose_186:ConcreteType
    Rose_186:ConcreteType.K(self: ConcreteType:Rose): ConcreteType:Integer [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:Rose,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:Rose,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Rose,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Rose): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Rose,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Rose): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Rose,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Rose,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:Rose,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:Rose,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:Rose,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:Rose,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Rose): ConcreteType:Boolean [Library];
Reified type ArchimedeanSpiral
  Reified functions for group ArchimedeanSpiral_188:ConcreteType
    ArchimedeanSpiral_188:ConcreteType.A(self: ConcreteType:ArchimedeanSpiral): ConcreteType:Number [Field];
    ArchimedeanSpiral_188:ConcreteType.B(self: ConcreteType:ArchimedeanSpiral): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:ArchimedeanSpiral): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:ArchimedeanSpiral,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:ArchimedeanSpiral): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:ArchimedeanSpiral,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:ArchimedeanSpiral,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:ArchimedeanSpiral,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:ArchimedeanSpiral): ConcreteType:Boolean [Library];
Reified type ConicSection
  Reified functions for group ConicSection_190:ConcreteType
    ConicSection_190:ConcreteType.Eccentricity(self: ConcreteType:ConicSection): ConcreteType:Number [Field];
    ConicSection_190:ConcreteType.SemiLatusRectum(self: ConcreteType:ConicSection): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:ConicSection,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:ConicSection,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:ConicSection,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:ConicSection): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:ConicSection,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:ConicSection): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:ConicSection,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:ConicSection,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:ConicSection,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:ConicSection,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:ConicSection,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:ConicSection,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:ConicSection): ConcreteType:Boolean [Library];
Reified type LemniscateOfBernoulli
  Reified functions for group LemniscateOfBernoulli_192:ConcreteType
    LemniscateOfBernoulli_192:ConcreteType.A(self: ConcreteType:LemniscateOfBernoulli): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:LemniscateOfBernoulli): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:LemniscateOfBernoulli,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:LemniscateOfBernoulli): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:LemniscateOfBernoulli,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:LemniscateOfBernoulli,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:LemniscateOfBernoulli,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:LemniscateOfBernoulli): ConcreteType:Boolean [Library];
Reified type TrisectrixOfMaclaurin
  Reified functions for group TrisectrixOfMaclaurin_194:ConcreteType
    TrisectrixOfMaclaurin_194:ConcreteType.A(self: ConcreteType:TrisectrixOfMaclaurin): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:TrisectrixOfMaclaurin): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:TrisectrixOfMaclaurin,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:TrisectrixOfMaclaurin): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:TrisectrixOfMaclaurin,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:TrisectrixOfMaclaurin,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:TrisectrixOfMaclaurin,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:TrisectrixOfMaclaurin): ConcreteType:Boolean [Library];
Reified type ConchoidOfDeSluze
  Reified functions for group ConchoidOfDeSluze_196:ConcreteType
    ConchoidOfDeSluze_196:ConcreteType.A(self: ConcreteType:ConchoidOfDeSluze): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:ConchoidOfDeSluze): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:ConchoidOfDeSluze,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:ConchoidOfDeSluze): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:ConchoidOfDeSluze,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:ConchoidOfDeSluze,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:ConchoidOfDeSluze,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:ConchoidOfDeSluze): ConcreteType:Boolean [Library];
Reified type TschirnhausenCubic
  Reified functions for group TschirnhausenCubic_198:ConcreteType
    TschirnhausenCubic_198:ConcreteType.A(self: ConcreteType:TschirnhausenCubic): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:TschirnhausenCubic,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:TschirnhausenCubic): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:TschirnhausenCubic,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:TschirnhausenCubic): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:TschirnhausenCubic,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:TschirnhausenCubic,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:TschirnhausenCubic,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:TschirnhausenCubic): ConcreteType:Boolean [Library];
Reified type SinusoidalSpiral
  Reified functions for group SinusoidalSpiral_200:ConcreteType
    SinusoidalSpiral_200:ConcreteType.A(self: ConcreteType:SinusoidalSpiral): ConcreteType:Number [Field];
    SinusoidalSpiral_200:ConcreteType.N(self: ConcreteType:SinusoidalSpiral): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:SinusoidalSpiral,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:SinusoidalSpiral): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:SinusoidalSpiral,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:SinusoidalSpiral): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:SinusoidalSpiral,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:SinusoidalSpiral,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:SinusoidalSpiral,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:SinusoidalSpiral): ConcreteType:Boolean [Library];
Reified type FermatsSpiral
  Reified functions for group FermatsSpiral_202:ConcreteType
    FermatsSpiral_202:ConcreteType.A(self: ConcreteType:FermatsSpiral): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:FermatsSpiral,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:FermatsSpiral): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:FermatsSpiral,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:FermatsSpiral): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:FermatsSpiral,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:FermatsSpiral,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:FermatsSpiral,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:FermatsSpiral): ConcreteType:Boolean [Library];
Reified type LogarithmicSpiral
  Reified functions for group LogarithmicSpiral_204:ConcreteType
    LogarithmicSpiral_204:ConcreteType.A(self: ConcreteType:LogarithmicSpiral): ConcreteType:Number [Field];
    LogarithmicSpiral_204:ConcreteType.K(self: ConcreteType:LogarithmicSpiral): ConcreteType:Number [Field];
  Reified functions for group IPolarCurve_178:Concept
    IPolarCurve_178:Concept.GetRadius(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Angle): ConcreteType:Number [Concept];
  Reified functions for group IAngularCurve2D_160:Concept
    IAngularCurve2D_160:Concept.GetPoint(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:LogarithmicSpiral,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:LogarithmicSpiral): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:LogarithmicSpiral,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:LogarithmicSpiral): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:LogarithmicSpiral,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:LogarithmicSpiral,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group AngularCurves2D_10:Library
    AngularCurves2D_10:Library.Eval(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group PolarCurves_12:Library
    PolarCurves_12:Library.EvalPolar(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Angle): ConcreteType:PolarCoordinate [Library];
    PolarCurves_12:Library.GetPoint(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Angle): ConcreteType:Vector2D [Library];
    PolarCurves_12:Library.GetRadius(curve: ConcreteType:LogarithmicSpiral,t: ConcreteType:Angle): ConcreteType:Number [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:LogarithmicSpiral): ConcreteType:Boolean [Library];
Reified type CubicBezier3D
  Reified functions for group CubicBezier3D_206:ConcreteType
    CubicBezier3D_206:ConcreteType.A(self: ConcreteType:CubicBezier3D): ConcreteType:Vector3D [Field];
    CubicBezier3D_206:ConcreteType.B(self: ConcreteType:CubicBezier3D): ConcreteType:Vector3D [Field];
    CubicBezier3D_206:ConcreteType.C(self: ConcreteType:CubicBezier3D): ConcreteType:Vector3D [Field];
    CubicBezier3D_206:ConcreteType.D(self: ConcreteType:CubicBezier3D): ConcreteType:Vector3D [Field];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:CubicBezier3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:CubicBezier3D): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:CubicBezier3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:CubicBezier3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:CubicBezier3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:CubicBezier3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:CubicBezier3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:CubicBezier3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:CubicBezier3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:CubicBezier3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:CubicBezier3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:CubicBezier3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:CubicBezier3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:CubicBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:CubicBezier3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:CubicBezier3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:CubicBezier3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:CubicBezier3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:CubicBezier3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:CubicBezier3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves3D_14:Library
    Curves3D_14:Library.Eval(curve: ConcreteType:CubicBezier3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:CubicBezier3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:CubicBezier3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier3D): ConcreteType:CubicBezier3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier3D): ConcreteType:CubicBezier3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:CubicBezier3D,ys: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:CubicBezier3D,ys: ConcreteType:CubicBezier3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:CubicBezier3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type QuadraticBezier3D
  Reified functions for group QuadraticBezier3D_208:ConcreteType
    QuadraticBezier3D_208:ConcreteType.A(self: ConcreteType:QuadraticBezier3D): ConcreteType:Vector3D [Field];
    QuadraticBezier3D_208:ConcreteType.B(self: ConcreteType:QuadraticBezier3D): ConcreteType:Vector3D [Field];
    QuadraticBezier3D_208:ConcreteType.C(self: ConcreteType:QuadraticBezier3D): ConcreteType:Vector3D [Field];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:QuadraticBezier3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:QuadraticBezier3D): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:QuadraticBezier3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:QuadraticBezier3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:QuadraticBezier3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:QuadraticBezier3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:QuadraticBezier3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:QuadraticBezier3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:QuadraticBezier3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:QuadraticBezier3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:QuadraticBezier3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:QuadraticBezier3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:QuadraticBezier3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:QuadraticBezier3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:QuadraticBezier3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:QuadraticBezier3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:QuadraticBezier3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:QuadraticBezier3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:QuadraticBezier3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves3D_14:Library
    Curves3D_14:Library.Eval(curve: ConcreteType:QuadraticBezier3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:QuadraticBezier3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:QuadraticBezier3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier3D): ConcreteType:QuadraticBezier3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier3D): ConcreteType:QuadraticBezier3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:QuadraticBezier3D,ys: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:QuadraticBezier3D,ys: ConcreteType:QuadraticBezier3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:QuadraticBezier3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type TorusKnot
  Reified functions for group TorusKnot_212:ConcreteType
    TorusKnot_212:ConcreteType.P(self: ConcreteType:TorusKnot): ConcreteType:Integer [Field];
    TorusKnot_212:ConcreteType.Q(self: ConcreteType:TorusKnot): ConcreteType:Integer [Field];
    TorusKnot_212:ConcreteType.Radius(self: ConcreteType:TorusKnot): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve3D_210:Concept
    IAngularCurve3D_210:Concept.GetPoint(curve: ConcreteType:TorusKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:TorusKnot,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:TorusKnot): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:TorusKnot,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:TorusKnot): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:TorusKnot,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:TorusKnot,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group AngularCurves3D_16:Library
    AngularCurves3D_16:Library.Eval(curve: ConcreteType:TorusKnot,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.GetPoint(curve: ConcreteType:TorusKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:TorusKnot): ConcreteType:Boolean [Library];
Reified type TrefoilKnot
  Reified functions for group IAngularCurve3D_210:Concept
    IAngularCurve3D_210:Concept.GetPoint(curve: ConcreteType:TrefoilKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:TrefoilKnot,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:TrefoilKnot): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:TrefoilKnot,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:TrefoilKnot): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:TrefoilKnot,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:TrefoilKnot,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group AngularCurves3D_16:Library
    AngularCurves3D_16:Library.Eval(curve: ConcreteType:TrefoilKnot,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.GetPoint(curve: ConcreteType:TrefoilKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:TrefoilKnot): ConcreteType:Boolean [Library];
Reified type FigureEightKnot
  Reified functions for group IAngularCurve3D_210:Concept
    IAngularCurve3D_210:Concept.GetPoint(curve: ConcreteType:FigureEightKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:FigureEightKnot,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:FigureEightKnot): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:FigureEightKnot,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:FigureEightKnot): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:FigureEightKnot,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:FigureEightKnot,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group AngularCurves3D_16:Library
    AngularCurves3D_16:Library.Eval(curve: ConcreteType:FigureEightKnot,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.GetPoint(curve: ConcreteType:FigureEightKnot,t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:FigureEightKnot): ConcreteType:Boolean [Library];
Reified type Helix
  Reified functions for group Helix_218:ConcreteType
    Helix_218:ConcreteType.Radius(self: ConcreteType:Helix): ConcreteType:Number [Field];
    Helix_218:ConcreteType.Height(self: ConcreteType:Helix): ConcreteType:Number [Field];
    Helix_218:ConcreteType.NumTurns(self: ConcreteType:Helix): ConcreteType:Number [Field];
  Reified functions for group IAngularCurve3D_210:Concept
    IAngularCurve3D_210:Concept.GetPoint(curve: ConcreteType:Helix,t: ConcreteType:Angle): ConcreteType:Vector3D [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Helix,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Helix): ConcreteType:Boolean [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Helix,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Helix): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Helix,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:Helix,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group AngularCurves3D_16:Library
    AngularCurves3D_16:Library.Eval(curve: ConcreteType:Helix,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    AngularCurves3D_16:Library.GetPoint(curve: ConcreteType:Helix,t: ConcreteType:Angle): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Helix): ConcreteType:Boolean [Library];
Reified type Transform2D
  Reified functions for group Transform2D_368:ConcreteType
    Transform2D_368:ConcreteType.Translation(self: ConcreteType:Transform2D): ConcreteType:Vector2D [Field];
    Transform2D_368:ConcreteType.Rotation(self: ConcreteType:Transform2D): ConcreteType:Angle [Field];
    Transform2D_368:ConcreteType.Scale(self: ConcreteType:Transform2D): ConcreteType:Vector2D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Transform2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Transform2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Transform2D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Transform2D,b: ConcreteType:Transform2D): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Transform2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Transform2D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Transform2D,b: ConcreteType:Transform2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Transform2D,b: ConcreteType:Transform2D): ConcreteType:Boolean [Library];
Reified type Pose2D
  Reified functions for group Pose2D_370:ConcreteType
    Pose2D_370:ConcreteType.Position(self: ConcreteType:Pose2D): ConcreteType:Vector2D [Field];
    Pose2D_370:ConcreteType.Rotation(self: ConcreteType:Pose2D): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Pose2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Pose2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Pose2D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Pose2D,b: ConcreteType:Pose2D): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Pose2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Pose2D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Pose2D,b: ConcreteType:Pose2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Pose2D,b: ConcreteType:Pose2D): ConcreteType:Boolean [Library];
Reified type Bounds2D
  Reified functions for group Bounds2D_372:ConcreteType
    Bounds2D_372:ConcreteType.Min(self: ConcreteType:Bounds2D): ConcreteType:Vector2D [Field];
    Bounds2D_372:ConcreteType.Max(self: ConcreteType:Bounds2D): ConcreteType:Vector2D [Field];
  Reified functions for group IBounds_80:Concept
    IBounds_80:Concept.Min(x: ConcreteType:Bounds2D): ConcreteType:Vector2D [Concept];
    IBounds_80:Concept.Max(x: ConcreteType:Bounds2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Bounds2D,b: ConcreteType:Bounds2D): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Bounds2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Bounds2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Bounds2D): ConcreteType:String [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Bounds2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Bounds2D> [Library];
  Reified functions for group IBounds_2:Library
    IBounds_2:Library.Size(x: ConcreteType:Bounds2D): TypeVariable:$T [Library];
    IBounds_2:Library.Lerp(x: ConcreteType:Bounds2D,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IBounds_2:Library.Center(x: ConcreteType:Bounds2D): TypeVariable:$T [Library];
    IBounds_2:Library.Contains(x: ConcreteType:Bounds2D,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IBounds_2:Library.Contains(x: ConcreteType:Bounds2D,y: Concept:IBounds<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IBounds_2:Library.Overlaps(x: ConcreteType:Bounds2D,y: Concept:IBounds<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IBounds_2:Library.Recenter(x: ConcreteType:Bounds2D,c: TypeVariable:$T): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Clamp(x: ConcreteType:Bounds2D,y: Concept:IBounds<TypeVariable:$T>): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Clamp(x: ConcreteType:Bounds2D,value: TypeVariable:$T): TypeVariable:$T [Library];
    IBounds_2:Library.Include(x: ConcreteType:Bounds2D,value: TypeVariable:$T): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Include(x: ConcreteType:Bounds2D,y: Concept:IBounds<TypeVariable:$T>): Concept:IBounds<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Bounds2D,b: ConcreteType:Bounds2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Bounds2D,b: ConcreteType:Bounds2D): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.To3D(x: ConcreteType:Bounds2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Bounds3D(x: ConcreteType:Bounds2D): ConcreteType:Bounds3D [Library];
Reified type Ray2D
  Reified functions for group Ray2D_374:ConcreteType
    Ray2D_374:ConcreteType.Origin(self: ConcreteType:Ray2D): ConcreteType:Vector2D [Field];
    Ray2D_374:ConcreteType.Direction(self: ConcreteType:Ray2D): ConcreteType:Vector2D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Ray2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Ray2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Ray2D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Ray2D,b: ConcreteType:Ray2D): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Ray2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Ray2D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Ray2D,b: ConcreteType:Ray2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Ray2D,b: ConcreteType:Ray2D): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.To3D(x: ConcreteType:Ray2D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Ray3D(x: ConcreteType:Ray2D): ConcreteType:Ray3D [Library];
Reified type Triangle2D
  Reified functions for group Triangle2D_376:ConcreteType
    Triangle2D_376:ConcreteType.A(self: ConcreteType:Triangle2D): ConcreteType:Vector2D [Field];
    Triangle2D_376:ConcreteType.B(self: ConcreteType:Triangle2D): ConcreteType:Vector2D [Field];
    Triangle2D_376:ConcreteType.C(self: ConcreteType:Triangle2D): ConcreteType:Vector2D [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Triangle2D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Triangle2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Triangle2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Triangle2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Triangle2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Triangle2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Triangle2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Triangle2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Triangle2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Triangle2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Triangle2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Triangle2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Triangle2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Triangle2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Triangle2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Triangle2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Triangle2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Triangle2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Triangle2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Triangle2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Triangle2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Triangle2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Triangle2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Triangle2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Triangle2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Triangle2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Triangle2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Triangle2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Triangle2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Triangle2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Triangle2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Area(t: ConcreteType:Triangle2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Flip(t: ConcreteType:Triangle2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.Center(t: ConcreteType:Triangle2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Barycentric(t: ConcreteType:Triangle2D,uv: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Triangle2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Triangle2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.LineArray2D(t: ConcreteType:Triangle2D): ConcreteType:LineArray2D [Library];
    IGeometry_18:Library.TriangleArray2D(t: ConcreteType:Triangle2D): ConcreteType:TriangleArray2D [Library];
    IGeometry_18:Library.To3D(x: ConcreteType:Triangle2D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Triangle3D(x: ConcreteType:Triangle2D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Unit(_: ConcreteType:Triangle2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Triangle2D,ys: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Triangle2D,ys: ConcreteType:Triangle2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Triangle2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Quad2D
  Reified functions for group Quad2D_378:ConcreteType
    Quad2D_378:ConcreteType.A(self: ConcreteType:Quad2D): ConcreteType:Vector2D [Field];
    Quad2D_378:ConcreteType.B(self: ConcreteType:Quad2D): ConcreteType:Vector2D [Field];
    Quad2D_378:ConcreteType.C(self: ConcreteType:Quad2D): ConcreteType:Vector2D [Field];
    Quad2D_378:ConcreteType.D(self: ConcreteType:Quad2D): ConcreteType:Vector2D [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Quad2D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Quad2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Quad2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Quad2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Quad2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Quad2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Quad2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Quad2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Quad2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Quad2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Quad2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Quad2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Quad2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Quad2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Quad2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Quad2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Quad2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quad2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quad2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quad2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Quad2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quad2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Quad2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Quad2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Quad2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Quad2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Quad2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Quad2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Quad2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Quad2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Quad2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Quad2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Flip(q: ConcreteType:Quad2D): ConcreteType:Quad2D [Library];
    IGeometry_18:Library.Center(q: ConcreteType:Quad2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.LineA(q: ConcreteType:Quad2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.LineB(q: ConcreteType:Quad2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.LineC(q: ConcreteType:Quad2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.LineD(q: ConcreteType:Quad2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.TriangleA(q: ConcreteType:Quad2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.TriangleB(q: ConcreteType:Quad2D): ConcreteType:Triangle2D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Quad2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Quad2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.LineArray2D(q: ConcreteType:Quad2D): ConcreteType:LineArray2D [Library];
    IGeometry_18:Library.TriangleArray2D(q: ConcreteType:Quad2D): ConcreteType:TriangleArray2D [Library];
    IGeometry_18:Library.To3D(x: ConcreteType:Quad2D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Quad3D(x: ConcreteType:Quad2D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Unit(_: ConcreteType:Quad2D): ConcreteType:Quad2D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Triangles(q: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad2D): ConcreteType:Quad2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad2D): ConcreteType:Quad2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quad2D,ys: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quad2D,ys: ConcreteType:Quad2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Quad2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Line2D
  Reified functions for group Line2D_380:ConcreteType
    Line2D_380:ConcreteType.A(self: ConcreteType:Line2D): ConcreteType:Vector2D [Field];
    Line2D_380:ConcreteType.B(self: ConcreteType:Line2D): ConcreteType:Vector2D [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:Line2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Line2D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Line2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Line2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Line2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Line2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Line2D,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group IInterval_78:Concept
    IInterval_78:Concept.Start(x: ConcreteType:Line2D): ConcreteType:Vector2D [Concept];
    IInterval_78:Concept.End(x: ConcreteType:Line2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Line2D,b: ConcreteType:Line2D): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Line2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Line2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Line2D): ConcreteType:String [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Line2D> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Line2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Line2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Line2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Line2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Line2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Line2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Line2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Line2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Line2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Line2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Line2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Line2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Line2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Line2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Line2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Line2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Line2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Line2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Line2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Line2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Line2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Line2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Line2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Line2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Line2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Line2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Line2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Line2D,b: ConcreteType:Line2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Line2D,b: ConcreteType:Line2D): ConcreteType:Boolean [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Line2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Line2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Line2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Length(x: ConcreteType:Line2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Direction(x: ConcreteType:Line2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Ray2D(x: ConcreteType:Line2D): ConcreteType:Ray2D [Library];
    IGeometry_18:Library.Reverse(x: ConcreteType:Line2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.Start(x: ConcreteType:Line2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.End(x: ConcreteType:Line2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Line2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Line2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Eval(x: ConcreteType:Line2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.To3D(x: ConcreteType:Line2D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Line3D(x: ConcreteType:Line2D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Line2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Line2D,ys: ConcreteType:Line2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Line2D,ys: ConcreteType:Line2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group IInterval_20:Library
    IInterval_20:Library.Size(x: ConcreteType:Line2D): TypeVariable:$T [Library];
    IInterval_20:Library.Lerp(x: ConcreteType:Line2D,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IInterval_20:Library.Reverse(x: ConcreteType:Line2D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Center(x: ConcreteType:Line2D): TypeVariable:$T [Library];
    IInterval_20:Library.Contains(x: ConcreteType:Line2D,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IInterval_20:Library.Contains(x: ConcreteType:Line2D,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.Overlaps(x: ConcreteType:Line2D,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.SplitAt(x: ConcreteType:Line2D,t: ConcreteType:Number): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Split(x: ConcreteType:Line2D): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Left(x: ConcreteType:Line2D,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Right(x: ConcreteType:Line2D,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.MoveTo(x: ConcreteType:Line2D,v: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.LeftHalf(x: ConcreteType:Line2D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.RightHalf(x: ConcreteType:Line2D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Recenter(x: ConcreteType:Line2D,c: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:Line2D,y: Concept:IInterval<TypeVariable:$T>): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:Line2D,value: TypeVariable:$T): TypeVariable:$T [Library];
    IInterval_20:Library.LinearSpace(interval: ConcreteType:Line2D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.LinearSpaceExclusive(interval: ConcreteType:Line2D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpace(interval: ConcreteType:Line2D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpaceExclusive(interval: ConcreteType:Line2D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line2D,start: ConcreteType:Number,end: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line2D,subInterval: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line2D,count: ConcreteType:Integer): Concept:IArray<Concept:IInterval<TypeVariable:$T>> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Line2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Lens
  Reified functions for group Lens_382:ConcreteType
    Lens_382:ConcreteType.A(self: ConcreteType:Lens): ConcreteType:Circle [Field];
    Lens_382:ConcreteType.B(self: ConcreteType:Lens): ConcreteType:Circle [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Lens): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Lens): ConcreteType:Boolean [Library];
Reified type Rect2D
  Reified functions for group Rect2D_384:ConcreteType
    Rect2D_384:ConcreteType.Center(self: ConcreteType:Rect2D): ConcreteType:Vector2D [Field];
    Rect2D_384:ConcreteType.Size(self: ConcreteType:Rect2D): ConcreteType:Vector2D [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Rect2D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Rect2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:Rect2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Rect2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Rect2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Rect2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Rect2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Rect2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Rect2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Rect2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Rect2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Rect2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Rect2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Rect2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Rect2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Rect2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Rect2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Rect2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Rect2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Rect2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Rect2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Rect2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Rect2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Rect2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Rect2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Rect2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Rect2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Rect2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Rect2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Rect2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Rect2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:Rect2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Width(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Height(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Left(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Right(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Bottom(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Top(x: ConcreteType:Rect2D): ConcreteType:Number [Library];
    IGeometry_18:Library.BottomLeft(x: ConcreteType:Rect2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.BottomRight(x: ConcreteType:Rect2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.TopRight(x: ConcreteType:Rect2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.TopLeft(x: ConcreteType:Rect2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Quad2D(x: ConcreteType:Rect2D): ConcreteType:Quad2D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Rect2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Rect2D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Rect2D): ConcreteType:Rect2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Rect2D): ConcreteType:Rect2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Rect2D,ys: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Rect2D,ys: ConcreteType:Rect2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Rect2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Ring
  Reified functions for group Ring_386:ConcreteType
    Ring_386:ConcreteType.Center(self: ConcreteType:Ring): ConcreteType:Vector2D [Field];
    Ring_386:ConcreteType.InnerRadius(self: ConcreteType:Ring): ConcreteType:Number [Field];
    Ring_386:ConcreteType.OuterRadius(self: ConcreteType:Ring): ConcreteType:Number [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Ring): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Ring): ConcreteType:Boolean [Library];
Reified type Arc
  Reified functions for group Arc_388:ConcreteType
    Arc_388:ConcreteType.Angles(self: ConcreteType:Arc): ConcreteType:AnglePair [Field];
    Arc_388:ConcreteType.Circle(self: ConcreteType:Arc): ConcreteType:Circle [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Arc): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Arc): ConcreteType:Boolean [Library];
Reified type Sector
  Reified functions for group Sector_390:ConcreteType
    Sector_390:ConcreteType.Arc(self: ConcreteType:Sector): ConcreteType:Arc [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Sector): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Sector): ConcreteType:Boolean [Library];
Reified type Chord
  Reified functions for group Chord_392:ConcreteType
    Chord_392:ConcreteType.Arc(self: ConcreteType:Chord): ConcreteType:Arc [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Chord): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Chord): ConcreteType:Boolean [Library];
Reified type Segment
  Reified functions for group Segment_394:ConcreteType
    Segment_394:ConcreteType.Arc(self: ConcreteType:Segment): ConcreteType:Arc [Field];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Segment): ConcreteType:Boolean [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Closed(x: ConcreteType:Segment): ConcreteType:Boolean [Library];
Reified type RegularPolygon
  Reified functions for group RegularPolygon_396:ConcreteType
    RegularPolygon_396:ConcreteType.NumPoints(self: ConcreteType:RegularPolygon): ConcreteType:Integer [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:RegularPolygon): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:RegularPolygon,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:RegularPolygon,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:RegularPolygon): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): ConcreteType:Vector2D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:RegularPolygon): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:RegularPolygon): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:RegularPolygon): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:RegularPolygon,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:RegularPolygon,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:RegularPolygon,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:RegularPolygon,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:RegularPolygon): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:RegularPolygon,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:RegularPolygon,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:RegularPolygon,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:RegularPolygon,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:RegularPolygon,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:RegularPolygon): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:RegularPolygon,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:RegularPolygon,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:RegularPolygon,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:RegularPolygon,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:RegularPolygon): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:RegularPolygon,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:RegularPolygon,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:RegularPolygon): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:RegularPolygon): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Points(x: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.At(x: ConcreteType:RegularPolygon,n: ConcreteType:Integer): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Count(x: ConcreteType:RegularPolygon): ConcreteType:Integer [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:RegularPolygon): ConcreteType:RegularPolygon [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:RegularPolygon): ConcreteType:RegularPolygon [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:RegularPolygon,ys: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:RegularPolygon,ys: ConcreteType:RegularPolygon): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:RegularPolygon,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Box2D
  Reified functions for group Box2D_398:ConcreteType
    Box2D_398:ConcreteType.Center(self: ConcreteType:Box2D): ConcreteType:Vector2D [Field];
    Box2D_398:ConcreteType.Rotation(self: ConcreteType:Box2D): ConcreteType:Angle [Field];
    Box2D_398:ConcreteType.Extent(self: ConcreteType:Box2D): ConcreteType:Vector2D [Field];
Reified type Plane
  Reified functions for group Plane_400:ConcreteType
    Plane_400:ConcreteType.Normal(self: ConcreteType:Plane): ConcreteType:Vector3D [Field];
    Plane_400:ConcreteType.D(self: ConcreteType:Plane): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Plane): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Plane): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Plane): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Plane,b: ConcreteType:Plane): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Plane,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Plane> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Plane,b: ConcreteType:Plane): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Plane,b: ConcreteType:Plane): ConcreteType:Boolean [Library];
Reified type Bounds3D
  Reified functions for group Bounds3D_402:ConcreteType
    Bounds3D_402:ConcreteType.Min(self: ConcreteType:Bounds3D): ConcreteType:Vector3D [Field];
    Bounds3D_402:ConcreteType.Max(self: ConcreteType:Bounds3D): ConcreteType:Vector3D [Field];
  Reified functions for group IBounds_80:Concept
    IBounds_80:Concept.Min(x: ConcreteType:Bounds3D): ConcreteType:Vector3D [Concept];
    IBounds_80:Concept.Max(x: ConcreteType:Bounds3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Bounds3D,b: ConcreteType:Bounds3D): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Bounds3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Bounds3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Bounds3D): ConcreteType:String [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Bounds3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Bounds3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Bounds3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Bounds3D> [Library];
  Reified functions for group IBounds_2:Library
    IBounds_2:Library.Size(x: ConcreteType:Bounds3D): TypeVariable:$T [Library];
    IBounds_2:Library.Lerp(x: ConcreteType:Bounds3D,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IBounds_2:Library.Center(x: ConcreteType:Bounds3D): TypeVariable:$T [Library];
    IBounds_2:Library.Contains(x: ConcreteType:Bounds3D,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IBounds_2:Library.Contains(x: ConcreteType:Bounds3D,y: Concept:IBounds<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IBounds_2:Library.Overlaps(x: ConcreteType:Bounds3D,y: Concept:IBounds<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IBounds_2:Library.Recenter(x: ConcreteType:Bounds3D,c: TypeVariable:$T): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Clamp(x: ConcreteType:Bounds3D,y: Concept:IBounds<TypeVariable:$T>): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Clamp(x: ConcreteType:Bounds3D,value: TypeVariable:$T): TypeVariable:$T [Library];
    IBounds_2:Library.Include(x: ConcreteType:Bounds3D,value: TypeVariable:$T): Concept:IBounds<TypeVariable:$T> [Library];
    IBounds_2:Library.Include(x: ConcreteType:Bounds3D,y: Concept:IBounds<TypeVariable:$T>): Concept:IBounds<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Bounds3D,b: ConcreteType:Bounds3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Bounds3D,b: ConcreteType:Bounds3D): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Center(x: ConcreteType:Bounds3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Corners(x: ConcreteType:Bounds3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Empty(_: ConcreteType:Bounds3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Bounds3D,t: Concept:ITransform3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Bounds3D,v: ConcreteType:Vector3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Bounds3D,q: ConcreteType:Quaternion): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Bounds3D,v: ConcreteType:Vector3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Bounds3D,a: ConcreteType:Angle): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Bounds3D,a: ConcreteType:Angle): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Bounds3D,a: ConcreteType:Angle): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Bounds3D,s: ConcreteType:Number): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Bounds3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Bounds3D [Library];
Reified type Line3D
  Reified functions for group Line3D_404:ConcreteType
    Line3D_404:ConcreteType.A(self: ConcreteType:Line3D): ConcreteType:Vector3D [Field];
    Line3D_404:ConcreteType.B(self: ConcreteType:Line3D): ConcreteType:Vector3D [Field];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:Line3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Line3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Line3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Line3D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Line3D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Line3D,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Line3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Line3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Line3D,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group IInterval_78:Concept
    IInterval_78:Concept.Start(x: ConcreteType:Line3D): ConcreteType:Vector3D [Concept];
    IInterval_78:Concept.End(x: ConcreteType:Line3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Line3D,b: ConcreteType:Line3D): ConcreteType:Boolean [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Line3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Line3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Line3D): ConcreteType:String [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Line3D> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Line3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Line3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Line3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Line3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Line3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Line3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Line3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Line3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Line3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Line3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Line3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Line3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Line3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Line3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Line3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Line3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Line3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Line3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Line3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Line3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Line3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Line3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Line3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Line3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Line3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Line3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Line3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Line3D,b: ConcreteType:Line3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Line3D,b: ConcreteType:Line3D): ConcreteType:Boolean [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Line3D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Line3D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:Line3D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Length(x: ConcreteType:Line3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Direction(x: ConcreteType:Line3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Ray3D(x: ConcreteType:Line3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Reverse(x: ConcreteType:Line3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Line3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Bounds3D(x: ConcreteType:Line3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Start(x: ConcreteType:Line3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.End(x: ConcreteType:Line3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Line3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Line3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Eval(x: ConcreteType:Line3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Line3D,t: Concept:ITransform3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Line3D,v: ConcreteType:Vector3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Line3D,q: ConcreteType:Quaternion): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Line3D,v: ConcreteType:Vector3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Line3D,a: ConcreteType:Angle): ConcreteType:Line3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Line3D,a: ConcreteType:Angle): ConcreteType:Line3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Line3D,a: ConcreteType:Angle): ConcreteType:Line3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Line3D,s: ConcreteType:Number): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Line3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Line3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Line3D,ys: ConcreteType:Line3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Line3D,ys: ConcreteType:Line3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group IInterval_20:Library
    IInterval_20:Library.Size(x: ConcreteType:Line3D): TypeVariable:$T [Library];
    IInterval_20:Library.Lerp(x: ConcreteType:Line3D,amount: ConcreteType:Number): TypeVariable:$T [Library];
    IInterval_20:Library.Reverse(x: ConcreteType:Line3D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Center(x: ConcreteType:Line3D): TypeVariable:$T [Library];
    IInterval_20:Library.Contains(x: ConcreteType:Line3D,value: TypeVariable:$T): ConcreteType:Boolean [Library];
    IInterval_20:Library.Contains(x: ConcreteType:Line3D,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.Overlaps(x: ConcreteType:Line3D,y: Concept:IInterval<TypeVariable:$T>): ConcreteType:Boolean [Library];
    IInterval_20:Library.SplitAt(x: ConcreteType:Line3D,t: ConcreteType:Number): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Split(x: ConcreteType:Line3D): ConcreteType:Tuple2<Concept:IInterval<TypeVariable:$T>,Concept:IInterval<TypeVariable:$T>> [Library];
    IInterval_20:Library.Left(x: ConcreteType:Line3D,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Right(x: ConcreteType:Line3D,t: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.MoveTo(x: ConcreteType:Line3D,v: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.LeftHalf(x: ConcreteType:Line3D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.RightHalf(x: ConcreteType:Line3D): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Recenter(x: ConcreteType:Line3D,c: TypeVariable:$T): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:Line3D,y: Concept:IInterval<TypeVariable:$T>): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Clamp(x: ConcreteType:Line3D,value: TypeVariable:$T): TypeVariable:$T [Library];
    IInterval_20:Library.LinearSpace(interval: ConcreteType:Line3D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.LinearSpaceExclusive(interval: ConcreteType:Line3D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpace(interval: ConcreteType:Line3D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.GeometricSpaceExclusive(interval: ConcreteType:Line3D,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line3D,start: ConcreteType:Number,end: ConcreteType:Number): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line3D,subInterval: ConcreteType:NumberInterval): Concept:IInterval<TypeVariable:$T> [Library];
    IInterval_20:Library.Subdivide(interval: ConcreteType:Line3D,count: ConcreteType:Integer): Concept:IArray<Concept:IInterval<TypeVariable:$T>> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Line3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Ray3D
  Reified functions for group Ray3D_406:ConcreteType
    Ray3D_406:ConcreteType.Origin(self: ConcreteType:Ray3D): ConcreteType:Vector3D [Field];
    Ray3D_406:ConcreteType.Direction(self: ConcreteType:Ray3D): ConcreteType:Vector3D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Ray3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Ray3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Ray3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Ray3D,b: ConcreteType:Ray3D): ConcreteType:Boolean [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Ray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Ray3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Ray3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Ray3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Ray3D,b: ConcreteType:Ray3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Ray3D,b: ConcreteType:Ray3D): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Angle(a: ConcreteType:Ray3D,b: ConcreteType:Ray3D): ConcreteType:Angle [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Ray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Line3D(r: ConcreteType:Ray3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Reverse(r: ConcreteType:Ray3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Ray3D,t: Concept:ITransform3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Ray3D,v: ConcreteType:Vector3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Ray3D,q: ConcreteType:Quaternion): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Ray3D,v: ConcreteType:Vector3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Ray3D,a: ConcreteType:Angle): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Ray3D,a: ConcreteType:Angle): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Ray3D,a: ConcreteType:Angle): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Ray3D,s: ConcreteType:Number): ConcreteType:Ray3D [Library];
Reified type Triangle3D
  Reified functions for group Triangle3D_408:ConcreteType
    Triangle3D_408:ConcreteType.A(self: ConcreteType:Triangle3D): ConcreteType:Vector3D [Field];
    Triangle3D_408:ConcreteType.B(self: ConcreteType:Triangle3D): ConcreteType:Vector3D [Field];
    Triangle3D_408:ConcreteType.C(self: ConcreteType:Triangle3D): ConcreteType:Vector3D [Field];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Triangle3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Triangle3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Triangle3D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Triangle3D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Triangle3D,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Triangle3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Triangle3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Triangle3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Triangle3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Triangle3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Triangle3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Triangle3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Triangle3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Triangle3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Triangle3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Triangle3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Triangle3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Triangle3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Triangle3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Triangle3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Triangle3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Triangle3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Triangle3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Triangle3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Triangle3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Triangle3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Triangle3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Triangle3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Triangle3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Triangle3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Triangle3D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Triangle3D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:Triangle3D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Flip(t: ConcreteType:Triangle3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Normal(t: ConcreteType:Triangle3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Center(t: ConcreteType:Triangle3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Plane(t: ConcreteType:Triangle3D): ConcreteType:Plane [Library];
    IGeometry_18:Library.Barycentric(t: ConcreteType:Triangle3D,uv: ConcreteType:Vector2D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.LineA(t: ConcreteType:Triangle3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.LineB(t: ConcreteType:Triangle3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.LineC(t: ConcreteType:Triangle3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Deform(t: ConcreteType:Triangle3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Triangle3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Triangle3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.LineArray3D(t: ConcreteType:Triangle3D): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.TriangleArray3D(t: ConcreteType:Triangle3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:Triangle3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Triangle3D,t: Concept:ITransform3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Triangle3D,v: ConcreteType:Vector3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Triangle3D,q: ConcreteType:Quaternion): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Triangle3D,v: ConcreteType:Vector3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Triangle3D,a: ConcreteType:Angle): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Triangle3D,a: ConcreteType:Angle): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Triangle3D,a: ConcreteType:Angle): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Triangle3D,s: ConcreteType:Number): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Triangle3D,ys: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Triangle3D,ys: ConcreteType:Triangle3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Triangle3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Quad3D
  Reified functions for group Quad3D_410:ConcreteType
    Quad3D_410:ConcreteType.A(self: ConcreteType:Quad3D): ConcreteType:Vector3D [Field];
    Quad3D_410:ConcreteType.B(self: ConcreteType:Quad3D): ConcreteType:Vector3D [Field];
    Quad3D_410:ConcreteType.C(self: ConcreteType:Quad3D): ConcreteType:Vector3D [Field];
    Quad3D_410:ConcreteType.D(self: ConcreteType:Quad3D): ConcreteType:Vector3D [Field];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Quad3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Quad3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:Quad3D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Quad3D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Quad3D,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Quad3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Quad3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Quad3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Quad3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Quad3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Quad3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Quad3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Quad3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Quad3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Quad3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Quad3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Quad3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Quad3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Quad3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quad3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quad3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quad3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Quad3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quad3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Quad3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Quad3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Quad3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Quad3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Quad3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Quad3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Quad3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:Quad3D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:Quad3D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:Quad3D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Flip(q: ConcreteType:Quad3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Center(q: ConcreteType:Quad3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.LineA(q: ConcreteType:Quad3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.LineB(q: ConcreteType:Quad3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.LineC(q: ConcreteType:Quad3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.LineD(q: ConcreteType:Quad3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.TriangleA(q: ConcreteType:Quad3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.TriangleB(q: ConcreteType:Quad3D): ConcreteType:Triangle3D [Library];
    IGeometry_18:Library.Deform(q: ConcreteType:Quad3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Quad3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Closed(x: ConcreteType:Quad3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.LineArray3D(q: ConcreteType:Quad3D): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.TriangleArray3D(q: ConcreteType:Quad3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.QuadArray3D(q: ConcreteType:Quad3D): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:Quad3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Quad3D,t: Concept:ITransform3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Quad3D,v: ConcreteType:Vector3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Quad3D,q: ConcreteType:Quaternion): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Quad3D,v: ConcreteType:Vector3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Quad3D,a: ConcreteType:Angle): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Quad3D,a: ConcreteType:Angle): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Quad3D,a: ConcreteType:Angle): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Quad3D,s: ConcreteType:Number): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Points(x: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(q: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad3D): ConcreteType:Quad3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quad3D,ys: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quad3D,ys: ConcreteType:Quad3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Quad3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type LineMesh3D
  Reified functions for group LineMesh3D_412:ConcreteType
    LineMesh3D_412:ConcreteType.Points(self: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Vector3D> [Field];
    LineMesh3D_412:ConcreteType.Indices(self: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Integer> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:LineMesh3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:LineMesh3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:LineMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:LineMesh3D [Concept];
  Reified functions for group ILineGeometry3D_322:Concept
    ILineGeometry3D_322:Concept.Lines(x: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Line3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.NumFaces(g: ConcreteType:LineMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:LineMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:LineMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:LineMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:LineMesh3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:LineMesh3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:LineMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:LineMesh3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:LineMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:LineMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:LineMesh3D,t: Concept:ITransform3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:LineMesh3D,v: ConcreteType:Vector3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:LineMesh3D,q: ConcreteType:Quaternion): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:LineMesh3D,v: ConcreteType:Vector3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:LineMesh3D,a: ConcreteType:Angle): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:LineMesh3D,a: ConcreteType:Angle): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:LineMesh3D,a: ConcreteType:Angle): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:LineMesh3D,s: ConcreteType:Number): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:LineMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:LineMesh3D [Library];
Reified type TriangleMesh3D
  Reified functions for group TriangleMesh3D_414:ConcreteType
    TriangleMesh3D_414:ConcreteType.Points(self: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Vector3D> [Field];
    TriangleMesh3D_414:ConcreteType.Indices(self: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Integer> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:TriangleMesh3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:TriangleMesh3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:TriangleMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:TriangleMesh3D [Concept];
  Reified functions for group ITriangleGeometry3D_326:Concept
    ITriangleGeometry3D_326:Concept.Triangles(x: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Triangle3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:TriangleMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:TriangleMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:TriangleMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:TriangleMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:TriangleMesh3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:TriangleMesh3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:TriangleMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Triangles(x: ConcreteType:TriangleMesh3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:TriangleMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:TriangleMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.LineMesh3D(g: ConcreteType:TriangleMesh3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:TriangleMesh3D,t: Concept:ITransform3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:TriangleMesh3D,v: ConcreteType:Vector3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:TriangleMesh3D,q: ConcreteType:Quaternion): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:TriangleMesh3D,v: ConcreteType:Vector3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:TriangleMesh3D,a: ConcreteType:Angle): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:TriangleMesh3D,a: ConcreteType:Angle): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:TriangleMesh3D,a: ConcreteType:Angle): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:TriangleMesh3D,s: ConcreteType:Number): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:TriangleMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:TriangleMesh3D [Library];
Reified type QuadMesh3D
  Reified functions for group QuadMesh3D_416:ConcreteType
    QuadMesh3D_416:ConcreteType.Points(self: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Vector3D> [Field];
    QuadMesh3D_416:ConcreteType.Indices(self: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Integer> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:QuadMesh3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:QuadMesh3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:QuadMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadMesh3D [Concept];
  Reified functions for group IQuadGeometry3D_330:Concept
    IQuadGeometry3D_330:Concept.Quads(x: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Quad3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:QuadMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:QuadMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:QuadMesh3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:QuadMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:QuadMesh3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:QuadMesh3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:QuadMesh3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Quads(x: ConcreteType:QuadMesh3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:QuadMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:QuadMesh3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.LineMesh3D(g: ConcreteType:QuadMesh3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:QuadMesh3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadMesh3D,t: Concept:ITransform3D): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:QuadMesh3D,v: ConcreteType:Vector3D): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:QuadMesh3D,q: ConcreteType:Quaternion): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadMesh3D,v: ConcreteType:Vector3D): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:QuadMesh3D,a: ConcreteType:Angle): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:QuadMesh3D,a: ConcreteType:Angle): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:QuadMesh3D,a: ConcreteType:Angle): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:QuadMesh3D,s: ConcreteType:Number): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadMesh3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadMesh3D [Library];
Reified type PolyLine2D
  Reified functions for group PolyLine2D_418:ConcreteType
    PolyLine2D_418:ConcreteType.Points(self: ConcreteType:PolyLine2D): Concept:IArray<ConcreteType:Vector2D> [Field];
    PolyLine2D_418:ConcreteType.Closed(self: ConcreteType:PolyLine2D): ConcreteType:Boolean [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:PolyLine2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:PolyLine2D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:PolyLine2D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField2D_256:Concept
    IDistanceField2D_256:Concept.Distance(x: ConcreteType:PolyLine2D,p: ConcreteType:Vector2D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:PolyLine2D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:PolyLine2D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    Curves_6:Library.ToPolyLine2D(curve: ConcreteType:PolyLine2D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.To3D(x: ConcreteType:PolyLine2D): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.PolyLine3D(x: ConcreteType:PolyLine2D): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:PolyLine2D): Concept:IArray<ConcreteType:Line2D> [Library];
Reified type PolyLine3D
  Reified functions for group PolyLine3D_420:ConcreteType
    PolyLine3D_420:ConcreteType.Points(self: ConcreteType:PolyLine3D): Concept:IArray<ConcreteType:Vector3D> [Field];
    PolyLine3D_420:ConcreteType.Closed(self: ConcreteType:PolyLine3D): ConcreteType:Boolean [Field];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:PolyLine3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:PolyLine3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:PolyLine3D [Concept];
  Reified functions for group IOpenClosedShape_226:Concept
    IOpenClosedShape_226:Concept.Closed(x: ConcreteType:PolyLine3D): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:PolyLine3D,t: ConcreteType:Number): TypeVariable:TRange [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:PolyLine3D,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Closed(curve: ConcreteType:PolyLine3D): ConcreteType:Boolean [Library];
    Curves_6:Library.Sample(curve: ConcreteType:PolyLine3D,numPoints: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    Curves_6:Library.ToPolyLine3D(curve: ConcreteType:PolyLine3D,numPoints: ConcreteType:Integer): ConcreteType:PolyLine3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Deform(x: ConcreteType:PolyLine3D,t: Concept:ITransform3D): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:PolyLine3D,v: ConcreteType:Vector3D): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:PolyLine3D,q: ConcreteType:Quaternion): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:PolyLine3D,v: ConcreteType:Vector3D): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:PolyLine3D,a: ConcreteType:Angle): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:PolyLine3D,a: ConcreteType:Angle): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:PolyLine3D,a: ConcreteType:Angle): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:PolyLine3D,s: ConcreteType:Number): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:PolyLine3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:PolyLine3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:PolyLine3D): Concept:IArray<ConcreteType:Line3D> [Library];
Reified type PointArray2D
  Reified functions for group PointArray2D_422:ConcreteType
    PointArray2D_422:ConcreteType.Points(self: ConcreteType:PointArray2D): Concept:IArray<ConcreteType:Vector2D> [Field];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:PointArray2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Indices(x: ConcreteType:PointArray2D): Concept:IArray<ConcreteType:Integer> [Library];
Reified type PointArray3D
  Reified functions for group PointArray3D_424:ConcreteType
    PointArray3D_424:ConcreteType.Points(self: ConcreteType:PointArray3D): Concept:IArray<ConcreteType:Vector3D> [Field];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:PointArray3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:PointArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:PointArray3D [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Indices(x: ConcreteType:PointArray3D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:PointArray3D,t: Concept:ITransform3D): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:PointArray3D,v: ConcreteType:Vector3D): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:PointArray3D,q: ConcreteType:Quaternion): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:PointArray3D,v: ConcreteType:Vector3D): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:PointArray3D,a: ConcreteType:Angle): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:PointArray3D,a: ConcreteType:Angle): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:PointArray3D,a: ConcreteType:Angle): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:PointArray3D,s: ConcreteType:Number): ConcreteType:PointArray3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:PointArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:PointArray3D [Library];
Reified type LineArray2D
  Reified functions for group LineArray2D_426:ConcreteType
    LineArray2D_426:ConcreteType.Lines(self: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Line2D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:LineArray2D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:LineArray2D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group ILineGeometry2D_320:Concept
    ILineGeometry2D_320:Concept.Lines(x: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Line2D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.NumFaces(g: ConcreteType:LineArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:LineArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:LineArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:LineArray2D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:LineArray2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:LineArray2D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:LineArray2D): Concept:IArray<Concept:IArray<ConcreteType:Vector2D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:LineArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:LineArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:LineArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
Reified type LineArray3D
  Reified functions for group LineArray3D_428:ConcreteType
    LineArray3D_428:ConcreteType.Lines(self: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Line3D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:LineArray3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:LineArray3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:LineArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:LineArray3D [Concept];
  Reified functions for group ILineGeometry3D_322:Concept
    ILineGeometry3D_322:Concept.Lines(x: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Line3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.NumFaces(g: ConcreteType:LineArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:LineArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:LineArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:LineArray3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:LineArray3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:LineArray3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:LineArray3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(x: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:LineArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:LineArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:LineArray3D,t: Concept:ITransform3D): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:LineArray3D,v: ConcreteType:Vector3D): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:LineArray3D,q: ConcreteType:Quaternion): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:LineArray3D,v: ConcreteType:Vector3D): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:LineArray3D,a: ConcreteType:Angle): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:LineArray3D,a: ConcreteType:Angle): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:LineArray3D,a: ConcreteType:Angle): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:LineArray3D,s: ConcreteType:Number): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:LineArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:LineArray3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:LineArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
Reified type TriangleArray2D
  Reified functions for group TriangleArray2D_430:ConcreteType
    TriangleArray2D_430:ConcreteType.Triangles(self: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Triangle2D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:TriangleArray2D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:TriangleArray2D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group ITriangleGeometry2D_324:Concept
    ITriangleGeometry2D_324:Concept.Triangles(x: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Triangle2D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:TriangleArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:TriangleArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:TriangleArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:TriangleArray2D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:TriangleArray2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:TriangleArray2D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:TriangleArray2D): Concept:IArray<Concept:IArray<ConcreteType:Vector2D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Triangles(x: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:TriangleArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:TriangleArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:TriangleArray2D): Concept:IArray<ConcreteType:Line2D> [Library];
Reified type TriangleArray3D
  Reified functions for group TriangleArray3D_432:ConcreteType
    TriangleArray3D_432:ConcreteType.Triangles(self: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Triangle3D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:TriangleArray3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:TriangleArray3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:TriangleArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:TriangleArray3D [Concept];
  Reified functions for group ITriangleGeometry3D_326:Concept
    ITriangleGeometry3D_326:Concept.Triangles(x: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Triangle3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:TriangleArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:TriangleArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:TriangleArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:TriangleArray3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:TriangleArray3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:TriangleArray3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:TriangleArray3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Triangles(x: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:TriangleArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:TriangleArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.LineMesh3D(g: ConcreteType:TriangleArray3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:TriangleArray3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:TriangleArray3D,t: Concept:ITransform3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:TriangleArray3D,v: ConcreteType:Vector3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:TriangleArray3D,q: ConcreteType:Quaternion): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:TriangleArray3D,v: ConcreteType:Vector3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:TriangleArray3D,a: ConcreteType:Angle): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:TriangleArray3D,a: ConcreteType:Angle): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:TriangleArray3D,a: ConcreteType:Angle): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:TriangleArray3D,s: ConcreteType:Number): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:TriangleArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:TriangleArray3D): Concept:IArray<ConcreteType:Line3D> [Library];
Reified type QuadArray2D
  Reified functions for group QuadArray2D_434:ConcreteType
    QuadArray2D_434:ConcreteType.Quads(self: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Quad2D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:QuadArray2D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:QuadArray2D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry2D_312:Concept
    IPointGeometry2D_312:Concept.Points(x: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Vector2D> [Concept];
  Reified functions for group IQuadGeometry2D_328:Concept
    IQuadGeometry2D_328:Concept.Quads(x: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Quad2D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Quad2D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:QuadArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:QuadArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:QuadArray2D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:QuadArray2D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:QuadArray2D,n: ConcreteType:Integer): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:QuadArray2D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:QuadArray2D): Concept:IArray<Concept:IArray<ConcreteType:Vector2D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Quads(x: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Quad2D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:QuadArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:QuadArray2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadArray2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
Reified type QuadArray3D
  Reified functions for group QuadArray3D_436:ConcreteType
    QuadArray3D_436:ConcreteType.Quads(self: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Quad3D> [Field];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:QuadArray3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:QuadArray3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:QuadArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadArray3D [Concept];
  Reified functions for group IQuadGeometry3D_330:Concept
    IQuadGeometry3D_330:Concept.Quads(x: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Quad3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:QuadArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:QuadArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:QuadArray3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:QuadArray3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:QuadArray3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:QuadArray3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:QuadArray3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Quads(x: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:QuadArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:QuadArray3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.LineMesh3D(g: ConcreteType:QuadArray3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TriangleArray3D(q: ConcreteType:QuadArray3D): ConcreteType:TriangleArray3D [Library];
    IGeometry_18:Library.QuadMesh3D(self: ConcreteType:QuadArray3D): ConcreteType:QuadMesh3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:QuadArray3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadArray3D,t: Concept:ITransform3D): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:QuadArray3D,v: ConcreteType:Vector3D): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:QuadArray3D,q: ConcreteType:Quaternion): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadArray3D,v: ConcreteType:Vector3D): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:QuadArray3D,a: ConcreteType:Angle): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:QuadArray3D,a: ConcreteType:Angle): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:QuadArray3D,a: ConcreteType:Angle): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:QuadArray3D,s: ConcreteType:Number): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadArray3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadArray3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:QuadArray3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
Reified type QuadGrid3D
  Reified functions for group QuadGrid3D_438:ConcreteType
    QuadGrid3D_438:ConcreteType.PointGrid(self: ConcreteType:QuadGrid3D): Concept:IArray2D<ConcreteType:Vector3D> [Field];
    QuadGrid3D_438:ConcreteType.ClosedX(self: ConcreteType:QuadGrid3D): ConcreteType:Boolean [Field];
    QuadGrid3D_438:ConcreteType.ClosedY(self: ConcreteType:QuadGrid3D): ConcreteType:Boolean [Field];
  Reified functions for group IQuadGrid3D_366:Concept
    IQuadGrid3D_366:Concept.PointGrid(x: ConcreteType:QuadGrid3D): Concept:IArray2D<ConcreteType:Vector3D> [Concept];
    IQuadGrid3D_366:Concept.ClosedX(x: ConcreteType:QuadGrid3D): ConcreteType:Boolean [Concept];
    IQuadGrid3D_366:Concept.ClosedY(x: ConcreteType:QuadGrid3D): ConcreteType:Boolean [Concept];
  Reified functions for group IIndexedGeometry_332:Concept
    IIndexedGeometry_332:Concept.Indices(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Integer> [Concept];
  Reified functions for group IPrimitiveGeometry_302:Concept
    IPrimitiveGeometry_302:Concept.PrimitiveSize(x: ConcreteType:QuadGrid3D): ConcreteType:Integer [Concept];
    IPrimitiveGeometry_302:Concept.NumPrimitives(x: ConcreteType:QuadGrid3D): ConcreteType:Integer [Concept];
  Reified functions for group IPointGeometry3D_314:Concept
    IPointGeometry3D_314:Concept.Points(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Vector3D> [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:QuadGrid3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadGrid3D [Concept];
  Reified functions for group IQuadGeometry3D_330:Concept
    IQuadGeometry3D_330:Concept.Quads(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Quad3D> [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Faces(g: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumFaces(g: ConcreteType:QuadGrid3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.FaceIndices(g: ConcreteType:QuadGrid3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    IGeometry_18:Library.FaceVertices(g: ConcreteType:QuadGrid3D,f: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceIndices(g: ConcreteType:QuadGrid3D): Concept:IArray<Concept:IArray<ConcreteType:Integer>> [Library];
    IGeometry_18:Library.Vertex(g: ConcreteType:QuadGrid3D,n: ConcreteType:Integer): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Vertices(g: ConcreteType:QuadGrid3D,xs: Concept:IArray<ConcreteType:Integer>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.AllFaceVertices(g: ConcreteType:QuadGrid3D): Concept:IArray<Concept:IArray<ConcreteType:Vector3D>> [Library];
    IGeometry_18:Library.AllVertices(g: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Quads(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Quad3D> [Library];
    IGeometry_18:Library.NumPrimitives(g: ConcreteType:QuadGrid3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.PrimitiveSize(g: ConcreteType:QuadGrid3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.LineMesh3D(g: ConcreteType:QuadGrid3D): ConcreteType:LineMesh3D [Library];
    IGeometry_18:Library.TriangleMesh3D(g: ConcreteType:QuadGrid3D): ConcreteType:TriangleMesh3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadGrid3D,t: Concept:ITransform3D): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:QuadGrid3D,v: ConcreteType:Vector3D): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:QuadGrid3D,q: ConcreteType:Quaternion): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadGrid3D,v: ConcreteType:Vector3D): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:QuadGrid3D,a: ConcreteType:Angle): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:QuadGrid3D,a: ConcreteType:Angle): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:QuadGrid3D,a: ConcreteType:Angle): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:QuadGrid3D,s: ConcreteType:Number): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:QuadGrid3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:QuadGrid3D [Library];
    IGeometry_18:Library.NumColumns(x: ConcreteType:QuadGrid3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.NumRows(x: ConcreteType:QuadGrid3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.Points(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Indices(x: ConcreteType:QuadGrid3D): Concept:IArray<ConcreteType:Integer> [Library];
Reified type Number
  Reified functions for group INumberLike_40:Concept
    INumberLike_40:Concept.ToNumber(x: ConcreteType:Number): ConcreteType:Number [Concept];
    INumberLike_40:Concept.FromNumber(x: ConcreteType:Number,n: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Number): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Number,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Number [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Number): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Number): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Number): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Number,other: ConcreteType:Number): ConcreteType:Number [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Number,other: ConcreteType:Number): ConcreteType:Number [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Number,other: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Boolean [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Number,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.OunceToGram(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.TroyOunceToGram(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.GrainToMilligram(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Mole(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Min(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Max(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Inverse(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Reciprocal(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.SquareRoot(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Sqrt(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.InversePow(x: ConcreteType:Number,n: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Exp(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.SmoothStep(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MultiplyEpsilon(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.AlmostEqual(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.AlmostZero(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.AlmostZeroOrOne(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.Fract(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Pow2(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Square(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Magnitude(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.GtZ(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.LtZ(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.GtEqZ(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.LtEqZ(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.IsPositive(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.IsNegative(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.Sign(x: ConcreteType:Number): ConcreteType:Integer [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Between(self: ConcreteType:Number,min: ConcreteType:Number,max: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.Half(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Million(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Turns(x: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Degrees(x: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Gradians(x: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Radians(x: ConcreteType:Number): ConcreteType:Angle [Library];
    INumerical_4:Library.Sin(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Cos(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Tan(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Component(x: ConcreteType:Number,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Number): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Number,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Number [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Number,y: ConcreteType:Number,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Number [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.One(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Number,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Number,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Number,a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Number,a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Integer [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Number(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.FromNumber(x: ConcreteType:Number,n: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Compare(a: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Integer [Library];
    INumerical_4:Library.Add(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Subract(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Number,s: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Number,s: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Number,s: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Number,b: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Number,v2: ConcreteType:Number,v3: ConcreteType:Number,uv: ConcreteType:Vector2D): ConcreteType:Number [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Linear(x: ConcreteType:Number,m: ConcreteType:Number,b: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.Quadratic(x: ConcreteType:Number,a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.Cubic(x: ConcreteType:Number,a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,d: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.SineWave(x: ConcreteType:Number,amplitude: ConcreteType:Number,frequency: ConcreteType:Number,phase: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.Parabola(x: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.StaircaseFloor(x: ConcreteType:Number,steps: ConcreteType:Integer): ConcreteType:Number [Library];
    Curves_6:Library.StaircaseCeiling(x: ConcreteType:Number,steps: ConcreteType:Integer): ConcreteType:Number [Library];
    Curves_6:Library.StaircaseRound(x: ConcreteType:Number,steps: ConcreteType:Integer): ConcreteType:Number [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,d: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,d: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,d: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Number,b: ConcreteType:Number,c: ConcreteType:Number,t: ConcreteType:Number): ConcreteType:Number [Library];
  Reified functions for group Curves2D_8:Library
    Curves2D_8:Library.Spiral(t: ConcreteType:Number,R: ConcreteType:Number,r: ConcreteType:Number,numTurns: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Acos(x: ConcreteType:Number): ConcreteType:Angle [Intrinsic];
    Intrinsics_22:Library.Asin(x: ConcreteType:Number): ConcreteType:Angle [Intrinsic];
    Intrinsics_22:Library.Atan(x: ConcreteType:Number): ConcreteType:Angle [Intrinsic];
    Intrinsics_22:Library.Atan2(y: ConcreteType:Number,x: ConcreteType:Number): ConcreteType:Angle [Intrinsic];
    Intrinsics_22:Library.Pow(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Log(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Ln(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Exp(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Floor(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Ceiling(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Round(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Truncate(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Add(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Subtract(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Divide(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Multiply(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Modulo(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Negative(x: ConcreteType:Number): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.LessThanOrEquals(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Equals(x: ConcreteType:Number,y: ConcreteType:Number): ConcreteType:Boolean [Intrinsic];
Reified type Integer
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Integer): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Integer): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Integer): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Boolean [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Integer,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.Range(n: ConcreteType:Integer): Concept:IArray<ConcreteType:Integer> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Square(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.ToNumber(x: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.FloatDivision(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.Fractions(x: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    INumerical_4:Library.FractionsExclusive(x: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Integer,b: ConcreteType:Integer): ConcreteType:Integer [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Integer): ConcreteType:Integer [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.CirclePoints(n: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.QuadFaceIndices(col: ConcreteType:Integer,row: ConcreteType:Integer,nCols: ConcreteType:Integer,nRows: ConcreteType:Integer): ConcreteType:Integer4 [Library];
    IGeometry_18:Library.AllQuadFaceIndices(nCols: ConcreteType:Integer,nRows: ConcreteType:Integer,closedX: ConcreteType:Boolean,closedY: ConcreteType:Boolean): Concept:IArray2D<ConcreteType:Integer4> [Library];
  Reified functions for group IInterval_20:Library
    IInterval_20:Library.LinearSpace(count: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    IInterval_20:Library.LinearSpaceExclusive(count: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    IInterval_20:Library.GeometricSpace(count: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    IInterval_20:Library.GeometricSpaceExclusive(count: ConcreteType:Integer): Concept:IArray<ConcreteType:Number> [Library];
    IInterval_20:Library.Intervals(count: ConcreteType:Integer): Concept:IArray<ConcreteType:NumberInterval> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Add(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Subtract(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Divide(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Multiply(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Modulo(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Negative(x: ConcreteType:Integer): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.Number(x: ConcreteType:Integer): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.LessThanOrEquals(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Equals(x: ConcreteType:Integer,y: ConcreteType:Integer): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.MapRange(x: ConcreteType:Integer,f: ConcreteType:Function1<ConcreteType:Integer,TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Intrinsic];
    Intrinsics_22:Library.MakeArray2D(columns: ConcreteType:Integer,rows: ConcreteType:Integer,f: ConcreteType:Function2<ConcreteType:Integer,ConcreteType:Integer,TypeVariable:$T>): Concept:IArray2D<TypeVariable:$T> [Intrinsic];
Reified type String
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:String): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:String): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:String): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:String,y: ConcreteType:String): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:String): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:String,n: ConcreteType:Integer): ConcreteType:Character [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<ConcreteType:String> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:String): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:String): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:String): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:String): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:String,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:String,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:String,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:String,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:String,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:String,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:String): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:String,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:String,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:String,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:String,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:String,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:String,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:String,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:String,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:String,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:String,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:String,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:String,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:String): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:String,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:String,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:String,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:String,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:String [Library];
    INumerical_4:Library.Greater(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:String [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:String,b: ConcreteType:String): ConcreteType:Integer [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:String): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:String): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:String): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:String): ConcreteType:String [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:String): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:String): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:String): ConcreteType:String [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:String): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:String): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:String,ys: ConcreteType:String): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:String,ys: ConcreteType:String): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.At(x: ConcreteType:String,y: ConcreteType:Integer): ConcreteType:Character [Intrinsic];
    Intrinsics_22:Library.Count(x: ConcreteType:String): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.LessThanOrEquals(x: ConcreteType:String,y: ConcreteType:String): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Equals(x: ConcreteType:String,y: ConcreteType:String): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:String,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Boolean
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Boolean): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Boolean): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Boolean): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Boolean,y: ConcreteType:Boolean): ConcreteType:Boolean [Concept];
  Reified functions for group IBoolean_76:Concept
    IBoolean_76:Concept.And(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Concept];
    IBoolean_76:Concept.Or(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Concept];
    IBoolean_76:Concept.Not(a: ConcreteType:Boolean): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Boolean,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Boolean> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Boolean [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Boolean,b: ConcreteType:Boolean): ConcreteType:Integer [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.And(x: ConcreteType:Boolean,y: ConcreteType:Boolean): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Or(x: ConcreteType:Boolean,y: ConcreteType:Boolean): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Not(x: ConcreteType:Boolean): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.LessThanOrEquals(x: ConcreteType:Boolean,y: ConcreteType:Boolean): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Equals(x: ConcreteType:Boolean,y: ConcreteType:Boolean): ConcreteType:Boolean [Intrinsic];
Reified type Character
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Character): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Character): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Character): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Concept];
  Reified functions for group IOrderable_52:Concept
    IOrderable_52:Concept.LessThanOrEquals(x: ConcreteType:Character,y: ConcreteType:Character): ConcreteType:Boolean [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Character,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Character> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Library];
    INumerical_4:Library.LessThan(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThan(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Library];
    INumerical_4:Library.GreaterThanOrEquals(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Boolean [Library];
    INumerical_4:Library.Lesser(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Character [Library];
    INumerical_4:Library.Greater(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Character [Library];
    INumerical_4:Library.CompareTo(a: ConcreteType:Character,b: ConcreteType:Character): ConcreteType:Integer [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Number(x: ConcreteType:Character): ConcreteType:Number [Intrinsic];
    Intrinsics_22:Library.Integer(x: ConcreteType:Character): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.LessThanOrEquals(x: ConcreteType:Character,y: ConcreteType:Character): ConcreteType:Boolean [Intrinsic];
    Intrinsics_22:Library.Equals(x: ConcreteType:Character,y: ConcreteType:Character): ConcreteType:Boolean [Intrinsic];
Reified type Dynamic
Reified type Type
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.New(t: ConcreteType:Type,args: Concept:IArray<Concept:IAny>): ConcreteType:Dynamic [Intrinsic];
Reified type Error
Reified type Tuple2
  Reified functions for group Tuple2_456:ConcreteType
    Tuple2_456:ConcreteType.X0(self: ConcreteType:Tuple2<TypeVariable:T0,TypeVariable:T1>): TypeVariable:T0 [Field];
    Tuple2_456:ConcreteType.X1(self: ConcreteType:Tuple2<TypeVariable:T0,TypeVariable:T1>): TypeVariable:T1 [Field];
Reified type Tuple3
  Reified functions for group Tuple3_458:ConcreteType
    Tuple3_458:ConcreteType.X0(self: ConcreteType:Tuple3<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2>): TypeVariable:T0 [Field];
    Tuple3_458:ConcreteType.X1(self: ConcreteType:Tuple3<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2>): TypeVariable:T1 [Field];
    Tuple3_458:ConcreteType.X2(self: ConcreteType:Tuple3<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2>): TypeVariable:T2 [Field];
Reified type Tuple4
  Reified functions for group Tuple4_460:ConcreteType
    Tuple4_460:ConcreteType.X0(self: ConcreteType:Tuple4<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3>): TypeVariable:T0 [Field];
    Tuple4_460:ConcreteType.X1(self: ConcreteType:Tuple4<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3>): TypeVariable:T1 [Field];
    Tuple4_460:ConcreteType.X2(self: ConcreteType:Tuple4<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3>): TypeVariable:T2 [Field];
    Tuple4_460:ConcreteType.X3(self: ConcreteType:Tuple4<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3>): TypeVariable:T3 [Field];
Reified type Tuple5
  Reified functions for group Tuple5_462:ConcreteType
    Tuple5_462:ConcreteType.X0(self: ConcreteType:Tuple5<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4>): TypeVariable:T0 [Field];
    Tuple5_462:ConcreteType.X1(self: ConcreteType:Tuple5<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4>): TypeVariable:T1 [Field];
    Tuple5_462:ConcreteType.X2(self: ConcreteType:Tuple5<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4>): TypeVariable:T2 [Field];
    Tuple5_462:ConcreteType.X3(self: ConcreteType:Tuple5<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4>): TypeVariable:T3 [Field];
    Tuple5_462:ConcreteType.X4(self: ConcreteType:Tuple5<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4>): TypeVariable:T4 [Field];
Reified type Tuple6
  Reified functions for group Tuple6_464:ConcreteType
    Tuple6_464:ConcreteType.X0(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T0 [Field];
    Tuple6_464:ConcreteType.X1(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T1 [Field];
    Tuple6_464:ConcreteType.X2(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T2 [Field];
    Tuple6_464:ConcreteType.X3(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T3 [Field];
    Tuple6_464:ConcreteType.X4(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T4 [Field];
    Tuple6_464:ConcreteType.X5(self: ConcreteType:Tuple6<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5>): TypeVariable:T5 [Field];
Reified type Tuple7
  Reified functions for group Tuple7_466:ConcreteType
    Tuple7_466:ConcreteType.X0(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T0 [Field];
    Tuple7_466:ConcreteType.X1(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T1 [Field];
    Tuple7_466:ConcreteType.X2(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T2 [Field];
    Tuple7_466:ConcreteType.X3(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T3 [Field];
    Tuple7_466:ConcreteType.X4(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T4 [Field];
    Tuple7_466:ConcreteType.X5(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T5 [Field];
    Tuple7_466:ConcreteType.X6(self: ConcreteType:Tuple7<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6>): TypeVariable:T6 [Field];
Reified type Tuple8
  Reified functions for group Tuple8_468:ConcreteType
    Tuple8_468:ConcreteType.X0(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T0 [Field];
    Tuple8_468:ConcreteType.X1(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T1 [Field];
    Tuple8_468:ConcreteType.X2(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T2 [Field];
    Tuple8_468:ConcreteType.X3(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T3 [Field];
    Tuple8_468:ConcreteType.X4(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T4 [Field];
    Tuple8_468:ConcreteType.X5(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T5 [Field];
    Tuple8_468:ConcreteType.X6(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T6 [Field];
    Tuple8_468:ConcreteType.X7(self: ConcreteType:Tuple8<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7>): TypeVariable:T7 [Field];
Reified type Tuple9
  Reified functions for group Tuple9_470:ConcreteType
    Tuple9_470:ConcreteType.X0(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T0 [Field];
    Tuple9_470:ConcreteType.X1(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T1 [Field];
    Tuple9_470:ConcreteType.X2(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T2 [Field];
    Tuple9_470:ConcreteType.X3(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T3 [Field];
    Tuple9_470:ConcreteType.X4(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T4 [Field];
    Tuple9_470:ConcreteType.X5(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T5 [Field];
    Tuple9_470:ConcreteType.X6(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T6 [Field];
    Tuple9_470:ConcreteType.X7(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T7 [Field];
    Tuple9_470:ConcreteType.X8(self: ConcreteType:Tuple9<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8>): TypeVariable:T8 [Field];
Reified type Tuple10
  Reified functions for group Tuple10_472:ConcreteType
    Tuple10_472:ConcreteType.X0(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T0 [Field];
    Tuple10_472:ConcreteType.X1(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T1 [Field];
    Tuple10_472:ConcreteType.X2(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T2 [Field];
    Tuple10_472:ConcreteType.X3(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T3 [Field];
    Tuple10_472:ConcreteType.X4(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T4 [Field];
    Tuple10_472:ConcreteType.X5(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T5 [Field];
    Tuple10_472:ConcreteType.X6(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T6 [Field];
    Tuple10_472:ConcreteType.X7(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T7 [Field];
    Tuple10_472:ConcreteType.X8(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T8 [Field];
    Tuple10_472:ConcreteType.X9(self: ConcreteType:Tuple10<TypeVariable:T0,TypeVariable:T1,TypeVariable:T2,TypeVariable:T3,TypeVariable:T4,TypeVariable:T5,TypeVariable:T6,TypeVariable:T7,TypeVariable:T8,TypeVariable:T9>): TypeVariable:T9 [Field];
Reified type Function0
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Invoke(f: ConcreteType:Function0<TypeVariable:$TR>): TypeVariable:$TR [Intrinsic];
Reified type Function1
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Invoke(f: ConcreteType:Function1<TypeVariable:$T0,TypeVariable:$TR>,a0: TypeVariable:$T0): TypeVariable:$TR [Intrinsic];
Reified type Function2
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Invoke(f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$TR>,a0: TypeVariable:$T0,a1: TypeVariable:$T1): TypeVariable:$TR [Intrinsic];
Reified type Function3
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Invoke(f: ConcreteType:Function3<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$TR>,a0: TypeVariable:$T0,a1: TypeVariable:$T1,a2: TypeVariable:$T2): TypeVariable:$TR [Intrinsic];
Reified type Function4
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Invoke(f: ConcreteType:Function4<TypeVariable:$T0,TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$TR>,a0: TypeVariable:$T0,a1: TypeVariable:$T1,a2: TypeVariable:$T2,a3: TypeVariable:$T3): TypeVariable:$TR [Intrinsic];
Reified type Function5
Reified type Function6
Reified type Function7
Reified type Function8
Reified type Function9
Reified type Function10
Reified type Array
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Array<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Array<TypeVariable:T>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Array<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Array<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Array<TypeVariable:T>,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Array<TypeVariable:T>,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Array<TypeVariable:T>,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Array<TypeVariable:T>,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Array<TypeVariable:T>,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Array<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Array<TypeVariable:T>,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Array<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Array<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Array<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Array<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Array<TypeVariable:T>,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Array<TypeVariable:T>): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array<TypeVariable:T>): ConcreteType:Array<TypeVariable:T> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array<TypeVariable:T>): ConcreteType:Array<TypeVariable:T> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array<TypeVariable:T>,ys: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array<TypeVariable:T>,ys: ConcreteType:Array<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.Count(xs: ConcreteType:Array<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.At(xs: ConcreteType:Array<TypeVariable:$T>,n: ConcreteType:Integer): TypeVariable:$T [Intrinsic];
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Array<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Array2D
  Reified functions for group IArray2D_30:Concept
    IArray2D_30:Concept.NumRows(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray2D_30:Concept.NumColumns(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray2D_30:Concept.At(xs: ConcreteType:Array2D<TypeVariable:T>,column: ConcreteType:Integer,row: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.Count(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Integer [Library];
    ArrayLibrary_0:Library.At(xs: ConcreteType:Array2D<TypeVariable:T>,i: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Array2D<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Array2D<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Array2D<TypeVariable:T>,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Array2D<TypeVariable:T>,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Array2D<TypeVariable:T>,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Array2D<TypeVariable:T>,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Array2D<TypeVariable:T>,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array2D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array2D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Array2D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Array2D<TypeVariable:T>,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Array2D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Array2D<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Array2D<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Array2D<TypeVariable:T>,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray2D<TypeVariable:$T2> [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.AllQuadFaceIndices(xs: ConcreteType:Array2D<TypeVariable:T>,closedX: ConcreteType:Boolean,closedY: ConcreteType:Boolean): Concept:IArray2D<ConcreteType:Integer4> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Array2D<TypeVariable:T> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array2D<TypeVariable:T>): ConcreteType:Array2D<TypeVariable:T> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array2D<TypeVariable:T>,ys: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array2D<TypeVariable:T>,ys: ConcreteType:Array2D<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.NumRows(xs: ConcreteType:Array2D<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.NumColumns(xs: ConcreteType:Array2D<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.At(xs: ConcreteType:Array2D<TypeVariable:$T>,i: ConcreteType:Integer,j: ConcreteType:Integer): TypeVariable:$T [Intrinsic];
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Array2D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Array3D
  Reified functions for group IArray3D_32:Concept
    IArray3D_32:Concept.NumRows(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray3D_32:Concept.NumColumns(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray3D_32:Concept.NumLayers(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray3D_32:Concept.At(xs: ConcreteType:Array3D<TypeVariable:T>,column: ConcreteType:Integer,row: ConcreteType:Integer,layer: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:T [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.Count(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Integer [Library];
    ArrayLibrary_0:Library.At(xs: ConcreteType:Array3D<TypeVariable:T>,i: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Array3D<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Array3D<TypeVariable:T>): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Array3D<TypeVariable:T>,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Array3D<TypeVariable:T>,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Array3D<TypeVariable:T>,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Array3D<TypeVariable:T>,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Array3D<TypeVariable:T>,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array3D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Array3D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Array3D<TypeVariable:T>,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Array3D<TypeVariable:T>,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Array3D<TypeVariable:T>,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Array3D<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Array3D<TypeVariable:T>,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Array3D<TypeVariable:T>,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Array3D<TypeVariable:T> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array3D<TypeVariable:T>): ConcreteType:Array3D<TypeVariable:T> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array3D<TypeVariable:T>,ys: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Array3D<TypeVariable:T>,ys: ConcreteType:Array3D<TypeVariable:T>): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.NumRows(xs: ConcreteType:Array3D<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.NumColumns(xs: ConcreteType:Array3D<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.NumLayers(xs: ConcreteType:Array3D<TypeVariable:$T>): ConcreteType:Integer [Intrinsic];
    Intrinsics_22:Library.At(xs: ConcreteType:Array3D<TypeVariable:$T>,i: ConcreteType:Integer,j: ConcreteType:Integer,k: ConcreteType:Integer): TypeVariable:$T [Intrinsic];
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Array3D<TypeVariable:T>,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Sphere
  Reified functions for group Sphere_502:ConcreteType
    Sphere_502:ConcreteType.Radius(self: ConcreteType:Sphere): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Sphere): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Sphere): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Sphere,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Sphere,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Sphere): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Sphere): ConcreteType:Boolean [Library];
Reified type Cylinder
  Reified functions for group Cylinder_504:ConcreteType
    Cylinder_504:ConcreteType.Height(self: ConcreteType:Cylinder): ConcreteType:Number [Field];
    Cylinder_504:ConcreteType.Radius(self: ConcreteType:Cylinder): ConcreteType:Number [Field];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Cylinder,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
Reified type Capsule
  Reified functions for group Capsule_506:ConcreteType
    Capsule_506:ConcreteType.Height(self: ConcreteType:Capsule): ConcreteType:Number [Field];
    Capsule_506:ConcreteType.Radius(self: ConcreteType:Capsule): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Capsule): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Capsule): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Capsule,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Capsule,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Capsule): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Capsule): ConcreteType:Boolean [Library];
Reified type Cone
  Reified functions for group Cone_508:ConcreteType
    Cone_508:ConcreteType.Height(self: ConcreteType:Cone): ConcreteType:Number [Field];
    Cone_508:ConcreteType.Radius(self: ConcreteType:Cone): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Cone): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Cone): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Cone,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Cone,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Cone): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Cone): ConcreteType:Boolean [Library];
Reified type ConeSegment
  Reified functions for group ConeSegment_510:ConcreteType
    ConeSegment_510:ConcreteType.Height(self: ConcreteType:ConeSegment): ConcreteType:Number [Field];
    ConeSegment_510:ConcreteType.Radius1(self: ConcreteType:ConeSegment): ConcreteType:Number [Field];
    ConeSegment_510:ConcreteType.Radius2(self: ConcreteType:ConeSegment): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:ConeSegment): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:ConeSegment): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:ConeSegment,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:ConeSegment,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:ConeSegment): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:ConeSegment): ConcreteType:Boolean [Library];
Reified type Box
  Reified functions for group Box_512:ConcreteType
    Box_512:ConcreteType.Extent(self: ConcreteType:Box): ConcreteType:Vector3D [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Box): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Box): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Box,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Box,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Box): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Box): ConcreteType:Boolean [Library];
Reified type Pyramid
  Reified functions for group Pyramid_514:ConcreteType
    Pyramid_514:ConcreteType.Height(self: ConcreteType:Pyramid): ConcreteType:Number [Field];
    Pyramid_514:ConcreteType.BaseLength(self: ConcreteType:Pyramid): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Pyramid): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Pyramid): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Pyramid,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Pyramid,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Pyramid): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Pyramid): ConcreteType:Boolean [Library];
Reified type Torus
  Reified functions for group Torus_516:ConcreteType
    Torus_516:ConcreteType.MajorRadius(self: ConcreteType:Torus): ConcreteType:Number [Field];
    Torus_516:ConcreteType.MinorRadius(self: ConcreteType:Torus): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Torus): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Torus): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Torus,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Torus,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Torus): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Torus): ConcreteType:Boolean [Library];
Reified type NPrism
  Reified functions for group NPrism_518:ConcreteType
    NPrism_518:ConcreteType.Height(self: ConcreteType:NPrism): ConcreteType:Number [Field];
    NPrism_518:ConcreteType.Radius(self: ConcreteType:NPrism): ConcreteType:Number [Field];
    NPrism_518:ConcreteType.NumSides(self: ConcreteType:NPrism): ConcreteType:Integer [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:NPrism): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:NPrism): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:NPrism,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:NPrism,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:NPrism): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:NPrism): ConcreteType:Boolean [Library];
Reified type Tube
  Reified functions for group Tube_520:ConcreteType
    Tube_520:ConcreteType.Height(self: ConcreteType:Tube): ConcreteType:Number [Field];
    Tube_520:ConcreteType.InnerRadius(self: ConcreteType:Tube): ConcreteType:Number [Field];
    Tube_520:ConcreteType.OuterRadius(self: ConcreteType:Tube): ConcreteType:Number [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Tube): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Tube): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Tube,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Tube,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Tube): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Tube): ConcreteType:Boolean [Library];
Reified type NPyramid
  Reified functions for group NPyramid_522:ConcreteType
    NPyramid_522:ConcreteType.Height(self: ConcreteType:NPyramid): ConcreteType:Number [Field];
    NPyramid_522:ConcreteType.Radius(self: ConcreteType:NPyramid): ConcreteType:Number [Field];
    NPyramid_522:ConcreteType.NumSides(self: ConcreteType:NPyramid): ConcreteType:Integer [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:NPyramid): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:NPyramid): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:NPyramid,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:NPyramid,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:NPyramid): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:NPyramid): ConcreteType:Boolean [Library];
Reified type Ellipsoid
  Reified functions for group Ellipsoid_524:ConcreteType
    Ellipsoid_524:ConcreteType.Radii(self: ConcreteType:Ellipsoid): ConcreteType:Vector3D [Field];
  Reified functions for group IProceduralSurface_276:Concept
    IProceduralSurface_276:Concept.ClosedX(x: ConcreteType:Ellipsoid): ConcreteType:Boolean [Concept];
    IProceduralSurface_276:Concept.ClosedY(x: ConcreteType:Ellipsoid): ConcreteType:Boolean [Concept];
  Reified functions for group IProcedural_252:Concept
    IProcedural_252:Concept.Eval(x: ConcreteType:Ellipsoid,t: ConcreteType:Vector2D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDistanceField3D_258:Concept
    IDistanceField3D_258:Concept.Distance(x: ConcreteType:Ellipsoid,p: ConcreteType:Vector3D): ConcreteType:Number [Concept];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.ClosedX(xs: ConcreteType:Ellipsoid): ConcreteType:Boolean [Library];
    IGeometry_18:Library.ClosedY(xs: ConcreteType:Ellipsoid): ConcreteType:Boolean [Library];
Reified type Vector2D
  Reified functions for group Vector2D_528:ConcreteType
    Vector2D_528:ConcreteType.X(self: ConcreteType:Vector2D): ConcreteType:Number [Field];
    Vector2D_528:ConcreteType.Y(self: ConcreteType:Vector2D): ConcreteType:Number [Field];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Vector2D,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Vector2D [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Vector2D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Vector2D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Vector2D,other: ConcreteType:Number): ConcreteType:Vector2D [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Vector2D,other: ConcreteType:Number): ConcreteType:Vector2D [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Vector2D,other: ConcreteType:Number): ConcreteType:Vector2D [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Vector2D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector2D> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Vector2D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Vector2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Vector2D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Vector2D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Vector2D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Vector2D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Vector2D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Vector2D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Vector2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Vector2D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Vector2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Vector2D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Vector2D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector2D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector2D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Vector2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector2D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Vector2D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Vector2D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Vector2D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Vector2D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Vector2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Vector2D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Vector2D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Square(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Half(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Million(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Component(x: ConcreteType:Vector2D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Vector2D): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Vector2D,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector2D [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.One(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Vector2D): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Vector2D): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Vector2D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Vector2D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Vector2D,a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Vector2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Vector2D,a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Min(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Max(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector2D,s: ConcreteType:Number): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector2D,s: ConcreteType:Number): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector2D,s: ConcreteType:Number): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Add(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector2D,y: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Vector2D,v2: ConcreteType:Vector2D,v3: ConcreteType:Vector2D,uv: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,d: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,d: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,d: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D,c: ConcreteType:Vector2D,t: ConcreteType:Number): ConcreteType:Vector2D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Vector3D(v: ConcreteType:Vector2D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.MidPoint(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Line(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Line2D [Library];
    IGeometry_18:Library.Ray(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Ray2D [Library];
    IGeometry_18:Library.RayTo(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Ray2D [Library];
    IGeometry_18:Library.Cross(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Count(v: ConcreteType:Vector2D): ConcreteType:Integer [Library];
    IGeometry_18:Library.At(v: ConcreteType:Vector2D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    IGeometry_18:Library.Length(a: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.LengthSquared(a: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Sum(v: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.SumSquares(v: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.MagnitudeSquared(v: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Magnitude(v: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Dot(v1: ConcreteType:Vector2D,v2: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Average(v: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Normalize(x: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Reflect(v: ConcreteType:Vector2D,normal: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Project(v: ConcreteType:Vector2D,other: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Distance(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.DistanceSquared(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Number [Library];
    IGeometry_18:Library.Angle(a: ConcreteType:Vector2D,b: ConcreteType:Vector2D): ConcreteType:Angle [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Vector2D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.To3D(x: ConcreteType:Vector2D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.UnitX(_: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.UnitY(_: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector2D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector2D,ys: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector2D,ys: ConcreteType:Vector2D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Vector2D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
Reified type Vector3D
  Reified functions for group Vector3D_530:ConcreteType
    Vector3D_530:ConcreteType.X(self: ConcreteType:Vector3D): ConcreteType:Number [Field];
    Vector3D_530:ConcreteType.Y(self: ConcreteType:Vector3D): ConcreteType:Number [Field];
    Vector3D_530:ConcreteType.Z(self: ConcreteType:Vector3D): ConcreteType:Number [Field];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Vector3D,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Vector3D [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Vector3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Vector3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Vector3D,other: ConcreteType:Number): ConcreteType:Vector3D [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Vector3D,other: ConcreteType:Number): ConcreteType:Vector3D [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Vector3D,other: ConcreteType:Number): ConcreteType:Vector3D [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Vector3D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): ConcreteType:Number [Concept];
  Reified functions for group IDeformable3D_228:Concept
    IDeformable3D_228:Concept.Deform(x: ConcreteType:Vector3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Vector3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector3D> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Vector3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Vector3D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Vector3D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Vector3D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Vector3D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Vector3D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Vector3D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Vector3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Vector3D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Vector3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Vector3D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Vector3D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector3D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector3D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Vector3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector3D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Vector3D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Vector3D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Vector3D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Vector3D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Vector3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Vector3D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Vector3D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Square(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Half(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Million(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Component(x: ConcreteType:Vector3D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Vector3D): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Vector3D,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector3D [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.One(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Vector3D): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Vector3D): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Vector3D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Vector3D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Vector3D,a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Vector3D,a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Min(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Max(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Add(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector3D,y: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Vector3D,v2: ConcreteType:Vector3D,v3: ConcreteType:Vector3D,uv: ConcreteType:Vector2D): ConcreteType:Vector3D [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,d: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,d: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,d: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D,t: ConcreteType:Number): ConcreteType:Vector3D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Vector4D(v: ConcreteType:Vector3D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.ToVector4D(v: ConcreteType:Vector3D,w: ConcreteType:Number): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.XZY(v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.YXZ(v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.YZX(v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.ZXY(v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.ZYX(v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.XY(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.YX(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.XZ(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.ZX(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.YZ(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.ZY(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.MidPoint(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Line(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Line3D [Library];
    IGeometry_18:Library.Ray(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.RayTo(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Ray3D [Library];
    IGeometry_18:Library.Project(v: ConcreteType:Vector3D,p: ConcreteType:Plane): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Deform(v: ConcreteType:Vector3D,f: ConcreteType:Function1<ConcreteType:Vector3D,ConcreteType:Vector3D>): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.To2D(v: ConcreteType:Vector3D): ConcreteType:Vector2D [Library];
    IGeometry_18:Library.Cross(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.MixedProduct(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D,c: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Count(v: ConcreteType:Vector3D): ConcreteType:Integer [Library];
    IGeometry_18:Library.At(v: ConcreteType:Vector3D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    IGeometry_18:Library.Length(a: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.LengthSquared(a: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Sum(v: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.SumSquares(v: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.MagnitudeSquared(v: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Magnitude(v: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Dot(v1: ConcreteType:Vector3D,v2: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Average(v: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Normalize(x: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Reflect(v: ConcreteType:Vector3D,normal: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Project(v: ConcreteType:Vector3D,other: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Distance(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.DistanceSquared(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Number [Library];
    IGeometry_18:Library.Angle(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Angle [Library];
    IGeometry_18:Library.IsParallel(a: ConcreteType:Vector3D,b: ConcreteType:Vector3D): ConcreteType:Boolean [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Vector3D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Deform(x: ConcreteType:Vector3D,t: Concept:ITransform3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Translate(x: ConcreteType:Vector3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Rotate(x: ConcreteType:Vector3D,q: ConcreteType:Quaternion): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Vector3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Scale(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.RotateX(x: ConcreteType:Vector3D,a: ConcreteType:Angle): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.RotateY(x: ConcreteType:Vector3D,a: ConcreteType:Angle): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.RotateZ(x: ConcreteType:Vector3D,a: ConcreteType:Angle): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.TranslateX(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.TranslateY(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.TranslateZ(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.ScaleX(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.ScaleY(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.ScaleZ(x: ConcreteType:Vector3D,s: ConcreteType:Number): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.UnitX(_: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.UnitY(_: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.UnitZ(_: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.MinValue(_: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.MaxValue(_: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector3D,ys: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector3D,ys: ConcreteType:Vector3D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Vector3D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix(v: ConcreteType:Vector3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.AxisAngle(v: ConcreteType:Vector3D,a: ConcreteType:Angle): ConcreteType:AxisAngle [Library];
    Transforms_26:Library.Rotation(v: ConcreteType:Vector3D,theta: ConcreteType:Angle): ConcreteType:Quaternion [Library];
    Transforms_26:Library.LookRotation(direction: ConcreteType:Vector3D,up: ConcreteType:Vector3D): ConcreteType:Quaternion [Library];
Reified type Vector4D
  Reified functions for group Vector4D_532:ConcreteType
    Vector4D_532:ConcreteType.X(self: ConcreteType:Vector4D): ConcreteType:Number [Field];
    Vector4D_532:ConcreteType.Y(self: ConcreteType:Vector4D): ConcreteType:Number [Field];
    Vector4D_532:ConcreteType.Z(self: ConcreteType:Vector4D): ConcreteType:Number [Field];
    Vector4D_532:ConcreteType.W(self: ConcreteType:Vector4D): ConcreteType:Number [Field];
  Reified functions for group INumerical_38:Concept
    INumerical_38:Concept.Components(x: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Number> [Concept];
    INumerical_38:Concept.FromComponents(x: ConcreteType:Vector4D,xs: Concept:IArray<ConcreteType:Number>): ConcreteType:Vector4D [Concept];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Vector4D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Vector4D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Boolean [Concept];
  Reified functions for group IScalarArithmetic_58:Concept
    IScalarArithmetic_58:Concept.Modulo(self: ConcreteType:Vector4D,other: ConcreteType:Number): ConcreteType:Vector4D [Concept];
    IScalarArithmetic_58:Concept.Divide(self: ConcreteType:Vector4D,other: ConcreteType:Number): ConcreteType:Vector4D [Concept];
    IScalarArithmetic_58:Concept.Multiply(self: ConcreteType:Vector4D,other: ConcreteType:Number): ConcreteType:Vector4D [Concept];
  Reified functions for group IAdditive_56:Concept
    IAdditive_56:Concept.Add(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
    IAdditive_56:Concept.Subtract(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
    IAdditive_56:Concept.Negative(self: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
  Reified functions for group IMultiplicative_60:Concept
    IMultiplicative_60:Concept.Multiply(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
  Reified functions for group IDivisible_70:Concept
    IDivisible_70:Concept.Divide(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
  Reified functions for group IModulo_72:Concept
    IModulo_72:Concept.Modulo(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Vector4D): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): ConcreteType:Number [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Vector4D> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Vector4D): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Vector4D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Vector4D): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Vector4D,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Vector4D,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Vector4D,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Vector4D,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Vector4D,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Vector4D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Vector4D,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Vector4D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Vector4D,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Vector4D,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector4D,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Vector4D,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector4D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Vector4D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Vector4D,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Vector4D,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Vector4D,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Vector4D): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Vector4D,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Vector4D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Vector4D,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Vector4D,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Pow2(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Pow3(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Pow4(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Pow5(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Square(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Sqr(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Cube(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Half(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Quarter(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Eight(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Sixteenth(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Tenth(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Twice(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Hundred(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Thousand(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Million(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Billion(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.PlusOne(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.MinusOne(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.FromOne(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Component(x: ConcreteType:Vector4D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    INumerical_4:Library.NumComponents(x: ConcreteType:Vector4D): ConcreteType:Integer [Library];
    INumerical_4:Library.MapComponents(x: ConcreteType:Vector4D,f: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector4D [Library];
    INumerical_4:Library.ZipComponents(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D,f: ConcreteType:Function2<ConcreteType:Number,ConcreteType:Number,ConcreteType:Number>): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Zero(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.One(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.MaxComponent(x: ConcreteType:Vector4D): ConcreteType:Number [Library];
    INumerical_4:Library.MinComponent(x: ConcreteType:Vector4D): ConcreteType:Number [Library];
    INumerical_4:Library.MinValue(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.MaxValue(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.AllComponents(x: ConcreteType:Vector4D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.AnyComponent(x: ConcreteType:Vector4D,predicate: ConcreteType:Function1<ConcreteType:Number,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    INumerical_4:Library.Between(x: ConcreteType:Vector4D,a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Boolean [Library];
    INumerical_4:Library.BetweenZeroOne(x: ConcreteType:Vector4D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Clamp(x: ConcreteType:Vector4D,a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.ClampZeroOne(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Clamp01(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Abs(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Min(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Max(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Floor(n: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Fract(n: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Equals(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Boolean [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector4D,s: ConcreteType:Number): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector4D,s: ConcreteType:Number): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector4D,s: ConcreteType:Number): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Add(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Subtract(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Negative(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Multiply(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Divide(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Modulo(x: ConcreteType:Vector4D,y: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Lerp(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    INumerical_4:Library.Barycentric(v1: ConcreteType:Vector4D,v2: ConcreteType:Vector4D,v3: ConcreteType:Vector4D,uv: ConcreteType:Vector2D): ConcreteType:Vector4D [Library];
  Reified functions for group Curves_6:Library
    Curves_6:Library.Parabola(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    Curves_6:Library.CubicBezier(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,d: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    Curves_6:Library.CubicBezierDerivative(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,d: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    Curves_6:Library.CubicBezierSecondDerivative(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,d: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    Curves_6:Library.QuadraticBezier(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    Curves_6:Library.QuadraticBezierDerivative(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
    Curves_6:Library.QuadraticBezierSecondDerivative(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D,c: ConcreteType:Vector4D,t: ConcreteType:Number): ConcreteType:Vector4D [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Count(v: ConcreteType:Vector4D): ConcreteType:Integer [Library];
    IGeometry_18:Library.At(v: ConcreteType:Vector4D,n: ConcreteType:Integer): ConcreteType:Number [Library];
    IGeometry_18:Library.ToVector3D(v: ConcreteType:Vector4D): ConcreteType:Vector3D [Library];
    IGeometry_18:Library.Length(a: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.LengthSquared(a: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Sum(v: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.SumSquares(v: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.MagnitudeSquared(v: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Magnitude(v: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Dot(v1: ConcreteType:Vector4D,v2: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Average(v: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Normalize(x: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Reflect(v: ConcreteType:Vector4D,normal: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Project(v: ConcreteType:Vector4D,other: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Distance(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.DistanceSquared(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Number [Library];
    IGeometry_18:Library.Angle(a: ConcreteType:Vector4D,b: ConcreteType:Vector4D): ConcreteType:Angle [Library];
    IGeometry_18:Library.Bounds(xs: ConcreteType:Vector4D): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.UnitX(_: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.UnitY(_: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.UnitZ(_: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.UnitW(_: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector4D): ConcreteType:Vector4D [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector4D,ys: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Vector4D,ys: ConcreteType:Vector4D): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Vector4D,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Quaternion(v: ConcreteType:Vector4D): ConcreteType:Quaternion [Library];
Reified type Matrix3x3
  Reified functions for group Matrix3x3_534:ConcreteType
    Matrix3x3_534:ConcreteType.Column1(self: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Field];
    Matrix3x3_534:ConcreteType.Column2(self: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Field];
    Matrix3x3_534:ConcreteType.Column3(self: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Matrix3x3): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Matrix3x3,b: ConcreteType:Matrix3x3): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Matrix3x3): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): ConcreteType:Vector3D [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Matrix3x3> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Matrix3x3): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Matrix3x3): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Matrix3x3): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Matrix3x3,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Matrix3x3,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Matrix3x3,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Matrix3x3,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Matrix3x3): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Matrix3x3,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Matrix3x3,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Matrix3x3,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Matrix3x3,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Matrix3x3,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Matrix3x3): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Matrix3x3,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Matrix3x3,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Matrix3x3,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Matrix3x3,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Matrix3x3,b: ConcreteType:Matrix3x3): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Matrix3x3,b: ConcreteType:Matrix3x3): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Matrix3x3): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Identity(_: ConcreteType:Matrix3x3): ConcreteType:Matrix3x3 [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix3x3): ConcreteType:Matrix3x3 [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix3x3): ConcreteType:Matrix3x3 [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Matrix3x3,ys: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Matrix3x3,ys: ConcreteType:Matrix3x3): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Matrix3x3,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix(m: ConcreteType:Matrix3x3): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Row1(m: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Row2(m: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Row3(m: ConcreteType:Matrix3x3): ConcreteType:Vector3D [Library];
    Transforms_26:Library.M11(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M12(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M13(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M21(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M22(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M23(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M31(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M32(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.M33(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
    Transforms_26:Library.Determinant(m: ConcreteType:Matrix3x3): ConcreteType:Number [Library];
Reified type Matrix4x4
  Reified functions for group Matrix4x4_536:ConcreteType
    Matrix4x4_536:ConcreteType.Column1(self: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Field];
    Matrix4x4_536:ConcreteType.Column2(self: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Field];
    Matrix4x4_536:ConcreteType.Column3(self: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Field];
    Matrix4x4_536:ConcreteType.Column4(self: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Matrix4x4): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Matrix4x4,b: ConcreteType:Matrix4x4): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Matrix4x4): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): ConcreteType:Vector4D [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Matrix4x4> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Matrix4x4): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Matrix4x4): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Matrix4x4): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Matrix4x4,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Matrix4x4,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Matrix4x4,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Matrix4x4,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Matrix4x4): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Matrix4x4,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Matrix4x4,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Matrix4x4,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Matrix4x4,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Matrix4x4,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Matrix4x4): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Matrix4x4,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Matrix4x4,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Matrix4x4,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Matrix4x4,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Matrix4x4,b: ConcreteType:Matrix4x4): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Matrix4x4,b: ConcreteType:Matrix4x4): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Matrix4x4): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Identity(_: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Matrix4x4,ys: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Matrix4x4,ys: ConcreteType:Matrix4x4): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Matrix4x4,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.M11(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M12(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M13(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M14(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M21(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M22(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M23(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M24(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M31(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M32(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M33(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M34(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M41(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M42(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M43(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.M44(m: ConcreteType:Matrix4x4): ConcreteType:Number [Library];
    Transforms_26:Library.Row1(m: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Library];
    Transforms_26:Library.Row2(m: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Library];
    Transforms_26:Library.Row3(m: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Library];
    Transforms_26:Library.Row4(m: ConcreteType:Matrix4x4): ConcreteType:Vector4D [Library];
    Transforms_26:Library.GetRow(m: ConcreteType:Matrix4x4,row: ConcreteType:Integer): ConcreteType:Vector4D [Library];
    Transforms_26:Library.Multiply(m: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.CreateFromRows(_: ConcreteType:Matrix4x4,row1: ConcreteType:Vector4D,row2: ConcreteType:Vector4D,row3: ConcreteType:Vector4D,row4: ConcreteType:Vector4D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.CreateFromRows(_: ConcreteType:Matrix4x4,row1: ConcreteType:Vector3D,row2: ConcreteType:Vector3D,row3: ConcreteType:Vector3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.WithTranslation(m: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Translation(m: ConcreteType:Matrix4x4): ConcreteType:Vector3D [Library];
    Transforms_26:Library.CreateTranslation(_: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.CreateScale(_: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(m: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(m: ConcreteType:Matrix4x4,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Transpose(m: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Multiply(m: ConcreteType:Matrix4x4,s: ConcreteType:Number): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Divide(m: ConcreteType:Matrix4x4,s: ConcreteType:Number): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Multiply(a: ConcreteType:Matrix4x4,b: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Matrix(m: ConcreteType:Matrix4x4): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.QuaternionFromRotationMatrix(m: ConcreteType:Matrix4x4): ConcreteType:Quaternion [Library];
Reified type IdentityTransform3D
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:IdentityTransform3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:IdentityTransform3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:IdentityTransform3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:IdentityTransform3D,b: ConcreteType:IdentityTransform3D): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:IdentityTransform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:IdentityTransform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:IdentityTransform3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:IdentityTransform3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:IdentityTransform3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:IdentityTransform3D,b: ConcreteType:IdentityTransform3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:IdentityTransform3D,b: ConcreteType:IdentityTransform3D): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:IdentityTransform3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(t: ConcreteType:IdentityTransform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(t: ConcreteType:IdentityTransform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(t: ConcreteType:IdentityTransform3D): ConcreteType:Matrix4x4 [Library];
Reified type Translation3D
  Reified functions for group Translation3D_540:ConcreteType
    Translation3D_540:ConcreteType.Translation(self: ConcreteType:Translation3D): ConcreteType:Vector3D [Field];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Translation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Translation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Translation3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix(t: ConcreteType:Translation3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(t: ConcreteType:Translation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(t: ConcreteType:Translation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Translation3D): ConcreteType:Matrix4x4 [Library];
Reified type Transform3D
  Reified functions for group Transform3D_542:ConcreteType
    Transform3D_542:ConcreteType.Translation(self: ConcreteType:Transform3D): ConcreteType:Vector3D [Field];
    Transform3D_542:ConcreteType.Rotation(self: ConcreteType:Transform3D): ConcreteType:Quaternion [Field];
    Transform3D_542:ConcreteType.Scale(self: ConcreteType:Transform3D): ConcreteType:Vector3D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Transform3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Transform3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Transform3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Transform3D,b: ConcreteType:Transform3D): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Transform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Transform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Transform3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Transform3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Transform3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Transform3D,b: ConcreteType:Transform3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Transform3D,b: ConcreteType:Transform3D): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Transform3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(t: ConcreteType:Transform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(t: ConcreteType:Transform3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(t: ConcreteType:Transform3D): ConcreteType:Matrix4x4 [Library];
Reified type Pose3D
  Reified functions for group Pose3D_544:ConcreteType
    Pose3D_544:ConcreteType.Position(self: ConcreteType:Pose3D): ConcreteType:Vector3D [Field];
    Pose3D_544:ConcreteType.Rotation(self: ConcreteType:Pose3D): ConcreteType:Rotation3D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Pose3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Pose3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Pose3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Pose3D,b: ConcreteType:Pose3D): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Pose3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Pose3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Pose3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Pose3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Pose3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Pose3D,b: ConcreteType:Pose3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Pose3D,b: ConcreteType:Pose3D): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Pose3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(p: ConcreteType:Pose3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(p: ConcreteType:Pose3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(p: ConcreteType:Pose3D): ConcreteType:Matrix4x4 [Library];
Reified type Frame3D
  Reified functions for group Frame3D_546:ConcreteType
    Frame3D_546:ConcreteType.Forward(self: ConcreteType:Frame3D): ConcreteType:Vector3D [Field];
    Frame3D_546:ConcreteType.Up(self: ConcreteType:Frame3D): ConcreteType:Vector3D [Field];
    Frame3D_546:ConcreteType.Position(self: ConcreteType:Frame3D): ConcreteType:Vector3D [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Frame3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Frame3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Frame3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Frame3D,b: ConcreteType:Frame3D): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Frame3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Frame3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Frame3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Frame3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Frame3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Frame3D,b: ConcreteType:Frame3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Frame3D,b: ConcreteType:Frame3D): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Frame3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Pose3D(f: ConcreteType:Frame3D): ConcreteType:Pose3D [Library];
    Transforms_26:Library.Transform(f: ConcreteType:Frame3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(f: ConcreteType:Frame3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(f: ConcreteType:Frame3D): ConcreteType:Matrix4x4 [Library];
Reified type Quaternion
  Reified functions for group Quaternion_548:ConcreteType
    Quaternion_548:ConcreteType.X(self: ConcreteType:Quaternion): ConcreteType:Number [Field];
    Quaternion_548:ConcreteType.Y(self: ConcreteType:Quaternion): ConcreteType:Number [Field];
    Quaternion_548:ConcreteType.Z(self: ConcreteType:Quaternion): ConcreteType:Number [Field];
    Quaternion_548:ConcreteType.W(self: ConcreteType:Quaternion): ConcreteType:Number [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Quaternion): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Quaternion): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Quaternion,b: ConcreteType:Quaternion): ConcreteType:Boolean [Concept];
  Reified functions for group IArray_28:Concept
    IArray_28:Concept.Count(xs: ConcreteType:Quaternion): ConcreteType:Integer [Concept];
    IArray_28:Concept.At(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): ConcreteType:Number [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Quaternion,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Quaternion,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Quaternion): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Quaternion> [Library];
    ArrayLibrary_0:Library.Indices(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Integer> [Library];
    ArrayLibrary_0:Library.IsEmpty(xs: ConcreteType:Quaternion): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.First(xs: ConcreteType:Quaternion): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Last(xs: ConcreteType:Quaternion): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Middle(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Slice(xs: ConcreteType:Quaternion,from: ConcreteType:Integer,to: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Slices(xs: ConcreteType:Quaternion,size: ConcreteType:Integer): Concept:IArray<Concept:IArray<TypeVariable:$T>> [Library];
    ArrayLibrary_0:Library.NthSlice(xs: ConcreteType:Quaternion,n: ConcreteType:Integer,size: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Subarray(xs: ConcreteType:Quaternion,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Skip(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Take(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.TakeLast(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Drop(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Trim(xs: ConcreteType:Quaternion,first: ConcreteType:Integer,last: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Rest(xs: ConcreteType:Quaternion): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Reduce(xs: ConcreteType:Quaternion,acc: TypeVariable:$U,f: ConcreteType:Function2<TypeVariable:$U,TypeVariable:$T,TypeVariable:$U>): TypeVariable:$U [Library];
    ArrayLibrary_0:Library.All(xs: ConcreteType:Quaternion,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Any(xs: ConcreteType:Quaternion,f: ConcreteType:Function1<TypeVariable:$T,ConcreteType:Boolean>): ConcreteType:Boolean [Library];
    ArrayLibrary_0:Library.Map(xs: ConcreteType:Quaternion,f: ConcreteType:Function1<TypeVariable:$T1,TypeVariable:$T2>): Concept:IArray<TypeVariable:$T2> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quaternion,ys: Concept:IArray<TypeVariable:$T2>,f: ConcreteType:Function2<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3>): Concept:IArray<TypeVariable:$T3> [Library];
    ArrayLibrary_0:Library.Zip(xs: ConcreteType:Quaternion,ys: Concept:IArray<TypeVariable:$T2>,zs: Concept:IArray<TypeVariable:$T3>,f: ConcreteType:Function3<TypeVariable:$T1,TypeVariable:$T2,TypeVariable:$T3,TypeVariable:$T4>): Concept:IArray<TypeVariable:$T4> [Library];
    ArrayLibrary_0:Library.ModuloAt(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): TypeVariable:$T [Library];
    ArrayLibrary_0:Library.Shift(xs: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quaternion,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNextAndBeginning(xs: ConcreteType:Quaternion,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.WithNext(xs: ConcreteType:Quaternion,f: ConcreteType:Function2<TypeVariable:$T0,TypeVariable:$T0,TypeVariable:$T1>,connect: ConcreteType:Boolean): Concept:IArray<TypeVariable:$T1> [Library];
    ArrayLibrary_0:Library.EveryNth(self: ConcreteType:Quaternion,n: ConcreteType:Integer): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.CartesianProduct(columns: ConcreteType:Quaternion,rows: Concept:IArray<TypeVariable:$TRow>,func: ConcreteType:Function2<TypeVariable:$TColumn,TypeVariable:$TRow,TypeVariable:$TResult>): Concept:IArray2D<TypeVariable:$TResult> [Library];
    ArrayLibrary_0:Library.Reverse(self: ConcreteType:Quaternion): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Concat(xs: ConcreteType:Quaternion,ys: Concept:IArray<TypeVariable:$T>): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Prepend(self: ConcreteType:Quaternion,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.Append(self: ConcreteType:Quaternion,value: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
    ArrayLibrary_0:Library.PrependAndAppend(self: ConcreteType:Quaternion,before: TypeVariable:$T,after: TypeVariable:$T): Concept:IArray<TypeVariable:$T> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Quaternion,b: ConcreteType:Quaternion): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Quaternion,b: ConcreteType:Quaternion): ConcreteType:Boolean [Library];
  Reified functions for group IGeometry_18:Library
    IGeometry_18:Library.Bounds(xs: ConcreteType:Quaternion): ConcreteType:Bounds3D [Library];
    IGeometry_18:Library.Identity(_: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Vector2D> [Library];
    IGeometry_18:Library.Points(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Vector3D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.Lines(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Line3D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Triangle2D> [Library];
    IGeometry_18:Library.Triangles(xs: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Triangle3D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quaternion,ys: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Line2D> [Library];
    IGeometry_18:Library.ToLines(xs: ConcreteType:Quaternion,ys: ConcreteType:Quaternion): Concept:IArray<ConcreteType:Line3D> [Library];
  Reified functions for group Intrinsics_22:Library
    Intrinsics_22:Library.FlatMap(xs: ConcreteType:Quaternion,f: ConcreteType:Function1<TypeVariable:$T1,Concept:IArray<TypeVariable:$T2>>): Concept:IArray<TypeVariable:$T2> [Intrinsic];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Quaternion): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Vector4D(q: ConcreteType:Quaternion): ConcreteType:Vector4D [Library];
    Transforms_26:Library.Magnitude(q: ConcreteType:Quaternion): ConcreteType:Number [Library];
    Transforms_26:Library.MagnitudeSquared(q: ConcreteType:Quaternion): ConcreteType:Number [Library];
    Transforms_26:Library.Transform(q: ConcreteType:Quaternion,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(q: ConcreteType:Quaternion,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Concatenate(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Conjugate(q: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Inverse(q: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Normalize(q: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.XYZ(q: ConcreteType:Quaternion): ConcreteType:Vector3D [Library];
    Transforms_26:Library.ReverseConcatenate(q2: ConcreteType:Quaternion,q1: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Multiply(q: ConcreteType:Quaternion,scalar: ConcreteType:Number): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Divide(q: ConcreteType:Quaternion,scalar: ConcreteType:Number): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Add(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Negate(q: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Subtract(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Dot(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion): ConcreteType:Number [Library];
    Transforms_26:Library.Slerp(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion,t: ConcreteType:Number): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Multiply(q1: ConcreteType:Quaternion,q2: ConcreteType:Quaternion): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Matrix(q: ConcreteType:Quaternion): ConcreteType:Matrix4x4 [Library];
Reified type AxisAngle
  Reified functions for group AxisAngle_550:ConcreteType
    AxisAngle_550:ConcreteType.Axis(self: ConcreteType:AxisAngle): ConcreteType:Vector3D [Field];
    AxisAngle_550:ConcreteType.Angle(self: ConcreteType:AxisAngle): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:AxisAngle): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:AxisAngle): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:AxisAngle): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:AxisAngle,b: ConcreteType:AxisAngle): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:AxisAngle,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:AxisAngle,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:AxisAngle): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:AxisAngle,n: ConcreteType:Integer): Concept:IArray<ConcreteType:AxisAngle> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:AxisAngle,b: ConcreteType:AxisAngle): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:AxisAngle,b: ConcreteType:AxisAngle): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:AxisAngle): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(aa: ConcreteType:AxisAngle,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(aa: ConcreteType:AxisAngle,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Quaternion(aa: ConcreteType:AxisAngle): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Matrix(aa: ConcreteType:AxisAngle): ConcreteType:Matrix4x4 [Library];
Reified type EulerAngles
  Reified functions for group EulerAngles_552:ConcreteType
    EulerAngles_552:ConcreteType.Yaw(self: ConcreteType:EulerAngles): ConcreteType:Angle [Field];
    EulerAngles_552:ConcreteType.Pitch(self: ConcreteType:EulerAngles): ConcreteType:Angle [Field];
    EulerAngles_552:ConcreteType.Roll(self: ConcreteType:EulerAngles): ConcreteType:Angle [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:EulerAngles): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:EulerAngles): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:EulerAngles): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:EulerAngles,b: ConcreteType:EulerAngles): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:EulerAngles,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:EulerAngles,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:EulerAngles): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:EulerAngles,n: ConcreteType:Integer): Concept:IArray<ConcreteType:EulerAngles> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:EulerAngles,b: ConcreteType:EulerAngles): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:EulerAngles,b: ConcreteType:EulerAngles): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:EulerAngles): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Quaternion(e: ConcreteType:EulerAngles): ConcreteType:Quaternion [Library];
    Transforms_26:Library.Transform(e: ConcreteType:EulerAngles,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(e: ConcreteType:EulerAngles,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(e: ConcreteType:EulerAngles): ConcreteType:Matrix4x4 [Library];
Reified type Rotation3D
  Reified functions for group Rotation3D_554:ConcreteType
    Rotation3D_554:ConcreteType.Quaternion(self: ConcreteType:Rotation3D): ConcreteType:Quaternion [Field];
  Reified functions for group IAny_34:Concept
    IAny_34:Concept.FieldNames(x: ConcreteType:Rotation3D): Concept:IArray<ConcreteType:String> [Concept];
    IAny_34:Concept.FieldValues(x: ConcreteType:Rotation3D): Concept:IArray<ConcreteType:Dynamic> [Concept];
    IAny_34:Concept.TypeName(x: ConcreteType:Rotation3D): ConcreteType:String [Concept];
  Reified functions for group IEquatable_54:Concept
    IEquatable_54:Concept.Equals(a: ConcreteType:Rotation3D,b: ConcreteType:Rotation3D): ConcreteType:Boolean [Concept];
  Reified functions for group ITransform3D_526:Concept
    ITransform3D_526:Concept.Transform(x: ConcreteType:Rotation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.TransformNormal(x: ConcreteType:Rotation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Concept];
    ITransform3D_526:Concept.Matrix(x: ConcreteType:Rotation3D): ConcreteType:Matrix4x4 [Concept];
  Reified functions for group ArrayLibrary_0:Library
    ArrayLibrary_0:Library.Repeat(x: ConcreteType:Rotation3D,n: ConcreteType:Integer): Concept:IArray<ConcreteType:Rotation3D> [Library];
  Reified functions for group INumerical_4:Library
    INumerical_4:Library.Equals(a: ConcreteType:Rotation3D,b: ConcreteType:Rotation3D): ConcreteType:Boolean [Library];
    INumerical_4:Library.NotEquals(a: ConcreteType:Rotation3D,b: ConcreteType:Rotation3D): ConcreteType:Boolean [Library];
  Reified functions for group Transforms_26:Library
    Transforms_26:Library.Matrix4x4(t: ConcreteType:Rotation3D): ConcreteType:Matrix4x4 [Library];
    Transforms_26:Library.Transform(r: ConcreteType:Rotation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.TransformNormal(r: ConcreteType:Rotation3D,v: ConcreteType:Vector3D): ConcreteType:Vector3D [Library];
    Transforms_26:Library.Matrix(r: ConcreteType:Rotation3D): ConcreteType:Matrix4x4 [Library];
