library IGeometry
{
    //==
	// 2D Lines
	
	Points(x: Line2D): IArray<Vector2D> => x;
	Length(x: Line2D): Number => (x.B - x.A).Length;
	Direction(x: Line2D): Vector2D => (x.B - x.A);
	Ray2D(x: Line2D): Ray2D => (x.A, x.Direction);
    Reverse(x: Line2D): Line2D => (x.B, x.A);

	//== 
	// 3D Lines
	 
	Points(x: Line3D): IArray<Vector3D> => x;
	Length(x: Line3D): Number => (x.B - x.A).Length;
	Direction(x: Line3D): Vector3D => (x.B - x.A);
	Ray3D(x: Line3D): Ray3D => (x.A, x.Direction);
    Reverse(x: Line3D): Line2D => (x.B, x.A);

	//==
	// 3D Rays

	Angle(a: Ray3D, b: Ray3D): Angle => a.Direction.Angle(b.Direction);

	//==
	// Rect2D functions 

	Width(x: Rect2D): Number => x.Size.X;
	Height(x: Rect2D): Number => x.Size.Y;
	HalfWidth(x: Rect2D): Number => x.Width.Half;
	HalfHeight(x: Rect2D): Number => x.Height.Half;
	Top(x: Rect2D): Number => x.Center.Y + HalfHeight;
	Bottom(x: Rect2D): Number => x.Top + x.Height;
	Left(x: Rect2D): Number => x.Center.X - HalfWidth;
	Right(x: Rect2D): Number => x.Left + x.Width;
	TopLeft(x: Rect2D): Vector2D => (x.Left, x.Top);
	TopRight(x: Rect2D): Vector2D => (x.Right, x.Top);
	BottomRight(x: Rect2D): Vector2D => (x.Right, x.Bottom);
	BottomLeft(x: Rect2D): Vector2D => (x.Left, x.Bottom);
	Points(x: Rect2D): IArray<Vector2D> => [x.TopLeft, x.TopRight, x.BottomRight, x.BottomLeft];

	//==
	// Ellipse functions 

	Eval(x: Ellipse, t: Number): Vector2D => t.CircleFunction * x.Size + x.Center;
	
	//==
	// Triangle 2D functions 

	Points(x: Triangle2D): IArray<Vector2D> => [x.A, x.B, x.C];
	Area(t: Triangle2D): Number => (t.A.X * (t.C.Y - t.B.Y) + t.B.X * (t.A.Y - t.C.Y) + t.C.X * (t.B.Y - t.A.Y)).Half;
	Flip(t: Triangle2D): Triangle2D => (t.C, t.B, t.A);
    Center(t: Triangle2D): Vector2D => (t.A + t.B + t.C) / 3.0;
	Barycentric(t: Triangle2D, uv: Vector2D): Vector2D => t.A.Barycentric(t.B, t.C, uv);

	//==
    // Triangle3D functions

    Flip(t: Triangle3D): Triangle3D => (t.C, t.B, t.A);        
    Normal(t: Triangle3D): Vector3D => (t.B - t.A).Cross(t.C - t.A).Normalize;
    Center(t: Triangle3D): Vector3D => (t.A + t.B + t.C) / 3.0;
    Plane(t: Triangle3D): Plane => (t.Normal, t.Normal.Dot(t.A));
	Barycentric(t: Triangle3D, uv: Vector2D): Vector3D => t.A.Barycentric(t.B, t.C, uv);    
    LineA(t: Triangle3D): Line3D => (t.A, t.B);        
    LineB(t: Triangle3D): Line3D => (t.B, t.C);        
    LineC(t: Triangle3D): Line3D => (t.C, t.A);        
    
    //==
    // Quad3D functions

    Flip(q: Quad3D): Quad3D => (q.D, q.C, q.B, q.A);        
    Center(q: Quad3D): Vector3D => (q.A + q.B + q.C + q.D) / 4.0;
    LineA(q: Quad3D): Line3D => (q.A, q.B);        
    LineB(q: Quad3D): Line3D => (q.B, q.C);        
    LineC(q: Quad3D): Line3D => (q.C, q.D);        
    LineD(q: Quad3D): Line3D => (q.D, q.A);            
    TriangleA(q: Quad3D): Triangle3D => (q.A, q.B, q.C);        
    TriangleB(q: Quad3D): Triangle3D => (q.C, q.D, q.A);        

    //==
    // Vector functions

    Vector4D(v: Vector3D): Vector4D => v.Vector4D(0);
    Vector4D(v: Vector3D, w: Number): Vector4D => (v.X, v.Y, v.Z, w);
    XZY(v: Vector3D): Vector3D => (v.X, v.Z, v.Y);
    YXZ(v: Vector3D): Vector3D => (v.Y, v.X, v.Z);
    YZX(v: Vector3D): Vector3D => (v.Y, v.Z, v.X);
    ZXY(v: Vector3D): Vector3D => (v.Z, v.X, v.Y);
    ZYX(v: Vector3D): Vector3D => (v.Z, v.Y, v.X);
    XY(v: Vector3D): Vector2D => (v.X, v.Y);
    YX(v: Vector3D): Vector2D => (v.Y, v.X);
    MidPoint(a: Vector3D, b: Vector3D): Vector3D => (a + b) / 2.0;
    Line(a: Vector3D, b: Vector3D): Line3D => (a, b);
    Ray(a: Vector3D, b: Vector3D): Ray3D => (a, b);
    RayTo(a: Vector3D, b: Vector3D): Ray3D => (a, b - a);
    Project(v: Vector3D, p: Plane): Vector3D => v - p.Normal * p.Normal.Dot(v);
      
    To2D(v: Vector3D): Vector2D => (v.X, v.Y);
    Length(a: IVector): Number => a.Magnitude;
    LengthSquared(a: IVector): Number => a.MagnitudeSquared;
    Sum(v: IVector): Number  => v.Reduce(0.0, (a, b) => a + b);
    Count(c: Complex): Integer => 2;   
    Count(v: Vector2D): Integer => 2;
    Count(v: Vector3D): Integer => 3;
    Count(v: Vector4D): Integer => 4;   
    At(c: Complex, n: Integer): Number => n == 0 ? c.IReal : c.Imaginary;
    At(v: Vector2D, n: Integer): Number => n == 0 ? v.X : v.Y;
    At(v: Vector3D, n: Integer): Number => n == 0 ? v.X : n == 1 ? v.Y : v.Z;
    At(v: Vector4D, n: Integer): Number => n == 0 ? v.X : n == 1 ? v.Y : n == 2 ? v.Z : v.W;
    SumSquares(v: IVector): Number => v.Square.Sum;   
    MagnitudeSquared(v: IVector): Number => v.SumSquares;    
    Magnitude(v: IVector): Number => v.MagnitudeSquared.SquareRoot;    
    Dot(v1: IVector, v2: IVector): Number => (v1 * v2).Sum;
    Average(v: IVector): Number => v.Sum / v.Count;        
    Normalize(x: IVector): IVector => x.MagnitudeSquared > 0 ? x / x.Magnitude : x.Zero;
    Cross(a: Vector2D, b: Vector2D): Number => a.X * b.Y - a.Y * b.X;
    Cross(a: Vector3D, b: Vector3D): Vector3D => (a.Y * b.Z - a.Z * b.Y, a.Z * b.X - a.X * b.Z, a.X * b.Y - a.Y * b.X);
    MixedProduct(a: Vector3D, b: Vector3D, c: Vector3D): Number => a.Cross(b).Dot(c);
    Reflect(v: IVector, normal: IVector): IVector => v - normal * v.Dot(normal) * 2.0;
    Project(v: IVector, other: IVector): IVector => other * v.Dot(other);
    Distance(a: IVector, b: IVector): Number => (b - a).Magnitude;
    DistanceSquared(a: IVector, b: IVector): Number => (b - a).Magnitude;
    Angle(a: IVector, b: IVector): Angle => (a.Dot(b) / (a.Magnitude * b.Magnitude)).Acos;     
    
    // TODO: the epsilon
    IsParallel(a: Vector3D, b: Vector3D): Boolean => a.Dot(b).Abs > (1 - 1e-6);
	
	//==
	// Closed functions 

    Closed(x: IClosedShape): Boolean => true;
	Closed(x: IOpenShape): Boolean => false;
	
	//== 
	// Misc functions 

    CirclePoints(n: Integer): IArray<Vector2D> => n.Fractions.Map((x) => x.Turns.CircleFunction);
	Points(x: RegularPolygon): IArray<Vector2D> => x.NumPoints.CirclePoints;

    // TODO: 
	//Eval(x: IPolyLine3D, t: Number): Vector3D => throw "Not Implemented yet";
    
    Eval(x: Line2D, t: Number): Vector2D => x.A.Lerp(x.B, t);
    Eval(x: Line3D, t: Number): Vector3D => x.A.Lerp(x.B, t);

    Lines(xs: IArray<Vector3D>, ys: IArray<Vector3D>): IArray<Line3D> 
        => xs.Zip(ys, (a, b) => new Line3D(a, b));
        
    Lines(xs: IArray<Vector2D>, ys: IArray<Vector2D>): IArray<Line2D> 
        => xs.Zip(ys, (a, b) => new Line2D(a, b));
               
    // # Indexed geometry related functions
    // The term, vertices is used often in this context to mean points. 
    // When rendering a vertex is more complex, containing additional attributes like UV, normal, and color. 

    NumFaces(g: IIndexedGeometry3D): Integer => g.NumPrimitives;
    NumPrimitives(g: IIndexedGeometry): Integer => g.Indices.Count / g.PrimitiveSize;
    FaceIndices(g: IIndexedGeometry, f: Integer): IArray<Integer> => g.Indices.Subarray(f * g.PrimitiveSize, PrimitiveSize);
    FaceVertices(g: IIndexedGeometry, f: Integer): IArray<Vector3D> => g.FaceIndices(f).Map(i => g.Vertices[i]);
    AllFaceIndices(g: IIndexedGeometry): IArray<IArray<Integer>> => g.Indices.Slices(g.PrimitiveSize);
    AllFaceVertices(g: IIndexedGeometry): IArray<IArray<Vector3D>> => g.Indices.Map(i => g.Vertices[i]).Slices(g.PrimitiveSize);    
    Vertices(g: IPointGeometry3D): IArray<Vector3D> => g;
    NumVertices(g: IIndexedGeometry3D): Integer => g.Points.Count;

    // # Primitives

    Primitives(g: ILineMesh3D): IArray<Line3D> => g.AllFaceVertices.Map(p => new Line3D(p));
    Primitives(g: ITriangleMesh3D): IArray<Triangle3D> => g.AllFaceVertices.Map(p => new Triangle3D(p));
    Primitives(g: IQuadMesh3D): IArray<Quad3D> => g.AllFaceVertices.Map(p => new Quad3D(p));

    PrimitiveSize(g: ILinePrimitives): Integer => 2;
    PrimitiveSize(g: ITrianglePrimitives): Integer => 3;
    PrimitiveSize(g: IQuadPrimitives): Integer => 4;
        
    // # Implicit cast functions for meshes 

    LineMesh3D(g: ITriangleMesh3D): LineMesh3D => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[0]]));
    LineMesh3D(g: IQuadMesh3D): LineMesh3D => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[3], a[0]]));
    TriangleMesh3D(g: IQuadMesh3D): TriangleMesh3D => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[2], a[3], a[0]]));

    PointArray3D(g: ILineMesh3D): PointArray3D => (g.Points);
    PointArray3D(g: ITriangleMesh3D): PointArray3D => (g.Points);
    PointArray3D(g: IQuadMesh3D): PointArray3D => (g.Points);
    LineArray3D(g: ILineMesh3D): LineArray3D => (g.Primitives);
    LineArray3D(g: ITriangleMesh3D): LineArray3D => (g.Primitives.FlatMap(t => t.Lines));
    LineArray3D(g: IQuadMesh3D): LineArray3D => (g.Primitives.FlatMap(t => t.Lines));
    TriangleArray3D(g: ITriangleMesh3D): TriangleArray3D => (g.Primitives);
    QuadArray3D(g: IQuadMesh3D): QuadArray3D => (g.Primitives);

    Triangles(q: Quad2D): IArray<Triangle2D> => [(q.A, q.B, q.C), (q.C, q.D, q.A)];
    Triangles(q: Quad3D): IArray<Triangle3D> => [(q.A, q.B, q.C), (q.C, q.D, q.A)];

    LineArray2D(t: Triangle2D): LineArray2D => new LineArray2D(t.Lines);
    LineArray2D(q: Quad2D): LineArray2D => q.Lines;
    LineArray3D(t: Triangle3D): LineArray3D => t.Lines;
    LineArray3D(q: Quad3D): LineArray3D => q.Lines;

    TriangleArray2D(q: Quad2D): TriangleArray2D => q.Triangles;
    TriangleArray3D(q: Quad3D): TriangleArray3D => q.Triangles;

    //==
    // Faces are synonymous with primitives for 3D triangle meshes and 3D quad meshes.

    Faces(g: ITriangleMesh3D): IArray<Triangle3D> => g.Primitives; 
    Faces(g: IQuadMesh3D): IArray<Quad3D> => g.Primitives; 

    //==
    // 2D to 3D

    To3D(x: Line2D): Line3D => (x.A.To3D, x.B.To3D);
    To3D(x: Triangle2D): Triangle3D => (x.A.To3D, x.B.To3D, x.C.To3D);
    To3D(x: Quad2D): Quad3D => (x.A.To3D, x.B.To3D, x.C.To3D, x.D.To3D);
    To3D(x: Bounds2D): Bounds3D => (x.Min.To3D, x.Max.To3D);
    To3D(x: Ray2D): Ray3D => (x.Origin.To3D, x.Direction.To3D);
    To3D(x: PolyLine2D): PolyLine3D => (x.Points.Map(p => p.To3D), x.Closed);

    Line3D(x: Line2D): Line3D => x.To3D;
    Triangle3D(x: Triangle2D): Triangle3D => x.To3D;
    Quad3D(x: Quad2D): Quad3D => x.To3D;
    Bounds3D(x: Bounds2D): Bounds3D => x.To3D;
    Ray3D(x: Ray2D): Ray3D => x.To3D;
    PolyLine3D(x: PolyLine2D): PolyLine3D => x.To3D;

    //==
    // Deformable functions

    Transform(x: IDeformable3D, m: Matrix4x4): IDeformable3D => x.Deform(v => m * v);
    Transform(x: IDeformable3D, t: ITransform3D): IDeformable3D => x.Deform(v => t.Transform(v));
    Transform(x: IDeformable3D, r: Rotation3D): IDeformable3D => x.Deform(v => r.Transform(v));

    Translate(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Deform(p => p + v);
    Rotate(x: IDeformable3D, r: Rotation3D): IDeformable3D => x.Transform(r);
    Scale(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Deform(p => p * v);
    Scale(x: IDeformable3D, s: Number): IDeformable3D => x.Deform(p => p * s);

    // TODO:
    // Rotate around an axis.
    // Rotate X, Y, Z
    // Scale X, Y, Z
    // Translate X, Y, Z 
    // Anything we can do with poses? 

    Add(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Translate(v);
    Subtract(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Translate(-v);
    Multiply(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Scale(v);
    Multiply(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Scale(v);
    Divide(x: IDeformable3D, v: Vector3D): IDeformable3D => x.Scale(1 / v);
    Divide(x: IDeformable3D, s: Number): IDeformable3D => x.Scale(1 / s);
}