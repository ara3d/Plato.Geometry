type ArrayImplementation<T>
    implements Array<T>
{
    Count: Integer;
    Function: Function1<Integer, T>;
}

library ArrayLibrary
{
    Count(xs: Array2D<$T>): Integer 
        => xs.RowCount * xs.ColumnCount;
    
    At(xs: Array2D<$T>, i: Integer): $T 
        => xs.At(i % xs.ColumnCount, i / xs.ColumnCount);

    Count(xs: Array3D<$T>): Integer 
        => xs.RowCount * xs.ColumnCount * xs.LayerCount;
    
    At(xs: Array3D<$T>, i: Integer): $T 
        => xs.At(i % xs.ColumnCount, i / xs.ColumnCount, i / xs.LayerCount);

    At(xs: ArrayImplementation<$T>, n: Integer): $T 
        => xs.Function.Invoke(n);
    
    IsEmpty(xs: Array): Boolean
        => xs.Count == 0;
    
    First(xs: Array<$T>): $T 
        => xs[0];    
    
    Last(xs: Array<$T>): $T
        => xs[xs.Count - 1];

    Middle(xs: Array<$T>, n: Integer): $T
		=> xs[xs.Count / 2];

    MapRange(x: Integer, f: Function1<Integer, $T>): Array<$T>
        => x.Range.Map(f);

    /*
    PairwiseMap(xs: Array<$T1>, f: Function2<$T1, $T1, $T2>): Array<$T2> 
		=> (xs.Count - 1).MapRange(i => f(xs.At(i), xs.At(i + 1)));

    Map(xs: ArrayImplementation<$T1>, f: Function1<$T1, $T2>): ArrayImplementation<$T2> 
        => ArrayImplementation(xs.Count, (i) => f.Invoke(xs.At(i)));

    Reverse(xs: Array<$T>): Array<$T>
        => ArrayImplementation(xs.Count, (i) => xs.At(xs.Count - 1 - i));

    Zip(xs: Array, ys: Array, f: Function2<): Array 
        => (xs.Count, (i) => f(At(i), ys.At(i)));  

    Zip(xs: Array, ys: Array, zs: Array, f: Function3): Array 
        => (xs.Count, (i) => f(At(i), ys.At(i), zs.At(i)));
    
    Skip(xs: Array, n: Integer): Array
        => (xs.Count - n, (i) => At(i - n));
    
    Take(xs: Array, n: Integer): Array
        => (n, (i) => At(i));   
    
    Aggregate(xs: Array, init: Any, f: Function2): Any 
        => xs.IsEmpty ? init : f(init, xs.Rest);

    Rest(xs: Array): Array 
        => xs.Skip(1);
    
    Slice(xs: Array, from: Integer, count: Integer): Array 
        => xs.Skip(from).Take(count);
    
    Join(xs: Array, sep: String): String 
        => xs.IsEmpty ? "" 
            : xs.First.ToString 
            + xs.Rest.Aggregate("", (acc, cur) => $"{acc}{sep}{cur}");
    
    All(xs: Array, f: Function1): Boolean 
        => xs.IsEmpty ? true : f(xs.First) && f(xs.Rest);

    All(xs: Array): Boolean 
        => xs.All((b) => b);
    */
} 