
// Arrays provide a count and support the indexing operator [] 
concept Array<T>
{
    Count(xs: Self): Integer;
    At(xs: Self, n: Integer): T;
}

// Extends the Array concept with rows and columns. 
concept Array2D<T>
    inherits Array<T>
{ 
    RowCount(xs: Self): Integer;
    ColumnCount(xs: Self): Integer;
    At(xs: Self, column: Integer, row: Integer): T;
}

// Extends the Array concept with rows, columns, and layers. 
concept Array3D<T>
    inherits Array<T>
{ 
    RowCount(xs: Self): Integer;
    ColumnCount(xs: Self): Integer;
    LayerCount(xs: Self): Integer;
    At(xs: Self, column: Integer, row: Integer, layer: Integer): T;
}

library ArrayLibrary
{
    // Returns n numbers, from 0 to 1, including 0, but not 1. 
    Numbers(n: Integer): Array<Number>
        => n.Map((i) => i.ToNumber / n.ToNumber);

    Range(n: Integer): Array<Integer>
        => n.Map((i) => i);

    Count(xs: Array2D<$T>): Integer 
        => xs.RowCount * xs.ColumnCount;

    Count(xs: Array3D<$T>): Integer 
        => xs.RowCount * xs.ColumnCount * xs.LayerCount;
    
    At(xs: Array2D<$T>, i: Integer): $T 
        => xs.At(i % xs.ColumnCount, i / xs.ColumnCount);
    
    At(xs: Array3D<$T>, i: Integer): $T 
        => xs.At(i % xs.ColumnCount, i / xs.ColumnCount, i / xs.LayerCount);    
        
    IsEmpty(xs: Array<$T>): Boolean
        => xs.Count == 0;
    
    First(xs: Array<$T>): $T 
        => xs[0];    
    
    Last(xs: Array<$T>): $T
        => xs[xs.Count - 1];

    Middle(xs: Array<$T>, n: Integer): $T
		=> xs[xs.Count / 2];

    Slice(xs: Array<$T>, from: Integer, to: Integer): Array<$T>
       => xs.Subarray(from, to - from);

    Subarray(xs: Array<$T>, from: Integer, count: Integer): Array<$T>
        => count.Map((i) => xs.At(i + from));

    Skip(xs: Array<$T>, n: Integer): Array<$T>
		=> xs.Subarray(n, xs.Count - n);

    Take(xs: Array<$T>, n: Integer): Array<$T>
        => xs.Subarray(0, n);

    Drop(xs: Array<$T>, n: Integer): Array<$T>
		=> xs.Take(xs.Count - n);

    SkipDrop(xs: Array<$T>, n1: Integer, n2: Integer): Array<$T>
        => xs.Skip(n1).Drop(n2);

    Rest(xs: Array<$T>): Array<$T>
		=> xs.Skip(1);

    Reduce(xs: Array<$T>, acc: $U, f: Function2<$T, $U, $U>): $U
    {
        var r = acc;
        for (var i=0; i < xs.Count; i = i + 1)
			r = f(xs.At(i), r);
        return r;
    }

    All(xs: Array<$T>, f: Function1<$T, Boolean>): Boolean
    {
        for (var i=0; i < xs.Count; i = i + 1)
			if (!f(xs.At(i)))
				return false;
		return true;
	}

    Any(xs: Array<$T>, f: Function1<$T, Boolean>): Boolean
    {
        for (var i=0; i < xs.Count; i = i + 1)
			if (f(xs.At(i)))
				return true;
		return false;
	}

    Map(xs: Array<$T1>, f: Function1<$T1, $T2>): Array<$T2> 
        => xs.Count.Map((i) => f(xs.At(i)));

    PairwiseMap(xs: Array<$T1>, f: Function2<$T1, $T1, $T2>): Array<$T2> 
		=> (xs.Count - 1).Map(i => f(xs[i], xs[i + 1]));

    PairwiseMapModulo(xs: Array<$T1>, f: Function2<$T1, $T1, $T2>): Array<$T2> 
		=> xs.Count.Map(i => f(xs[i], xs[(i + 1) % xs.Count]));

    Zip(xs: Array<$T1>, ys: Array<$T2>, f: Function2<$T1, $T2, $T3>): Array<$T3> 
        => xs.Count.Lesser(ys.Count).Map((i) => f(xs[i], ys[i]));  

    Zip(xs: Array<$T1>, ys: Array<$T2>, zs: Array<$T3>, f: Function3<$T1, $T2, $T3, $T4>): Array<$T4> 
        => xs.Count.Lesser(ys.Count).Lesser(zs.Count).Map((i) => f(xs[i], ys[i], zs[i]));  
} 