
//==
//# Mesh related concepts

// Any geometry that consists has an index buffer 
concept IIndexedGeometry3D
	inherits IPoints3D
{
    // The number of indices per element (2 for lines, 3 for triangles, 4 for quads, etc.))
    PrimitiveSize(x: Self): Integer;

    // An index buffer used to index the number of points 
	Indices(x: Self): IArray<Integer>;
}

concept ILineMesh
	inherits IIndexedGeometry3D
{ }

concept ITriangleMesh
    inherits IIndexedGeometry3D
{ }

concept IQuadMesh
	inherits IIndexedGeometry3D
{ }

concept IPrimitives3D<TPrim>
    where TPrim: IArray<Vector3D>
    inherits IIndexedGeometry3D
{ 
    Primitives(xs: Self): IArray<TPrim>;
}

concept ILines 
    inherits IPrimitives3D<Line3D>
{ }

concept ITriangles
    inherits IPrimitives3D<Triangle3D>
{ }

concept IQuads
    inherits IPrimitives3D<Quad3D>
{ }

//==
//# Specific indexed geometry types

type LineMesh
    implements ILineMesh
{ 
    Points: IArray<Vector3D>;
    Indices: IArray<Integer>;
}

type TriangleMesh
    implements ITriangleMesh
{ 
    Points: IArray<Vector3D>;
    Indices: IArray<Integer>;
}

type QuadMesh
    implements IQuadMesh
{   
    Points: IArray<Vector3D>;
    Indices: IArray<Integer>;
}

type PolyLine2D
    implements IPolyLine2D
{
    Points: IArray<Vector2D>;
    Closed: Boolean;
}

type PolyLine3D
    implements IPolyLine3D
{
    Points: IArray<Vector3D>;
    Closed: Boolean;
}

type PointArray2D
    implements IPointArray2D
{
	Points: IArray<Vector2D>;
}

type PointArray3D
	implements IPointArray3D
{
	Points: IArray<Vector3D>;
}

type Lines
    implements ILines
{ 
    Primitives: IArray<Line3D>;
}

type Triangles
    implements ITriangles
{ 
    Primitives: IArray<Triangle3D>;
}

type Quads
    implements IQuads
{ 
    Primitives: IArray<Quad3D>;
}

type QuadGrid
	implements IQuadGrid
{
	PointGrid: IArray2D<Vector3D>;
	ClosedX: Boolean;
    ClosedY: Boolean;
}


library Meshes
{
    // # Indexed geometry related functions

    NumFaces(g: IIndexedGeometry3D): Integer => g.NumPrimitives;
    NumPrimitives(g: IIndexedGeometry3D): Integer => g.Indices.Count / g.PrimitiveSize;
    FaceIndices(g: IIndexedGeometry3D, f: Integer): IArray<Integer> => g.Indices.Subarray(f * g.PrimitiveSize, PrimitiveSize);
    FaceVertices(g: IIndexedGeometry3D, f: Integer): IArray<Vector3D> => g.FaceIndices(f).Map(i => g.Vertices[i]);
    AllFaceIndices(g: IIndexedGeometry3D): IArray<IArray<Integer>> => g.Indices.Slices(g.PrimitiveSize);
    AllFaceVertices(g: IIndexedGeometry3D): IArray<IArray<Vector3D>> => g.Indices.Map(i => g.Vertices[i]).Slices(g.PrimitiveSize);
    Vertices(g: IPoints3D): IArray<Vector3D> => g.Points;
    NumVertices(g: IIndexedGeometry3D): Integer => g.Points.Count;

    Primitives(g: ILineMesh): IArray<Line3D> => g.AllFaceVertices.Map(p => new Line3D(p));
    Primitives(g: ITriangleMesh): IArray<Triangle3D> => g.AllFaceVertices.Map(p => new Triangle3D(p));
    Primitives(g: IQuadMesh): IArray<Quad3D> => g.AllFaceVertices.Map(p => new Quad3D(p));

    // # Primitives

    PrimitiveSize(g: ILines): Integer => 2;
    PrimitiveSize(g: ITriangles): Integer => 3;
    PrimitiveSize(g: IQuads): Integer => 4;
    NumPrimitives(g: IPrimitives3D<$T>): Integer => g.Primitives.Count / g.PrimitiveSize;    
    Indices(g: IPrimitives3D<$T>): IArray<Integer> => g.NumPrimitives.Range;    
    Points(g: IPrimitives3D<$T>): IArray<Vector3D> => g.Primitives.FlatMap(p => p);
    
    // # Implicit cast functions

    LineMesh(g: ITriangleMesh): LineMesh => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[0]]));
    LineMesh(g: IQuadMesh): LineMesh => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[3], a[0]]));
    TriangleMesh(g: IQuadMesh): TriangleMesh => (g.Vertices, g.AllFaceIndices.FlatMap(a => [a[0], a[1], a[2], a[2], a[3], a[0]]));

    Lines(g: ILineMesh): Lines => new Lines(g.Primitives);
    Triangles(g: ITriangleMesh): Triangles => new Triangles(g.Primitives);
    Quads(g: IQuadMesh): Quads => new Quads(g.Primitives);

    LineMesh(g: IPrimitives3D<Line3D>): LineMesh => (g.Points, g.Indices);
    TriangleMesh(g: IPrimitives3D<Triangle3D>): TriangleMesh => (g.Points, g.Indices);
    QuadMesh(g: IPrimitives3D<Quad3D>): QuadMesh => (g.Points, g.Indices);

    // # Concept implementation functions

    PrimitiveSize(g: ILineMesh): Integer => 2;
    PrimitiveSize(g: ITriangleMesh): Integer => 3;
    PrimitiveSize(g: IQuadMesh): Integer => 4;
     
    Faces(g: ITriangleMesh): IArray<Triangle3D> => g.Primitives; 
    Faces(g: IQuadMesh): IArray<Quad3D> => g.Primitives; 
}
