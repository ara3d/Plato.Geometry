// https://en.wikipedia.org/wiki/Top_type
// This is the Top Type in Plato. All types provide this. 
concept Any
{ 
    FieldNames(x: Self): Array<String>;     
    FieldValues(x: Self): Array<Dynamic>;
    TypeName(x: Self): String;
}

// A value is a read-only type which has the implicit rule that only Values are members
concept Value 
    inherits Any, Equatable
{ 
}

// A numerical type represents things like reals, integers, vectors, complex numbers, and measures.
// It is a generalization of real numbers to multiple dimensions, and with or without units of measure.
// The NumComponents function returns the dimensionality of the numerical type. 
// Individual components are returned via the Component type. 
concept Numerical 
    inherits Value, ScalarArithmetic, Betweenable
{
    Zero(x: Self): Self;
    One(x: Self): Self;
    MinValue(x: Self): Self;
    MaxValue(x: Self): Self;
    NumComponents(x: Self): Integer;
    Component(x: Self, d: Integer): Number;
}   

// Represents a continuous one dimensional value.
// https://en.wikipedia.org/wiki/Real_number
// The "Value" or a Real is the number itself, and is equal to the Magnitude 
concept Real
    inherits Numerical, Comparable, Arithmetic
{
}

// A measure is a numeric value with an intrinisic unit of measure. 
// It resembles a numerical type except you cannot multiply or divide two measures without 
// getting a new type. It does however support ScalarArithmetic 
concept Measure
    inherits Numerical, Comparable, AdditiveArithmeticSelf
{
}

// Vectors are specialization of the Numerical type.
// Unlike reals and measures they cannot be compared in any meaningful way 
// They are also "array-like" in that they have a fixed number of components.
concept Vector
    inherits Numerical, Arithmetic, Array<Number>
{ 
}

// Arrays are immutable types which can be indexed. 
// The "At" function maps to the indexing operator in C#. 
concept Array<T>
{
    Count(xs: Self): Integer;
    At(xs: Self, n: Integer): T;
}

// Extends the Array concept with rows and columns. 
concept Array2D<T>
    inherits Array<T>
{ 
    RowCount(xs: Self): Integer;
    ColumnCount(xs: Self): Integer;
    At(xs: Self, column: Integer, row: Integer): T;
}

// Extends the Array concept with rows, columns, and layers. 
concept Array3D<T>
    inherits Array<T>
{ 
    RowCount(xs: Self): Integer;
    ColumnCount(xs: Self): Integer;
    LayerCount(xs: Self): Integer;
    At(xs: Self, column: Integer, row: Integer, layer: Integer): T;
}

// A coordinate is a point in some space (e.g., a cartesian grid). 
// This also includes a time line, so a DateTime is considered a Coordinate. 
// Notice that coordinates do not provide arithmetic operators.  
// We could have defined a Point2D and a Point3D types as kinds of coordinates,  
// however, doing anything interesting with them involved converting them 
// to vectors. This just added a lot of complexity without much benefit. 
concept Coordinate
    inherits Value, Betweenable
{ }

// Used for integer and cardinal types. Somewhat counter intuitively, they are not considered Numerical types.
// This is because they do not support scalar arithmetic. 
concept WholeNumber 
    inherits Value, Comparable, Arithmetic, Betweenable
{
    Value(x: Self): Integer;
}

// The compare function return a negative integer if x < y, a positive integer if x > y, or zero otherwise. 
concept Comparable
{
    Compare(x: Self, y: Self): Integer;
}

// Supported for when two values are equal 
concept Equatable
{
    Equals(a: Self, b: Self): Boolean;
    NotEquals(a: Self, b: Self): Boolean;
}

// A type that can be negated.
concept AdditiveInverse
{
    Negative(self: Self): Self;
}

// A type that has a reciprocal (e.g., 1/self).
concept MultiplicativeInverse
{
    Reciprocal(self: Self): Self;
}

// To specify that another type can be added to, or subtracted from this one.
concept AdditiveArithmetic<T>
{
    Add(self: Self, other: T): Self;    
    Add(other: T, self: Self): Self;        
    Subtract(self: Self, other: T): Self;
    Subtract(self: Self, other: Self): T;
}

// The formal term for this is an Abelian group over addition
// https://en.wikipedia.org/wiki/Abelian_group
concept AdditiveArithmeticSelf
    inherits AdditiveInverse
{
    Add(a: Self, b: Self): Self;    
    Subtract(a: Self, b: Self): Self;    
}

// A type which an be multiplied, divided, or have the modulo computed with regards to another type. 
concept MultiplicativeArithmetic<T>
{
    Multiply(self: Self, other: T): Self;
    
    // TODO: I think this was triggering an error in the generated C# code. 
    // I Think what I do is I drop the first argument, even though it is an argument which should stay.
    // Especially for static functions. 
    // However, I have a nice work-around. Define on "T"
    //Multiply(other: T, self: Self): Self;
    
    Divide(self: Self, other: T): Self;    
    Modulo(self: Self, other: T): Self;
}

// Types implementing this concept can be multiplied or divided by a scalar value
concept ScalarArithmetic
    inherits MultiplicativeArithmetic<Number>
{ 
}

// Basic arithmetic operators 
concept Arithmetic 
    inherits AdditiveInverse, MultiplicativeInverse
{ 
    Add(a: Self, b: Self): Self;    
    Subtract(a: Self, b: Self): Self;
    Multiply(a: Self, b: Self): Self;
    Divide(a: Self, b: Self): Self;    
    Modulo(a: Self, b: Self): Self;
}

// Basic boolean operations, which are also similar to set operations.  
concept BooleanOperations
{
    And(a: Self, b: Self): Self;
    Or(a: Self, b: Self): Self;    
    Not(a: Self): Self;
}

// Represents a range of values. 
// TODO: if T supports arithmetic, then the Size is implied and can be removed  
concept Interval<T>    
    where T: Numerical, T: Arithmetic
    inherits Equatable, Value
{
    Min(x: Self): T;
    Max(x: Self): T;    
    Size(x: Self): T;
}
    
// A type that can be clamped, and supports the concept of being between two values.
// For vectors, being between two values is component-wise comparison 
concept Betweenable
{
    Between(x: Self, a: Self, b: Self): Boolean;
    Clamp(x: Self, a: Self, b: Self): Self;
}
