library Numerical
{
    //==
    // Constants

    Pi(): Number 
        => 3.1415926535897;
    
    TwoPi(): Number 
        => Pi.Twice;
    
    HalfPi(): Number 
        => Pi.Half;

    Epsilon(): Number 
        => 1E-15;
    
    FeetPerMeter(): Number 
        => 3.280839895;

    FeetPerMile(): Number 
        => 5280;
    
    MetersPerLightyear(): Number 
        => 9.46073047258e+15;
    
    MetersPerAU(): Number 
        => 149597870691.0;
    
    DaltonPerKilogram(): Number 
        => 1.66053e-27;
    
    PoundPerKilogram(): Number 
        => 0.45359237;
    
    PoundPerTon(): Number 
        => 2000;
    
    KilogramPerSolarMass(): Number 
        => 1.9889200011446E+30;
    
    JulianYearSeconds(): Number 
        => 31557600;
    
    GregorianYearDays(): Number 
        => 365.2425;

    RadiansPerDegree(): Number 
		=> Pi / 180.0;

    DegreesPerRadian(): Number
        => 180.0 / Pi;

    //==
    // Some helpful conversion functions

    OunceToGram(x: Number): Number 
        => x * 28.349523125;
    
    TroyOunceToGram(x: Number): Number 
        => x * 31.1034768;
    
    GrainToMilligram(x: Number): Number 
        => x * 64.79891;    
    
    Mole(x: Number): Number 
        => x * 6.02214076e+23;

    //==
    // Very common numbers 
    
    Hundred(x: Number): Number 
        => x * 100;  
    
    Thousand(x: Number): Number 
        => x * 1000;
    
    Million(x: Number): Number 
        => x.Thousand.Thousand;
    
    Billion(x: Number): Number 
        => x.Thousand.Million;

    //==
    // Number operations 
        
    Inverse(x: Number): Number
        => 1.0 / x;

    Reciprocal(x: Number): Number
        => x.Inverse;

    SquareRoot(x: Number): Number 
        => x.Pow(0.5);

    Sqrt(x: Number): Number
        => x.SquareRoot;

    SmoothStep(x: Number): Number
        => x.Square * (3.0 - x.Twice);    

    MultiplyEpsilon(x: Number, y: Number): Number
        => x.Abs.Greater(y.Abs) * Epsilon;

    // https://stackoverflow.com/a/2411661
    AlmostEqual(x: Number, y: Number): Boolean
        => (x-y).Abs <= x.MultiplyEpsilon(y);

    AlmostZero(x: Number): Boolean
        => x.Abs < Epsilon;

    AlmostZeroOrOne(x: Number): Boolean
        => AlmostEqual(x, 0) || AlmostEqual(x, 1);
   
    //==
    // Arithmetic operations 

    Pow2(x: Arithmetic): Arithmetic 
        => x * x;

    Pow3(x: Arithmetic): Arithmetic 
        => x.Pow2 * x;

    Pow4(x: Arithmetic): Arithmetic 
        => x.Pow3 * x;

    Pow5(x: Arithmetic): Arithmetic 
        => x.Pow4 * x;

    Square(x: Arithmetic): Arithmetic 
        => x.Pow2;

    Cube(x: Arithmetic): Arithmetic 
        => x.Pow3;

    //==
    // Numerical Operations 

    PlusOne(x: Numerical): Numerical 
        => x + x.One;

    MinusOne(x: Numerical): Numerical
        => x - x.One;
    
    FromOne(x: Numerical): Numerical 
        => x.One - x;

    //==
    // WholeNumber Operations 


    //==
    // Integer operations

    // TODO: can these be promoted to a concept? 

    FloatDivision(x: Integer, y: Integer): Number
		=> x.ToNumber / y.ToNumber;

	Fractions(x: Integer): Array<Number>
		=> x.Range.Map((i) => i.FloatDivision(x));

    //==
    // Real Operations 
   
    Magnitude(x: Real): Number
        => x.Value;

    ClampOne(x: Real): Real
        => x.Clamp(x.Zero, x.One);

    GtZ(x : Real): Boolean
        => x > x.Zero;

    LtZ(x : Real): Boolean
        => x < x.Zero;

    GtEqZ(x : Real): Boolean
        => x >= x.Zero;

    LtEqZ(x : Real): Boolean
        => x <= x.Zero;

    IsPositive(x: Real): Boolean
        => x.GtEqZ;

    IsNegative(x: Real): Boolean
        => x.LtZ;

    Sign(x: Real): Integer
        => x.LtZ ? -1 : x.GtZ ? 1 : 0;

    Abs(x: Real): Real 
        => x.LtZ ? -x: x;
    
    //==
    // ScalarArithmetic operations 

    Half(x: ScalarArithmetic): ScalarArithmetic
        => x / 2.0;
        
    Quarter(x: ScalarArithmetic): ScalarArithmetic
        => x / 4.0;
    
    Tenth(x: ScalarArithmetic): ScalarArithmetic 
        => x / 10.0;
    
    Twice(x: ScalarArithmetic): ScalarArithmetic 
        => x * 2.0;
           
    Lerp(a: ScalarArithmetic, b: ScalarArithmetic, t: Number): ScalarArithmetic
        => a * t.FromOne + b * t;
          
    Between(self: Number, min: Number, max: Number): Boolean
        => self >= min && self <= max;

    Barycentric(v1: ScalarArithmetic, v2: ScalarArithmetic, v3: ScalarArithmetic, uv: Vector2D): ScalarArithmetic 
        => v1 + (v2 - v1) * uv.X + (v3 - v1) * uv.Y;   

    //==
    // Matrix operations

    M11(m: Matrix4x4): Number => m.Column1.X;
    M12(m: Matrix4x4): Number => m.Column2.X;
    M13(m: Matrix4x4): Number => m.Column3.X;
    M14(m: Matrix4x4): Number => m.Column4.X;
    M21(m: Matrix4x4): Number => m.Column1.Y;
    M22(m: Matrix4x4): Number => m.Column2.Y;
    M23(m: Matrix4x4): Number => m.Column3.Y;
    M24(m: Matrix4x4): Number => m.Column4.Y;
    M31(m: Matrix4x4): Number => m.Column1.Z;
    M32(m: Matrix4x4): Number => m.Column2.Z;
    M33(m: Matrix4x4): Number => m.Column3.Z;
    M34(m: Matrix4x4): Number => m.Column4.Z;
    M41(m: Matrix4x4): Number => m.Column1.W;
    M42(m: Matrix4x4): Number => m.Column2.W;
    M43(m: Matrix4x4): Number => m.Column3.W;
    M44(m: Matrix4x4): Number => m.Column4.W;

    Multiply(m: Matrix4x4, v: Vector3D): Vector3D
        =>  (v.X * m.M11 + v.Y * m.M21 + v.Z * m.M31 + m.M41,
            v.X * m.M12 + v.Y * m.M22 + v.Z * m.M32 + m.M42,
            v.X * m.M13 + v.Y * m.M23 + v.Z * m.M33 + m.M43);                  

    //==
	// Angle conversion functions 

	Turns(x: Number): Angle
		=> (x * TwoPi).Radians;

	Degrees(x: Number): Angle
		=> (x / 360.0).Turns;

	Gradians(x: Number): Angle
		=> (x / 400.0).Turns;

	Radians(x: Number): Angle
		=> x;

	Turns(x: Angle): Number
		=> x.Radians / TwoPi;

	Degrees(x: Angle): Number
		=> x.Turns * 360.0;

	Gradians(x: Angle): Number
		=> x.Turns * 400.0;

    //==
    // Numerical functions

    Component(x: Numerical, n: Integer): Number
        => x.Components[n];

    NumComponents(x: Numerical): Integer
        => x.Components.Count;

    MapComponents(x: Numerical, f: Function1<Number, Number>): Numerical
        => x.FromComponents(x.Components.Map(f));

    Zero(x: Numerical): Numerical
        => x.MapComponents((i) => 0.0);

    One(x: Numerical): Numerical
        => x.MapComponents((i) => 1.0);

    MinValue(x: Numerical): Numerical
        => x.MapComponents((x) => x.MinNumber);

    MaxValue(x: Numerical): Numerical
        => x.MapComponents((x) => x.MaxNumber);

    AllComponents(x: Numerical, predicate: Function1<Number, Boolean>): Boolean
		=> x.Components.All(predicate);

    AnyComponent(x: Numerical, predicate: Function1<Number, Boolean>): Boolean
		=> x.Components.Any(predicate);
}