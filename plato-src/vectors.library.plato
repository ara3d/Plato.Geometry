
library IVector
{  
    Vector3D(v: Vector2D): Vector3D
    	=> (v.X, v.Y, 0);

    Vector4D(v: Vector3D): Vector4D
		=> (v.X, v.Y, v.Z, 0);

    To2D(v: Vector3D): Vector2D
		=> (v.X, v.Y);

    Length(a: IVector): Number
    	=> a.Magnitude;

    LengthSquared(a: IVector): Number
    	=> a.MagnitudeSquared;

    Sum(v: IVector): Number 
        => v.Reduce(0.0, (a, b) => a + b);

    Count(c: Complex): Integer
        => 2;
   
    Count(v: Vector2D): Integer
        => 2;

    Count(v: Vector3D): Integer
        => 3;
    
    Count(v: Vector4D): Integer
        => 4;
   
    At(c: Complex, n: Integer): Number
        => n == 0 ? c.IReal : c.Imaginary;

    At(v: Vector2D, n: Integer): Number
        => n == 0 ? v.X : v.Y;

    At(v: Vector3D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : v.Z;

    At(v: Vector4D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : n == 2 ? v.Z : v.W;

    SumSquares(v: IVector): Number
        => v.Square.Sum; 
    
    MagnitudeSquared(v: IVector): Number
        => v.SumSquares;
    
    Magnitude(v: IVector): Number
        => v.MagnitudeSquared.SquareRoot;
    
    Dot(v1: IVector, v2: IVector): Number
        => (v1 * v2).Sum;

    Average(v: IVector): Number
        => v.Sum / v.Count;
        
    Normalize(x: IVector): IVector
        => x.MagnitudeSquared > 0 ? x / x.Magnitude : x.Zero;

    Cross(a: Vector2D, b: Vector2D): Number
		=> a.X * b.Y - a.Y * b.X;

    Cross(a: Vector3D, b: Vector3D): Vector3D
        => (a.Y * b.Z - a.Z * b.Y,
            a.Z * b.X - a.X * b.Z,
            a.X * b.Y - a.Y * b.X);

    MixedProduct(a: Vector3D, b: Vector3D, c: Vector3D): Number
		=> a.Cross(b).Dot(c);

    // Returns the reflection of a vector off a surface that has the specified normal.
    Reflect(v: IVector, normal: IVector): IVector
        => v - normal * v.Dot(normal) * 2.0;

    // Returns the projection of a vector onto another vector.
    Project(v: IVector, other: IVector): IVector
		=> other * v.Dot(other);

    Distance(a: IVector, b: IVector): Number
        => (b - a).Magnitude;

    DistanceSquared(a: IVector, b: IVector): Number
        => (b - a).Magnitude;

    Angle(a: IVector, b: IVector): Angle
        => (a.Dot(b) / (a.Magnitude * b.Magnitude)).Acos;     
}