
library Vector
{  
    Vector3D(v: Vector2D): Vector3D
    	=> (v.X, v.Y, 0);

    Vector4D(v: Vector3D): Vector4D
		=> (v.X, v.Y, v.Z, 0);

    To2D(v: Vector3D): Vector2D
		=> (v.X, v.Y);

    Length(a: Vector): Number
    	=> a.Magnitude;

    LengthSquared(a: Vector): Number
    	=> a.MagnitudeSquared;

    Sum(v: Vector): Number 
        => v.Reduce(0.0, (a, b) => a + b);

    Count(c: Complex): Integer
        => 2;
   
    Count(v: Vector2D): Integer
        => 2;

    Count(v: Vector3D): Integer
        => 3;
    
    Count(v: Vector4D): Integer
        => 4;
   
    At(c: Complex, n: Integer): Number
        => n == 0 ? c.Real : c.Imaginary;

    At(v: Vector2D, n: Integer): Number
        => n == 0 ? v.X : v.Y;

    At(v: Vector3D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : v.Z;

    At(v: Vector4D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : n == 2 ? v.Z : v.W;

    SumSquares(v: Vector): Number
        => v.Square.Sum; 
    
    MagnitudeSquared(v: Vector): Number
        => v.SumSquares;
    
    Magnitude(v: Vector): Number
        => v.MagnitudeSquared.SquareRoot;
    
    Dot(v1: Vector, v2: Vector): Number
        => (v1 * v2).Sum;

    Average(v: Vector): Number
        => v.Sum / v.Count;
        
    Normalize(x: Vector): Vector
        => x.MagnitudeSquared > 0 ? x / x.Magnitude : x.Zero;

    Cross(a: Vector2D, b: Vector2D): Number
		=> a.X * b.Y - a.Y * b.X;

    Cross(a: Vector3D, b: Vector3D): Vector3D
        => (a.Y * b.Z - a.Z * b.Y,
            a.Z * b.X - a.X * b.Z,
            a.X * b.Y - a.Y * b.X);

    MixedProduct(a: Vector3D, b: Vector3D, c: Vector3D): Number
		=> a.Cross(b).Dot(c);

    // Returns the reflection of a vector off a surface that has the specified normal.
    Reflect(v: Vector, normal: Vector): Vector
        => v - normal * v.Dot(normal) * 2.0;

    // Returns the projection of a vector onto another vector.
    Project(v: Vector, other: Vector): Vector
		=> other * v.Dot(other);

    Distance(a: Vector, b: Vector): Number
        => (b - a).Magnitude;

    DistanceSquared(a: Vector, b: Vector): Number
        => (b - a).Magnitude;

    Angle(a: Vector, b: Vector): Angle
        => (a.Dot(b) / (a.Magnitude * b.Magnitude)).Acos;     
}