// Autogenerated file: DO NOT EDIT
// Created on 2025-01-17 3:12:39 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Number: IReal<Number>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Number Create() => new Number();

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Number other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Number other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Number a, Number b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Number a, Number b) => !a.Equals(b);

        // Explicit implementation of interfaces by forwarding properties to fields

        // Numerical predefined functions
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(); }
        [MethodImpl(AggressiveInlining)] public Number FromComponents(IArray<Number> numbers) => new Number();

        // Implemented concept functions and type functions
        public Number OunceToGram { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)28.349523125)); } 
        public Number TroyOunceToGram { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)31.1034768)); } 
        public Number GrainToMilligram { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)64.79891)); } 
        public Number Mole { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)6.02214076E+23)); } 
        // Ambiguous: could not choose a best function implementation for Min(Number, Number):Number:Number.
        [MethodImpl(AggressiveInlining)]  public Number Min(Number y) => this.LessThanOrEquals(y) ? this : y;
        // Ambiguous: could not choose a best function implementation for Max(Number, Number):Number:Number.
        [MethodImpl(AggressiveInlining)]  public Number Max(Number y) => this.GreaterThanOrEquals(y) ? this : y;
        public Number Inverse { [MethodImpl(AggressiveInlining)] get  => ((Number)1).Divide(this); } 
        // Ambiguous: could not choose a best function implementation for Reciprocal(Number):Number:Number.
        public Number Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.Inverse; } 
        // Ambiguous: could not choose a best function implementation for SquareRoot(Number):Number:Number.
        public Number SquareRoot { [MethodImpl(AggressiveInlining)] get  => this.Pow(((Number)0.5)); } 
        public Number Sqrt { [MethodImpl(AggressiveInlining)] get  => this.SquareRoot; } 
        [MethodImpl(AggressiveInlining)]  public Number InversePow(Number n) => this.Pow(n.Reciprocal);
        // Ambiguous: could not choose a best function implementation for Exp(Number):Number:Number.
        public Number Exp { [MethodImpl(AggressiveInlining)] get  => Constants.E.Pow(this); } 
        public Number SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Square.Multiply(((Number)3).Subtract(this.Twice)); } 
        [MethodImpl(AggressiveInlining)]  public Number MultiplyEpsilon(Number y) => this.Abs.Greater(y.Abs).Multiply(Constants.Epsilon);
        [MethodImpl(AggressiveInlining)]  public Boolean AlmostEqual(Number y) => this.Subtract(y).Abs.LessThanOrEquals(this.MultiplyEpsilon(y));
        public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.Abs.LessThan(Constants.Epsilon); } 
        public Boolean AlmostZeroOrOne { [MethodImpl(AggressiveInlining)] get  => this.AlmostEqual(((Integer)0)).Or(this.AlmostEqual(((Integer)1))); } 
        public Number Fract { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.Floor); } 
        public Angle Turns { [MethodImpl(AggressiveInlining)] get  => this.Multiply(Constants.TwoPi).Radians; } 
        public Angle Degrees { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)360)).Turns; } 
        public Angle Gradians { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)400)).Turns; } 
        public Angle Radians { [MethodImpl(AggressiveInlining)] get  => this; } 
        public Number Sin { [MethodImpl(AggressiveInlining)] get  => this.Turns.Sin; } 
        public Number Cos { [MethodImpl(AggressiveInlining)] get  => this.Turns.Cos; } 
        public Number Tan { [MethodImpl(AggressiveInlining)] get  => this.Turns.Tan; } 
        public Number ToNumber { [MethodImpl(AggressiveInlining)] get  => this; } 
        [MethodImpl(AggressiveInlining)]  public Number Linear(Number m, Number b) => m.Multiply(this).Add(b);
        [MethodImpl(AggressiveInlining)]  public Number Quadratic(Number a, Number b, Number c) => a.Multiply(this.Sqr).Add(b.Multiply(this).Add(c));
        [MethodImpl(AggressiveInlining)]  public Number Cubic(Number a, Number b, Number c, Number d) => a.Multiply(this.Cube).Add(b.Multiply(this.Sqr).Add(c.Multiply(this).Add(d)));
        [MethodImpl(AggressiveInlining)]  public Number SineWave(Number amplitude, Number frequency, Number phase) => amplitude.Multiply(frequency.Multiply(this.Turns.Sin).Add(phase));
        [MethodImpl(AggressiveInlining)]  public Number StaircaseFloor(Integer steps) => this.Multiply(steps).Floor.Divide(steps);
        [MethodImpl(AggressiveInlining)]  public Number StaircaseCeiling(Integer steps) => this.Multiply(steps).Ceiling.Divide(steps);
        [MethodImpl(AggressiveInlining)]  public Number StaircaseRound(Integer steps) => this.Multiply(steps).Round.Divide(steps);
        [MethodImpl(AggressiveInlining)]  public Vector2 Spiral(Number R, Number r, Number numTurns) => new Any(Vector2, this.Turns.Multiply(numTurns).Cos, this.Turns.Multiply(numTurns).Sin).Multiply(r.Lerp(R, this));
        public Scaling3D UniformScaling3D { [MethodImpl(AggressiveInlining)] get  => (this, this, this); } 
        public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.Value; } 
        public Boolean GtZ { [MethodImpl(AggressiveInlining)] get  => this.GreaterThan(this.Zero); } 
        public Boolean LtZ { [MethodImpl(AggressiveInlining)] get  => this.LessThan(this.Zero); } 
        public Boolean GtEqZ { [MethodImpl(AggressiveInlining)] get  => this.GreaterThanOrEquals(this.Zero); } 
        public Boolean LtEqZ { [MethodImpl(AggressiveInlining)] get  => this.LessThanOrEquals(this.Zero); } 
        public Boolean IsPositive { [MethodImpl(AggressiveInlining)] get  => this.GtEqZ; } 
        public Boolean IsNegative { [MethodImpl(AggressiveInlining)] get  => this.LtZ; } 
        [MethodImpl(AggressiveInlining)]  public Boolean Between(Number min, Number max) => this.GreaterThanOrEquals(min).And(this.LessThanOrEquals(max));
        [MethodImpl(AggressiveInlining)]  public Number Modulo(Number y) => this.FromNumber(this.ToNumber.Modulo(y.ToNumber));
        [MethodImpl(AggressiveInlining)]  public Number FromNumber(Number n) => this.FromComponents(Intrinsics.MakeArray(n));
        [MethodImpl(AggressiveInlining)]  public Integer Compare(Number b) => this.ToNumber.LessThan(b.ToNumber) ? ((Integer)1).Negative : this.ToNumber.GreaterThan(b.ToNumber) ? ((Integer)1) : ((Integer)0);
        [MethodImpl(AggressiveInlining)]  public Number Subract(Number y) => this.FromNumber(this.ToNumber.Subtract(y));
        public Number PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(this.One); } 
        public Number MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.One); } 
        public Number FromOne { [MethodImpl(AggressiveInlining)] get  => this.One.Subtract(this); } 
        [MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get  => this.Components.Count; } 
        [MethodImpl(AggressiveInlining)]  public Number MapComponents(System.Func<Number, Number> f) => this.FromComponents(this.Components.Map(f));
        [MethodImpl(AggressiveInlining)]  public Number ZipComponents(Number y, System.Func<Number, Number, Number> f) => this.FromComponents(this.Components.Zip(y.Components, f));
        public Number Zero { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((i) => ((Number)0)); } 
        public Number One { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((i) => ((Number)1)); } 
        public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
            var n = this.NumComponents;
            if (n.Equals(((Integer)0)))
            return ((Integer)0);
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(n))
                {
                    r = r.Max(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
            var n = this.NumComponents;
            if (n.Equals(((Integer)0)))
            return ((Integer)0);
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(n))
                {
                    r = r.Min(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        public Number MinValue { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x) => x.MinValue); } 
        public Number MaxValue { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x) => x.MaxValue); } 
        [MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
        [MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
        public Boolean BetweenZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Between(this.Zero, this.One); } 
        [MethodImpl(AggressiveInlining)]  public Number Clamp(Number a, Number b) => this.FromComponents(this.Components.Zip(a.Components, b.Components, (x0, a0, b0) => x0.Clamp(a0, b0)));
        public Number ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(this.Zero, this.One); } 
        public Number Clamp01 { [MethodImpl(AggressiveInlining)] get  => this.ClampZeroOne; } 
        [MethodImpl(AggressiveInlining)]  public IArray<Number> Repeat(Integer n){
            var _var298 = this;
            return n.MapRange((i) => _var298);
        }

        public Number Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
        public Number Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
        public Number Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
        public Number Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
        public Number Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
        public Number Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
        public Number Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
        public Number Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
        public Number Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
        public Number Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
        [MethodImpl(AggressiveInlining)]  public Number Lesser(Number b) => this.LessThanOrEquals(b) ? this : b;
        [MethodImpl(AggressiveInlining)]  public Number Greater(Number b) => this.GreaterThanOrEquals(b) ? this : b;
        [MethodImpl(AggressiveInlining)]  public Number CubicBezier(Number b, Number c, Number d, Number t) => this.Multiply(((Number)1).Subtract(t).Cube).Add(b.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr.Multiply(t))).Add(c.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Multiply(t.Sqr))).Add(d.Multiply(t.Cube))));
        [MethodImpl(AggressiveInlining)]  public Number CubicBezierDerivative(Number b, Number c, Number d, Number t) => b.Subtract(this).Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr)).Add(c.Subtract(b).Multiply(((Number)6).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(d.Subtract(c).Multiply(((Number)3).Multiply(t.Sqr))));
        [MethodImpl(AggressiveInlining)]  public Number CubicBezierSecondDerivative(Number b, Number c, Number d, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(((Number)1).Subtract(t))).Add(d.Subtract(c.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(t)));
        [MethodImpl(AggressiveInlining)]  public Number QuadraticBezier(Number b, Number c, Number t) => this.Multiply(((Number)1).Subtract(t).Sqr).Add(b.Multiply(((Number)2).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(c.Multiply(t.Sqr)));
        [MethodImpl(AggressiveInlining)]  public Number QuadraticBezierDerivative(Number b, Number c, Number t) => b.Subtract(b).Multiply(((Number)2).Multiply(((Number)1).Subtract(t))).Add(c.Subtract(b).Multiply(((Number)2).Multiply(t)));
        [MethodImpl(AggressiveInlining)]  public Number QuadraticBezierSecondDerivative(Number b, Number c, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this));
        [MethodImpl(AggressiveInlining)]  public Number Lerp(Number b, Number t) => this.Multiply(t.FromOne).Add(b.Multiply(t));
        [MethodImpl(AggressiveInlining)]  public Number Barycentric(Number v2, Number v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
        public Number Parabola { [MethodImpl(AggressiveInlining)] get  => this.Sqr; } 
        public Number Pow2 { [MethodImpl(AggressiveInlining)] get  => this.Multiply(this); } 
        public Number Pow3 { [MethodImpl(AggressiveInlining)] get  => this.Pow2.Multiply(this); } 
        public Number Pow4 { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this); } 
        public Number Pow5 { [MethodImpl(AggressiveInlining)] get  => this.Pow4.Multiply(this); } 
        public Number Sqr { [MethodImpl(AggressiveInlining)] get  => this.Pow2; } 
        public Number Cube { [MethodImpl(AggressiveInlining)] get  => this.Pow3; } 

        // Unimplemented concept functions
    }
}
