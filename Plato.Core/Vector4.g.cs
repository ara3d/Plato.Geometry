// Autogenerated file: DO NOT EDIT
// Created on 2025-01-17 3:12:39 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Vector4: IVector<Vector4>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Vector4 Create(Number x, Number y, Number z, Number w) => new Vector4(x, y, z, w);

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number, Number)(Vector4 self) => (self.X, self.Y, self.Z, self.W);
        [MethodImpl(AggressiveInlining)] public static implicit operator Vector4((Number, Number, Number, Number) value) => new(value.Item1, value.Item2, value.Item3, value.Item4);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y, out Number z, out Number w) { x = X; y = Y; z = Z; w = W;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Vector4 other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Vector4 other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Vector4 a, Vector4 b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Vector4 a, Vector4 b) => !a.Equals(b);

        // Explicit implementation of interfaces by forwarding properties to fields

        // Array predefined functions
        [MethodImpl(AggressiveInlining)] public Vector4(IReadOnlyList<Number> xs) : this(xs[0], xs[1], xs[2], xs[3]) { }
        [MethodImpl(AggressiveInlining)] public Vector4(Number[] xs) : this(xs[0], xs[1], xs[2], xs[3]) { }
        [MethodImpl(AggressiveInlining)] public static Vector4 Create(IReadOnlyList<Number> xs) => new Vector4(xs);
        // Implementation of IReadOnlyList
        [MethodImpl(AggressiveInlining)] public System.Collections.Generic.IEnumerator<Number> GetEnumerator() => new ArrayEnumerator<Number>(this);
        [MethodImpl(AggressiveInlining)] System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
        Number System.Collections.Generic.IReadOnlyList<Number>.this[int n] { [MethodImpl(AggressiveInlining)] get => At(n); }
        int System.Collections.Generic.IReadOnlyCollection<Number>.Count { [MethodImpl(AggressiveInlining)] get => this.Count; }

        // Numerical predefined functions
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y, Z, W); }
        [MethodImpl(AggressiveInlining)] public Vector4 FromComponents(IArray<Number> numbers) => new Vector4(numbers[0], numbers[1], numbers[2], numbers[3]);

        // Implemented concept functions and type functions
        public static Vector4 UnitX { [MethodImpl(AggressiveInlining)] get  => (((Number)1), ((Number)0), ((Number)0), ((Number)0)); } 
        public static Vector4 UnitY { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)1), ((Number)0), ((Number)0)); } 
        public static Vector4 UnitZ { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)0), ((Number)1), ((Number)0)); } 
        public static Vector4 UnitW { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)0), ((Number)0), ((Number)1)); } 
        public Vector3 Vector3 { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y, this.Z); } 
        [MethodImpl(AggressiveInlining)]  public static implicit operator Vector3(Vector4 v) => v.Vector3;
        public Vector3 XYZ { [MethodImpl(AggressiveInlining)] get  => this.Vector3; } 
        [MethodImpl(AggressiveInlining)]  public Vector4 Modulo(Vector4 y) => this.ZipComponents(y, (a, b) => a.Modulo(b));
        [MethodImpl(AggressiveInlining)]  public Vector2 MidPoint(Vector4 b) => this.Add(b).Divide(((Number)2));
        public Number Sum { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b) => a.Add(b)); } 
        public Number SumSquares { [MethodImpl(AggressiveInlining)] get  => this.Square.Sum; } 
        public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSquares; } 
        public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.SquareRoot; } 
        [MethodImpl(AggressiveInlining)]  public Vector4 Reflect(Vector4 normal) => this.Subtract(normal.Multiply(this.Dot(normal).Multiply(((Number)2))));
        [MethodImpl(AggressiveInlining)]  public Vector4 Project(Vector4 other) => other.Multiply(this.Dot(other));
        [MethodImpl(AggressiveInlining)]  public Angle Angle(Vector4 b) => this.Dot(b).Divide(this.Magnitude.Multiply(b.Magnitude)).Acos;
        [MethodImpl(AggressiveInlining)]  public Boolean IsParallel(Vector4 b) => this.Dot(b).Abs.GreaterThan(((Number)1).Subtract(Constants.Epsilon));
        public Vector4 PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(this.One); } 
        public Vector4 MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.One); } 
        public Vector4 FromOne { [MethodImpl(AggressiveInlining)] get  => this.One.Subtract(this); } 
        [MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get  => this.Components.Count; } 
        [MethodImpl(AggressiveInlining)]  public Vector4 MapComponents(System.Func<Number, Number> f) => this.FromComponents(this.Components.Map(f));
        [MethodImpl(AggressiveInlining)]  public Vector4 ZipComponents(Vector4 y, System.Func<Number, Number, Number> f) => this.FromComponents(this.Components.Zip(y.Components, f));
        public Vector4 Zero { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((i) => ((Number)0)); } 
        public Vector4 One { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((i) => ((Number)1)); } 
        public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
            var n = this.NumComponents;
            if (n.Equals(((Integer)0)))
            return ((Integer)0);
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(n))
                {
                    r = r.Max(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
            var n = this.NumComponents;
            if (n.Equals(((Integer)0)))
            return ((Integer)0);
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(n))
                {
                    r = r.Min(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        public Vector4 MinValue { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x) => x.MinValue); } 
        public Vector4 MaxValue { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x) => x.MaxValue); } 
        [MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
        [MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
        [MethodImpl(AggressiveInlining)]  public Boolean Between(Vector4 a, Vector4 b) => this.Components.Zip(a.Components, b.Components, (x0, a0, b0) => x0.Between(a0, b0)).All((x0) => x0);
        public Boolean BetweenZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Between(this.Zero, this.One); } 
        public Vector4 ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(this.Zero, this.One); } 
        public Vector4 Clamp01 { [MethodImpl(AggressiveInlining)] get  => this.ClampZeroOne; } 
        public Vector4 Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((c) => c.Fract); } 
        [MethodImpl(AggressiveInlining)]  public Vector4 Modulo(Number s){
            var _var314 = s;
            return this.MapComponents((i) => i.Modulo(_var314));
        }

        [MethodImpl(AggressiveInlining)]  public IArray<Vector4> Repeat(Integer n){
            var _var315 = this;
            return n.MapRange((i) => _var315);
        }

        public Vector4 Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
        public Vector4 Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
        public Vector4 Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
        public Vector4 Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
        public Vector4 Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
        public Vector4 Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
        public Vector4 Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
        public Vector4 Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
        public Vector4 Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
        public Vector4 Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
        public Vector4 Pow2 { [MethodImpl(AggressiveInlining)] get  => this.Multiply(this); } 
        public Vector4 Pow3 { [MethodImpl(AggressiveInlining)] get  => this.Pow2.Multiply(this); } 
        public Vector4 Pow4 { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this); } 
        public Vector4 Pow5 { [MethodImpl(AggressiveInlining)] get  => this.Pow4.Multiply(this); } 
        public Vector4 Square { [MethodImpl(AggressiveInlining)] get  => this.Pow2; } 
        public Vector4 Sqr { [MethodImpl(AggressiveInlining)] get  => this.Pow2; } 
        public Vector4 Cube { [MethodImpl(AggressiveInlining)] get  => this.Pow3; } 
        public Vector4 Parabola { [MethodImpl(AggressiveInlining)] get  => this.Sqr; } 
        [MethodImpl(AggressiveInlining)]  public Vector4 Lerp(Vector4 b, Number t) => this.Multiply(t.FromOne).Add(b.Multiply(t));
        [MethodImpl(AggressiveInlining)]  public Vector4 Barycentric(Vector4 v2, Vector4 v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
        [MethodImpl(AggressiveInlining)]  public Vector4 CubicBezier(Vector4 b, Vector4 c, Vector4 d, Number t) => this.Multiply(((Number)1).Subtract(t).Cube).Add(b.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr.Multiply(t))).Add(c.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Multiply(t.Sqr))).Add(d.Multiply(t.Cube))));
        [MethodImpl(AggressiveInlining)]  public Vector4 CubicBezierDerivative(Vector4 b, Vector4 c, Vector4 d, Number t) => b.Subtract(this).Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr)).Add(c.Subtract(b).Multiply(((Number)6).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(d.Subtract(c).Multiply(((Number)3).Multiply(t.Sqr))));
        [MethodImpl(AggressiveInlining)]  public Vector4 CubicBezierSecondDerivative(Vector4 b, Vector4 c, Vector4 d, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(((Number)1).Subtract(t))).Add(d.Subtract(c.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(t)));
        [MethodImpl(AggressiveInlining)]  public Vector4 QuadraticBezier(Vector4 b, Vector4 c, Number t) => this.Multiply(((Number)1).Subtract(t).Sqr).Add(b.Multiply(((Number)2).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(c.Multiply(t.Sqr)));
        [MethodImpl(AggressiveInlining)]  public Vector4 QuadraticBezierDerivative(Vector4 b, Vector4 c, Number t) => b.Subtract(b).Multiply(((Number)2).Multiply(((Number)1).Subtract(t))).Add(c.Subtract(b).Multiply(((Number)2).Multiply(t)));
        [MethodImpl(AggressiveInlining)]  public Vector4 QuadraticBezierSecondDerivative(Vector4 b, Vector4 c, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this));

        // Unimplemented concept functions
        public Integer Count { [MethodImpl(AggressiveInlining)] get => 4; }
        [MethodImpl(AggressiveInlining)]  public Number At(Integer n) { [MethodImpl(AggressiveInlining)] get => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : n == 3 ? W : throw new System.IndexOutOfRangeException(); }
        public Number this[Integer n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : n == 3 ? W : throw new System.IndexOutOfRangeException();
    }
}
