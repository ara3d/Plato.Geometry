// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Time: IMeasure<Time>
    {
        // Fields
        [DataMember] public readonly Number Seconds;

        // With functions 
        [MethodImpl(AggressiveInlining)] public Time WithSeconds(Number seconds) => new Time(seconds);

        // Regular Constructor
        [MethodImpl(AggressiveInlining)] public Time(Number seconds) { Seconds = seconds; }

        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Time Create(Number seconds) => new Time(seconds);

        // Static default implementation
        public static readonly Time Default = default;

        // Implicit converters to/from single field
        [MethodImpl(AggressiveInlining)] public static implicit operator Number(Time self) => self.Seconds;
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(Number value) => new Time(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(Integer value) => new Time(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(int value) => new Integer(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(float value) => new Number(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator float(Time value) => value.Seconds;

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Time other) => Seconds.Equals(other.Seconds);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Time other) => !Seconds.Equals(other.Seconds);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Time other ? Equals(other).Value : false;
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(Seconds);
        [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"Seconds\" = {Seconds} }}";

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 1; }
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(Seconds); }
        [MethodImpl(AggressiveInlining)] public static Time CreateFromComponents(IArray<Number> numbers) => new Time(numbers[0]);

        [MethodImpl(AggressiveInlining)] public static Time CreateFromComponent(Number x) => new Time(x);

        // Implemented interface functions
        public static Time Zero { [MethodImpl(AggressiveInlining)] get  => Time.CreateFromComponent(((Number)0)); } 
public static Time One { [MethodImpl(AggressiveInlining)] get  => Time.CreateFromComponent(((Number)1)); } 
public static Time MinValue { [MethodImpl(AggressiveInlining)] get  => Time.CreateFromComponent(Number.MinValue); } 
public static Time MaxValue { [MethodImpl(AggressiveInlining)] get  => Time.CreateFromComponent(Number.MaxValue); } 
[MethodImpl(AggressiveInlining)]  public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Time Abs { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Abs); } 
public Time BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Time BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Time Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
public Time Ceiling { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Ceiling); } 
[MethodImpl(AggressiveInlining)]  public Time Clamp(Time min, Time max) => this.ZipComponents(min, max, (a, b, c)  => a.Clamp(b, c));
[MethodImpl(AggressiveInlining)]  public Time CopySign(Time y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
public Time Exp { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Exp); } 
public Time Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Floor); } 
[MethodImpl(AggressiveInlining)]  public Time FusedMultiplyAdd(Time y, Time z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Time ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)]  public Time IEEERemainder(Time y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Time Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
public Time Log2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log2); } 
[MethodImpl(AggressiveInlining)]  public Time Min(Time other) => this.ZipComponents(other, (a, b)  => a.Min(b));
[MethodImpl(AggressiveInlining)]  public Time MinMagnitude(Time other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)]  public Time Max(Time other) => this.ZipComponents(other, (a, b)  => a.Max(b));
[MethodImpl(AggressiveInlining)]  public Time MaxMagnitude(Time other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Time NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)]  public Time Pow(Time power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Time Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Reciprocal); } 
public Time ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Time ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)]  public Time RoundToZero(Integer digits){
            var _var49 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var49));
        }

[MethodImpl(AggressiveInlining)]  public Time ScaleB(Integer n){
            var _var50 = n;
            return this.MapComponents((x)  => x.ScaleB(_var50));
        }

public Time Square { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Sqr); } 
public Time Truncate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Truncate); } 
[MethodImpl(AggressiveInlining)]  public Boolean AlmostEqual(Time y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        [MethodImpl(AggressiveInlining)]  public Time Average(Time y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)]  public Boolean Between(Time a, Time b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Time ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Time Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
public Time FromOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.FromOne); } 
[MethodImpl(AggressiveInlining)]  public Time InversePow(Time y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)]  public Time Lerp(Time b, Number t){
            var _var51 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var51));
        }

[MethodImpl(AggressiveInlining)]  public Time MultiplyEpsilon(Time y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Time Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Time Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Time Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Time Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
public Time Sqr { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqr); } 
public Time Sqrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqrt); } 
[MethodImpl(AggressiveInlining)]  public IArray<Time> Sample(Time b, Integer n){
            var _var53 = b;
            {
                var _var52 = this;
                return n.LinearSpace.Map((i)  => _var52.Lerp(_var53, i));
            }
        }

public Time Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Time Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Time Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Time Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Time Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Time Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Time Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Time Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Time Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Time Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Time Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Time Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Time Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Time Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)]  public Number At(Integer n) => this.Components.At(n);
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Time MapComponents(System.Func<Number, Number> f) => Time.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Time ZipComponents(Time b, System.Func<Number, Number, Number> f) => Time.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Time ZipComponents(Time b, Time c, System.Func<Number, Number, Number, Number> f) => Time.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Time b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Time b, Time c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Time b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Time b, Time c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean LessThan(Time b) => this.LessThanOrEquals(b).And(this.NotEquals(b));
[MethodImpl(AggressiveInlining)]  public static Boolean operator <(Time a, Time b) => a.LessThan(b);
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThan(Time b) => b.LessThan(this);
[MethodImpl(AggressiveInlining)]  public static Boolean operator >(Time a, Time b) => a.GreaterThan(b);
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThanOrEquals(Time b) => b.LessThanOrEquals(this);
[MethodImpl(AggressiveInlining)]  public static Boolean operator >=(Time a, Time b) => a.GreaterThanOrEquals(b);
        [MethodImpl(AggressiveInlining)]  public Time Lesser(Time b) => this.LessThanOrEquals(b) ? this : b;
[MethodImpl(AggressiveInlining)]  public Time Greater(Time b) => this.GreaterThanOrEquals(b) ? this : b;
[MethodImpl(AggressiveInlining)]  public Integer CompareTo(Time b) => this.LessThanOrEquals(b) ? this.Equals(b) ? ((Integer)0) : ((Integer)1).Negative : ((Integer)1);

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)]  public Boolean LessThanOrEquals(Time y) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Boolean operator <=(Time x, Time y) => x.LessThanOrEquals(y);
        [MethodImpl(AggressiveInlining)]  public Time Modulo(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator %(Time self, Number other) => self.Modulo(other);
        [MethodImpl(AggressiveInlining)]  public Time Divide(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator /(Time self, Number other) => self.Divide(other);
        [MethodImpl(AggressiveInlining)]  public Time Multiply(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator *(Time self, Number other) => self.Multiply(other);
    }
}
