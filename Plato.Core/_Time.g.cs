// Autogenerated file: DO NOT EDIT
// Created on 2025-03-14 12:36:59 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Time: IMeasure<Time>
    {
        // Fields
        [DataMember] public readonly Number Seconds;

        // With functions 
        [MethodImpl(AggressiveInlining)] public Time WithSeconds(Number seconds) => new Time(seconds);

        // Regular Constructor
        [MethodImpl(AggressiveInlining)] public Time(Number seconds) { Seconds = seconds; }

        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Time Create(Number seconds) => new Time(seconds);

        // Implicit converters to/from single field
        [MethodImpl(AggressiveInlining)] public static implicit operator Number(Time self) => self.Seconds;
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(Number value) => new Time(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(Integer value) => new Time(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(int value) => new Integer(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator Time(float value) => new Number(value);
        [MethodImpl(AggressiveInlining)] public static implicit operator float(Time value) => value.Seconds;

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Time other) => Seconds.Equals(other.Seconds);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Time other) => !Seconds.Equals(other.Seconds);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Time other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(Seconds);
        [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"Seconds\" = {Seconds} }}";

        // Explicit implementation of interfaces by forwarding properties to fields

        // IVectorSpace predefined functions
        public static readonly int NumComponents = 1;
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(Seconds); }
        [MethodImpl(AggressiveInlining)] public static Time CreateFromComponents(IArray<Number> numbers) => new Time(numbers[0]);

        // Implemented interface functions
        // LessThan(Time, Time):Boolean; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean LessThan(Time b) => this.LessThanOrEquals(b).And(this.NotEquals(b));
[MethodImpl(AggressiveInlining)]  public static Boolean operator <(Time a, Time b) => a.LessThan(b);
        // GreaterThan(Time, Time):Boolean; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThan(Time b) => b.LessThan(this);
[MethodImpl(AggressiveInlining)]  public static Boolean operator >(Time a, Time b) => a.GreaterThan(b);
        // GreaterThanOrEquals(Time, Time):Boolean; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThanOrEquals(Time b) => b.LessThanOrEquals(this);
[MethodImpl(AggressiveInlining)]  public static Boolean operator >=(Time a, Time b) => a.GreaterThanOrEquals(b);
        // Lesser(Time, Time):Time; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Lesser(Time b) => this.LessThanOrEquals(b) ? this : b;
// Greater(Time, Time):Time; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Greater(Time b) => this.GreaterThanOrEquals(b) ? this : b;
// CompareTo(Time, Time):Integer; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Integer CompareTo(Time b) => this.LessThanOrEquals(b) ? this.Equals(b) ? ((Integer)0) : ((Integer)1).Negative : ((Integer)1);
// Lerp(Time, Time, Number):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Lerp(Time b, Number t) => this.Add(b.Subtract(this).Multiply(t));
// PlusOne(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One); } 
// MinusOne(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(Constants.One); } 
// FromOne(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One).Negative; } 
// Component(Time, Integer):Number; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
// MaxComponent(Time):Number; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(NumComponents))
                {
                    r = r.Max(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
// MinComponent(Time):Number; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(NumComponents))
                {
                    r = r.Min(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
// MapComponents(Time, Function1<Number, Number>):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time MapComponents(System.Func<Number, Number> f) => Time.CreateFromComponents(this.Components.Map(f));
// ZipComponents(Time, Time, Function2<Number, Number, Number>):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time ZipComponents(Time b, System.Func<Number, Number, Number> f) => Time.CreateFromComponents(this.Components.Zip(b.Components, f));
// ZipComponents(Time, Time, Time, Function3<Number, Number, Number, Number>):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time ZipComponents(Time b, Time c, System.Func<Number, Number, Number, Number> f) => Time.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
// AllZipComponents(Time, Time, Function2<Number, Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Time b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
// AllZipComponents(Time, Time, Time, Function3<Number, Number, Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Time b, Time c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
// AnyZipComponents(Time, Time, Function2<Number, Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Time b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
// AnyZipComponents(Time, Time, Time, Function3<Number, Number, Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Time b, Time c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
// AllComponents(Time, Function1<Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
// AnyComponent(Time, Function1<Number, Boolean>):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
// Clamp(Time, Time, Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Clamp(Time a, Time b) => this.ZipComponents(a, b, (x0, a0, b0)  => x0.Clamp(a0, b0));
// InversePow(Time, Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time InversePow(Time n) => this.Pow(n.Reciprocal);
// Floor(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x0)  => x0.Floor); } 
// Fract(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Fract { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.Floor); } 
// ClampZeroOne(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(Constants.Zero, Constants.One); } 
// Between(Time, Time, Time):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean Between(Time a, Time b) => this.AllZipComponents(a, b, (x0, a0, b0)  => x0.Between(a0, b0));
// BetweenZeroOne(Time):Boolean; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Boolean BetweenZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Between(Constants.Zero, Constants.One); } 
// Sqrt(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Sqrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((n)  => n.Sqrt); } 
// Pow(Time, Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Pow(Time y) => this.ZipComponents(y, (a, b)  => a.Pow(b));
// Reciprocal(Time):Time; [IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((n)  => n.Reciprocal); } 
// Half(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
// Quarter(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
// Eight(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
// Sixteenth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
// Tenth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
// Twice(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
// Hundred(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
// Thousand(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
// Million(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
// Billion(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
// Hundredth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
// Thousandth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
// Millionth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
// Billionth(Time):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 

        // Unimplemented concept functions
        // Add(Time, Time):Time; [IAdditive=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Add(Time b) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator +(Time a, Time b) => a.Add(b);
        // Subtract(Time, Time):Time; [IAdditive=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Subtract(Time b) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator -(Time a, Time b) => a.Subtract(b);
        // Negative(Time):Time; [IAdditive=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        public Time Negative => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator -(Time self) => self.Negative;
        // LessThanOrEquals(Time, Time):Boolean; [IOrderable=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean LessThanOrEquals(Time y) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Boolean operator <=(Time x, Time y) => x.LessThanOrEquals(y);
        // Modulo(Time, Number):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Modulo(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator %(Time self, Number other) => self.Modulo(other);
        // Divide(Time, Number):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Divide(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator /(Time self, Number other) => self.Divide(other);
        // Multiply(Time, Number):Time; [IScalarArithmetic=Time;IVectorSpace=Time;IMeasure=Time;Self=Time;]; <>
        [MethodImpl(AggressiveInlining)]  public Time Multiply(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Time operator *(Time self, Number other) => self.Multiply(other);
    }
}
