// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Point3D: ICoordinate, IVectorLike<Point3D>, IGeometricPrimitive3D<Point3D>, IDifference<Point3D, Vector3>
    {
        // Fields
        [DataMember] public readonly Number X;
        [DataMember] public readonly Number Y;
        [DataMember] public readonly Number Z;

        // With functions 
        [MethodImpl(AggressiveInlining)] public Point3D WithX(Number x) => new Point3D(x, Y, Z);
        [MethodImpl(AggressiveInlining)] public Point3D WithY(Number y) => new Point3D(X, y, Z);
        [MethodImpl(AggressiveInlining)] public Point3D WithZ(Number z) => new Point3D(X, Y, z);

        // Regular Constructor
        [MethodImpl(AggressiveInlining)] public Point3D(Number x, Number y, Number z) { X = x; Y = y; Z = z; }

        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Point3D Create(Number x, Number y, Number z) => new Point3D(x, y, z);

        // Static default implementation
        public static readonly Point3D Default = default;

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number)(Point3D self) => (self.X, self.Y, self.Z);
        [MethodImpl(AggressiveInlining)] public static implicit operator Point3D((Number, Number, Number) value) => new Point3D(value.Item1, value.Item2, value.Item3);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y, out Number z) { x = X; y = Y; z = Z;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Point3D other) => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Point3D other) => !X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Point3D other ? Equals(other).Value : false;
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(X, Y, Z);
        [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"X\" = {X}, \"Y\" = {Y}, \"Z\" = {Z} }}";

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 3; }
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y, Z); }
        [MethodImpl(AggressiveInlining)] public static Point3D CreateFromComponents(IArray<Number> numbers) => new Point3D(numbers[0], numbers[1], numbers[2]);

        [MethodImpl(AggressiveInlining)] public static Point3D CreateFromComponent(Number x) => new Point3D(x, x, x);

        // Implemented interface functions
        public Vector3 Vector3 { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y, this.Z); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Vector3(Point3D x) => x.Vector3;
        [MethodImpl(AggressiveInlining)]  public Line3D LineTo(Point3D b) => (this, b);
[MethodImpl(AggressiveInlining)]  public Ray3D RayTo(Point3D b) => (this, b.Subtract(this));
[MethodImpl(AggressiveInlining)]  public Ray3D RayFrom(Vector3 dir) => (this, dir);
[MethodImpl(AggressiveInlining)]  public Vector3 Subtract(Point3D p2) => this.Vector3.Subtract(p2.Vector3);
[MethodImpl(AggressiveInlining)]  public static Vector3 operator -(Point3D p1, Point3D p2) => p1.Subtract(p2);
        [MethodImpl(AggressiveInlining)]  public Point3D Add(Vector3 p2) => this.Vector3.Add(p2);
[MethodImpl(AggressiveInlining)]  public static Point3D operator +(Point3D p1, Vector3 p2) => p1.Add(p2);
        [MethodImpl(AggressiveInlining)]  public Point3D Add(Point3D p2) => this.Vector3.Add(p2.Vector3);
[MethodImpl(AggressiveInlining)]  public static Point3D operator +(Point3D p1, Point3D p2) => p1.Add(p2);
        [MethodImpl(AggressiveInlining)]  public Point3D Multiply(Number n) => (this.X.Multiply(n), this.Y.Multiply(n), this.Z.Multiply(n));
[MethodImpl(AggressiveInlining)]  public static Point3D operator *(Point3D a, Number n) => a.Multiply(n);
        [MethodImpl(AggressiveInlining)]  public Point3D Divide(Number n) => (this.X.Divide(n), this.Y.Divide(n), this.Z.Divide(n));
[MethodImpl(AggressiveInlining)]  public static Point3D operator /(Point3D a, Number n) => a.Divide(n);
        [MethodImpl(AggressiveInlining)]  public Point3D Multiply(Vector3 v) => this.Vector3.Multiply(v);
[MethodImpl(AggressiveInlining)]  public static Point3D operator *(Point3D a, Vector3 v) => a.Multiply(v);
        [MethodImpl(AggressiveInlining)]  public Point3D Deform(System.Func<Point3D, Point3D> f) => f.Invoke(this);
[MethodImpl(AggressiveInlining)]  public LookAt3D LookAt(Point3D target) => (this, target);
public static Point3D Zero { [MethodImpl(AggressiveInlining)] get  => Point3D.CreateFromComponent(((Number)0)); } 
public static Point3D One { [MethodImpl(AggressiveInlining)] get  => Point3D.CreateFromComponent(((Number)1)); } 
public static Point3D MinValue { [MethodImpl(AggressiveInlining)] get  => Point3D.CreateFromComponent(Number.MinValue); } 
public static Point3D MaxValue { [MethodImpl(AggressiveInlining)] get  => Point3D.CreateFromComponent(Number.MaxValue); } 
[MethodImpl(AggressiveInlining)]  public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Point3D Abs { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Abs); } 
public Point3D BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Point3D BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Point3D Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
public Point3D Ceiling { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Ceiling); } 
[MethodImpl(AggressiveInlining)]  public Point3D Clamp(Point3D min, Point3D max) => this.ZipComponents(min, max, (a, b, c)  => a.Clamp(b, c));
[MethodImpl(AggressiveInlining)]  public Point3D CopySign(Point3D y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
public Point3D Exp { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Exp); } 
public Point3D Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Floor); } 
[MethodImpl(AggressiveInlining)]  public Point3D FusedMultiplyAdd(Point3D y, Point3D z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Point3D ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)]  public Point3D IEEERemainder(Point3D y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Point3D Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
public Point3D Log2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log2); } 
[MethodImpl(AggressiveInlining)]  public Point3D Min(Point3D other) => this.ZipComponents(other, (a, b)  => a.Min(b));
[MethodImpl(AggressiveInlining)]  public Point3D MinMagnitude(Point3D other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)]  public Point3D Max(Point3D other) => this.ZipComponents(other, (a, b)  => a.Max(b));
[MethodImpl(AggressiveInlining)]  public Point3D MaxMagnitude(Point3D other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Point3D NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)]  public Point3D Pow(Point3D power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Point3D Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Reciprocal); } 
public Point3D ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Point3D ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)]  public Point3D RoundToZero(Integer digits){
            var _var100 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var100));
        }

[MethodImpl(AggressiveInlining)]  public Point3D ScaleB(Integer n){
            var _var101 = n;
            return this.MapComponents((x)  => x.ScaleB(_var101));
        }

public Point3D Square { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Sqr); } 
public Point3D Truncate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Truncate); } 
[MethodImpl(AggressiveInlining)]  public Boolean AlmostEqual(Point3D y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        [MethodImpl(AggressiveInlining)]  public Point3D Average(Point3D y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)]  public Boolean Between(Point3D a, Point3D b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Point3D ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Point3D Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
public Point3D FromOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.FromOne); } 
[MethodImpl(AggressiveInlining)]  public Point3D InversePow(Point3D y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)]  public Point3D Lerp(Point3D b, Number t){
            var _var102 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var102));
        }

[MethodImpl(AggressiveInlining)]  public Point3D MultiplyEpsilon(Point3D y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Point3D Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Point3D Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Point3D Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Point3D Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
public Point3D Sqr { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqr); } 
public Point3D Sqrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqrt); } 
[MethodImpl(AggressiveInlining)]  public IArray<Point3D> Sample(Point3D b, Integer n){
            var _var104 = b;
            {
                var _var103 = this;
                return n.LinearSpace.Map((i)  => _var103.Lerp(_var104, i));
            }
        }

public Point3D Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Point3D Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Point3D Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Point3D Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Point3D Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Point3D Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Point3D Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Point3D Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Point3D Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Point3D Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Point3D Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Point3D Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Point3D Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Point3D Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)]  public Number At(Integer n) => this.Components.At(n);
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Point3D MapComponents(System.Func<Number, Number> f) => Point3D.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Point3D ZipComponents(Point3D b, System.Func<Number, Number, Number> f) => Point3D.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Point3D ZipComponents(Point3D b, Point3D c, System.Func<Number, Number, Number, Number> f) => Point3D.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Point3D b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Point3D b, Point3D c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Point3D b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Point3D b, Point3D c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
[MethodImpl(AggressiveInlining)]  public Point3D Point(Integer index) => this.Points.At(index);
[MethodImpl(AggressiveInlining)]  public Triangle3D Triangle(Integer3 f) => (this.Point(f.A), this.Point(f.B), this.Point(f.C));
[MethodImpl(AggressiveInlining)]  public Quad3D Quad(Integer4 f) => (this.Point(f.A), this.Point(f.B), this.Point(f.C), this.Point(f.D));
public Bounds3D Bounds { [MethodImpl(AggressiveInlining)] get  => this.Points.Bounds(); } 
[MethodImpl(AggressiveInlining)]  public Point3D Deform<_T0>(_T0 t) where _T0 : ITransform3D{
            var _var105 = t;
            return this.Deform((v)  => v.Vector3.Transform(_var105.Matrix));
        }

[MethodImpl(AggressiveInlining)]  public Point3D Scale(Vector3 v){
            var _var106 = v;
            return this.Deform((p)  => p.Vector3.Multiply(_var106));
        }

[MethodImpl(AggressiveInlining)]  public Point3D Scale(Number s) => this.Scale((s, s, s));
[MethodImpl(AggressiveInlining)]  public Point3D ScaleX(Number s) => this.Scale((s, ((Integer)1), ((Integer)1)));
[MethodImpl(AggressiveInlining)]  public Point3D ScaleY(Number s) => this.Scale((((Integer)1), s, ((Integer)1)));
[MethodImpl(AggressiveInlining)]  public Point3D ScaleZ(Number s) => this.Scale((((Integer)1), ((Integer)1), s));
[MethodImpl(AggressiveInlining)]  public Point3D Rotate(Quaternion q){
            var _var107 = q;
            return this.Deform((v)  => _var107.Transform(v));
        }

[MethodImpl(AggressiveInlining)]  public Point3D RotateX(Angle a) => this.Rotate(a.RotateX);
[MethodImpl(AggressiveInlining)]  public Point3D RotateY(Angle a) => this.Rotate(a.RotateY);
[MethodImpl(AggressiveInlining)]  public Point3D RotateZ(Angle a) => this.Rotate(a.RotateZ);
[MethodImpl(AggressiveInlining)]  public Point3D Translate(Vector3 v){
            var _var108 = v;
            return this.Deform((p)  => p.Add(_var108));
        }

[MethodImpl(AggressiveInlining)]  public Point3D TranslateX(Number s) => this.Translate(s.XVector3);
[MethodImpl(AggressiveInlining)]  public Point3D TranslateY(Number s) => this.Translate(s.YVector3);
[MethodImpl(AggressiveInlining)]  public Point3D TranslateZ(Number s) => this.Translate(s.ZVector3);

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)]  public Point3D Subtract(Vector3 amount) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Point3D operator -(Point3D x, Vector3 amount) => x.Subtract(amount);
        public IArray<Point3D> Points => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public Point3D Modulo(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Point3D operator %(Point3D self, Number other) => self.Modulo(other);
    }
}
