// Autogenerated file: DO NOT EDIT
// Created on 2025-03-09 8:08:08 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
public partial struct Rect2D: IPolygon2D
{
    // Fields
    [DataMember] public readonly Vector2 Center;
    [DataMember] public readonly Vector2 Size;

    // With functions 
    [MethodImpl(AggressiveInlining)] public Rect2D WithCenter(Vector2 center) => new Rect2D(center, Size);
    [MethodImpl(AggressiveInlining)] public Rect2D WithSize(Vector2 size) => new Rect2D(Center, size);

    // Regular Constructor
    [MethodImpl(AggressiveInlining)] public Rect2D(Vector2 center, Vector2 size) { Center = center; Size = size; }

    // Static factory function
    [MethodImpl(AggressiveInlining)] public static Rect2D Create(Vector2 center, Vector2 size) => new Rect2D(center, size);

    // Implicit converters to/from value-tuples and deconstructor
    [MethodImpl(AggressiveInlining)] public static implicit operator (Vector2, Vector2)(Rect2D self) => (self.Center, self.Size);
    [MethodImpl(AggressiveInlining)] public static implicit operator Rect2D((Vector2, Vector2) value) => new(value.Item1, value.Item2);
    [MethodImpl(AggressiveInlining)] public void Deconstruct(out Vector2 center, out Vector2 size) { center = Center; size = Size;  }

    // Object virtual function overrides: Equals, GetHashCode, ToString
    [MethodImpl(AggressiveInlining)] public Boolean Equals(Rect2D other) => Center.Equals(other.Center) && Size.Equals(other.Size);
    [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Rect2D other) => !Center.Equals(other.Center) && Size.Equals(other.Size);
    [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Rect2D other ? Equals(other) : false;
    [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(Center, Size);
    [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"Center\" = {Center}, \"Size\" = {Size} }}";

    // Explicit implementation of interfaces by forwarding properties to fields

    // Implemented concept functions and type functions
    public Number Width { [MethodImpl(AggressiveInlining)] get  => this.Size.X; } 
public Number Height { [MethodImpl(AggressiveInlining)] get  => this.Size.Y; } 
public Number Left { [MethodImpl(AggressiveInlining)] get  => this.Center.X.Subtract(this.Width.Half); } 
public Number Right { [MethodImpl(AggressiveInlining)] get  => this.Left.Add(this.Width); } 
public Number Bottom { [MethodImpl(AggressiveInlining)] get  => this.Center.Y.Subtract(this.Height.Half); } 
public Number Top { [MethodImpl(AggressiveInlining)] get  => this.Bottom.Add(this.Height); } 
public Vector2 BottomLeft { [MethodImpl(AggressiveInlining)] get  => (this.Left, this.Bottom); } 
public Vector2 BottomRight { [MethodImpl(AggressiveInlining)] get  => (this.Right, this.Bottom); } 
public Vector2 TopRight { [MethodImpl(AggressiveInlining)] get  => (this.Right, this.Top); } 
public Vector2 TopLeft { [MethodImpl(AggressiveInlining)] get  => (this.Left, this.Top); } 
public Quad2D Quad2D { [MethodImpl(AggressiveInlining)] get  => (this.BottomLeft, this.BottomRight, this.TopRight, this.TopLeft); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Quad2D(Rect2D x) => x.Quad2D;
    public IArray<Vector2> Points { [MethodImpl(AggressiveInlining)] get  => this.Quad2D; } 
public IArray<Line2D> Lines { [MethodImpl(AggressiveInlining)] get  => this.Points.WithNext((a, b) =>  => new Line2D(a, b);
 } 
[MethodImpl(AggressiveInlining)]  public IArray<Vector2> Sample(Integer numPoints){
    var _var622 = this;
    return numPoints.LinearSpace.Map((x) =>  => _var622.Eval(x);
;
}

[MethodImpl(AggressiveInlining)]  public PolyLine2D ToPolyLine2D(Integer numPoints) => (this.Sample(numPoints), this.Closed);
[MethodImpl(AggressiveInlining)]  public Procedural<Number, TR> Combine<TR>(Rect2D b, System.Func<TR, TR, TR> f){
    var _var625 = b;
    {
        var _var624 = this;
        {
            var _var623 = f;
            return (x) =>  => _var623.Invoke(_var624.Eval(x), _var625.Eval(x));
;
        }
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<TR, Vector2> MapDomain<T0, TR>(System.Func<T0, TR> f){
    var _var627 = f;
    {
        var _var626 = this;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var626.Eval(_var627.Invoke(x));
;
    }
}

public System.Func<Number, Vector2> Function { [MethodImpl(AggressiveInlining)] get {
    var _var628 = this;
    return (x) =>  => _var628.Eval(x);
;
}
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Number, Vector2> Compose(Rect2D b){
    var _var630 = this;
    {
        var _var629 = b;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var629.Eval(_var630.Eval(x));
;
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, TR> Combine<TR>(Rect2D b, System.Func<TR, TR, TR> f){
    var _var633 = b;
    {
        var _var632 = this;
        {
            var _var631 = f;
            return (x) =>  => _var631.Invoke(_var632.Eval(x), _var633.Eval(x));
;
        }
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<TR, Number> MapDomain<T0, TR>(System.Func<T0, TR> f){
    var _var635 = f;
    {
        var _var634 = this;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var634.Eval(_var635.Invoke(x));
;
    }
}

public System.Func<Vector2, Number> Function { [MethodImpl(AggressiveInlining)] get {
    var _var636 = this;
    return (x) =>  => _var636.Eval(x);
;
}
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, Number> Compose(Rect2D b){
    var _var638 = this;
    {
        var _var637 = b;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var637.Eval(_var638.Eval(x));
;
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, $TOut> Union(Rect2D b) => this.Combine(b, (a, b) =>  => a.Max(b);

[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, $TOut> Intersection(Rect2D b) => this.Combine(b, (a, b) =>  => a.Min(b);

[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, $TOut> Difference(Rect2D b) => this.Combine(b, (a, b) =>  => a.Max(b.Negative);

public Procedural<Vector2, Number> Inverse { [MethodImpl(AggressiveInlining)] get  => this.Map((x) =>  => x.Negative;
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Vector2, Boolean> Threshold(Number threshold){
    var _var639 = threshold;
    return this.Map((x) =>  => x.GreaterThanOrEquals(_var639);
;
}

public Boolean Closed { [MethodImpl(AggressiveInlining)] get  => ((Boolean)true); } 

    // Unimplemented concept functions
    [MethodImpl(AggressiveInlining)]  public Number Distance(Vector2 p) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public Number Eval(Vector2 t) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public Vector2 Eval(Number t) => throw new NotImplementedException();
public IArray<Vector2> Corners => throw new NotImplementedException();
public Integer PrimitiveSize => throw new NotImplementedException();
public Integer NumPrimitives => throw new NotImplementedException();
}
Plato.CSharpWriter.CSharpConcreteTypeWriter}
