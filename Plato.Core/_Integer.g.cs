// Autogenerated file: DO NOT EDIT
// Created on 2025-03-14 12:36:59 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Integer: IWholeNumber<Integer>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Integer Create() => new Integer();

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Integer other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Integer other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Integer other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Integer a, Integer b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Integer a, Integer b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // Implemented interface functions
        // Turns(Integer):Angle; [Self=Integer;]; <>
        public Angle Turns { [MethodImpl(AggressiveInlining)] get  => this.Number.Turns; } 
// Degrees(Integer):Angle; [Self=Integer;]; <>
        public Angle Degrees { [MethodImpl(AggressiveInlining)] get  => this.Number.Turns; } 
// Gradians(Integer):Angle; [Self=Integer;]; <>
        public Angle Gradians { [MethodImpl(AggressiveInlining)] get  => this.Number.Gradians; } 
// ArcMinutes(Integer):Angle; [Self=Integer;]; <>
        public Angle ArcMinutes { [MethodImpl(AggressiveInlining)] get  => this.Number.ArcMinutes; } 
// ArcSeconds(Integer):Angle; [Self=Integer;]; <>
        public Angle ArcSeconds { [MethodImpl(AggressiveInlining)] get  => this.Number.ArcSeconds; } 
// Range(Integer):Array<Integer>; [Self=Integer;]; <>
        public Array<Integer> Range { [MethodImpl(AggressiveInlining)] get  => this.MapRange((i)  => i); } 
// CirclePoints(Integer):_T0; [Self=Integer;]; <_T0:IArray<Vector2>>
        public _T0 CirclePoints<_T0> { [MethodImpl(AggressiveInlining)] get  => this.Fractions.Map((x)  => x.Turns.UnitCircle); } 
// Number(Integer):Number; [Self=Integer;]; <>
        public Number Number { [MethodImpl(AggressiveInlining)] get  => this; } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Number(Integer x) => x.Number;
        // PlusOne(Integer):Integer; [Self=Integer;]; <>
        public Integer PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(((Integer)1)); } 
// MinusOne(Integer):Integer; [Self=Integer;]; <>
        public Integer MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(((Integer)1)); } 
// FromOne(Integer):Integer; [Self=Integer;]; <>
        public Integer FromOne { [MethodImpl(AggressiveInlining)] get  => ((Integer)1).Subtract(this); } 
// FloatDivision(Integer, Integer):Number; [Self=Integer;]; <>
        [MethodImpl(AggressiveInlining)]  public Number FloatDivision(Integer y) => this.Number.Divide(y.Number);
// Fractions(Integer):_T0; [Self=Integer;]; <_T0:IArray<Number>>
        public _T0 Fractions<_T0> { [MethodImpl(AggressiveInlining)] get {
            var _var187 = this;
            return this.Range.Map((i)  => i.FloatDivision(_var187.Subtract(((Integer)1))));
        }
         } 
// FractionsExclusive(Integer):_T0; [Self=Integer;]; <_T0:IArray<Number>>
        public _T0 FractionsExclusive<_T0> { [MethodImpl(AggressiveInlining)] get {
            var _var188 = this;
            return this.Range.Map((i)  => i.FloatDivision(_var188));
        }
         } 
// LinearSpace(Integer):_T0; [Self=Integer;]; <_T0:IArray<Number>>
        public _T0 LinearSpace<_T0> { [MethodImpl(AggressiveInlining)] get  => this.Fractions; } 
// LinearSpaceExclusive(Integer):_T0; [Self=Integer;]; <_T0:IArray<Number>>
        public _T0 LinearSpaceExclusive<_T0> { [MethodImpl(AggressiveInlining)] get  => this.FractionsExclusive; } 
// Intervals(Integer):_T0; [Self=Integer;]; <_T0:IArray<NumberInterval>>
        public _T0 Intervals<_T0> { [MethodImpl(AggressiveInlining)] get  => this.Add(((Integer)1)).LinearSpace.WithNext((a, b)  => new NumberInterval(a, b)); } 
[MethodImpl(AggressiveInlining)]  public Integer Add(Integer b) => this + b;
        [MethodImpl(AggressiveInlining)]  public Integer Subtract(Integer b) => this - b;
        [MethodImpl(AggressiveInlining)]  public Integer Multiply(Integer b) => this * b;
        [MethodImpl(AggressiveInlining)]  public Integer Divide(Integer b) => this / b;
        [MethodImpl(AggressiveInlining)]  public Integer Modulo(Integer b) => this % b;
        public Integer Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)]  public Boolean LessThan(Integer b) => this < b;
        [MethodImpl(AggressiveInlining)]  public Boolean LessThanOrEquals(Integer b) => this <= b;
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThan(Integer b) => this > b;
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThanOrEquals(Integer b) => this >= b;
        // QuadFaceIndices(Integer, Integer, Integer, Integer):Integer4; [Self=Integer;]; <>
        [MethodImpl(AggressiveInlining)]  public Integer4 QuadFaceIndices(Integer row, Integer nCols, Integer nRows){
            var a = row.Multiply(nCols).Add(this);
            var b = row.Multiply(nCols).Add(this.Add(((Integer)1)).Modulo(nCols));
            var c = row.Add(((Integer)1)).Modulo(nRows).Multiply(nCols).Add(this.Add(((Integer)1)).Modulo(nCols));
            var d = row.Add(((Integer)1)).Modulo(nRows).Multiply(nCols).Add(this);
            return (a, b, c, d);
        }

// AllQuadFaceIndices(Integer, Integer, Boolean, Boolean):_T0; [Self=Integer;]; <_T0:IArray2D<Integer4>>
        [MethodImpl(AggressiveInlining)]  public _T0 AllQuadFaceIndices<_T0>(Integer nRows, Boolean closedX, Boolean closedY){
            var _var190 = nRows;
            {
                var _var189 = this;
                {
                    var nx = this.Subtract(closedX ? ((Integer)0) : ((Integer)1));
                    var ny = nRows.Subtract(closedY ? ((Integer)0) : ((Integer)1));
                    return nx.MakeArray2D(ny, (col, row)  => col.QuadFaceIndices(row, _var189, _var190));
                }
            }
        }

// Lesser(Integer, Integer):Integer; [IOrderable=Integer;IWholeNumber=Integer;Self=Integer;]; <>
        [MethodImpl(AggressiveInlining)]  public Integer Lesser(Integer b) => this.LessThanOrEquals(b) ? this : b;
// Greater(Integer, Integer):Integer; [IOrderable=Integer;IWholeNumber=Integer;Self=Integer;]; <>
        [MethodImpl(AggressiveInlining)]  public Integer Greater(Integer b) => this.GreaterThanOrEquals(b) ? this : b;

        // Unimplemented concept functions
    }
}
