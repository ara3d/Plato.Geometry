// Autogenerated file: DO NOT EDIT
// Created on 2025-03-18 2:15:23 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    public interface IAny<Self> where Self : IAny<Self>
    {
        Boolean Equals(Self b);
    }
public interface IValue
    {
    }
public interface IAdditive<Self> where Self : IAdditive<Self>
    {
        Self Add(Self b);
        Self Subtract(Self b);
        Self Negative { get; }
    }
public interface IScalarArithmetic<Self> where Self : IScalarArithmetic<Self>
    {
        Self Modulo(Number other);
        Self Divide(Number other);
        Self Multiply(Number other);
    }
public interface IInterpolatable<Self> where Self : IInterpolatable<Self>
    {
        Self Lerp(Self b, Number t);
    }
public interface IVectorSpace<Self>: IInterpolatable<Self>, IAdditive<Self>, IScalarArithmetic<Self> where Self : IVectorSpace<Self>
    {
        Integer NumComponents { get; }
        IArray<Number> Components { get; }
        Self CreateFromComponents(IArray<Number> xs);
        Self CreateFromNumber(Number x);
    }
public interface IMultiplicative<Self> where Self : IMultiplicative<Self>
    {
        Self Multiply(Self b);
    }
public interface IDivisible<Self> where Self : IDivisible<Self>
    {
        Self Divide(Self b);
    }
public interface IModulo<Self> where Self : IModulo<Self>
    {
        Self Modulo(Self b);
    }
public interface IArithmetic<Self>: IAdditive<Self>, IMultiplicative<Self>, IDivisible<Self>, IModulo<Self> where Self : IArithmetic<Self>
    {
    }
public interface INumerical<Self>: IVectorSpace<Self>, IArithmetic<Self> where Self : INumerical<Self>
    {
    }
public interface IOrderable<Self> where Self : IOrderable<Self>
    {
        Boolean LessThanOrEquals(Self y);
    }
public interface IInvertible<Self> where Self : IInvertible<Self>
    {
        Self Inverse { get; }
    }
public interface IMultiplicativeWithInverse<Self>: IMultiplicative<Self>, IInvertible<Self> where Self : IMultiplicativeWithInverse<Self>
    {
    }
public interface IRealNumber<Self>: INumerical<Self>, IOrderable<Self> where Self : IRealNumber<Self>
    {
    }
public interface IWholeNumber<Self>: IOrderable<Self>, IArithmetic<Self>, IInterpolatable<Self> where Self : IWholeNumber<Self>
    {
    }
public interface IMeasure<Self>: IOrderable<Self>, IVectorSpace<Self> where Self : IMeasure<Self>
    {
    }
public interface IVector<Self>: IArray<Number>, INumerical<Self>, IArithmetic<Self> where Self : IVector<Self>
    {
    }
public interface ICoordinate
    {
    }
public interface IBoolean<Self> where Self : IBoolean<Self>
    {
        Self And(Self b);
        Self Or(Self b);
        Self Not { get; }
    }
public interface IInterval<T>: IValue, IArray<T>
    {
        T Start { get; }
        T End { get; }
    }
public interface IBounds<T>: IValue
    {
        T Min { get; }
        T Max { get; }
    }
public interface IRealFunction
    {
        Number Eval(Number x);
    }
public interface IAngularCurve2D: ICurve2D
    {
        Vector2 Eval(Angle t);
    }
public interface IPolarCurve: IAngularCurve2D
    {
        Number GetRadius(Angle t);
    }
public interface IAngularCurve3D: ICurve3D
    {
        Vector3 Eval(Angle t);
    }
public interface IGeometry
    {
    }
public interface IGeometry2D: IGeometry
    {
    }
public interface IGeometry3D: IGeometry
    {
    }
public interface IBounded2D
    {
        Bounds2D Bounds { get; }
    }
public interface IBounded3D
    {
        Bounds3D Bounds { get; }
    }
public interface IDeformable2D<Self> where Self : IDeformable2D<Self>
    {
        Self Deform(System.Func<Vector2, Vector2> f);
    }
public interface IDeformable3D<Self> where Self : IDeformable3D<Self>
    {
        Self Deform(System.Func<Vector3, Vector3> f);
    }
public interface IShape: IGeometry
    {
    }
public interface IShape2D: IShape, IGeometry2D
    {
    }
public interface IShape3D: IShape, IGeometry3D
    {
    }
public interface IOpenClosedShape: IShape
    {
        Boolean Closed { get; }
    }
public interface IOpenShape: IOpenClosedShape
    {
    }
public interface IClosedShape: IOpenClosedShape
    {
    }
public interface IOpenShape2D: IGeometry2D, IOpenShape
    {
    }
public interface IClosedShape2D: IGeometry2D, IClosedShape
    {
    }
public interface IOpenShape3D: IGeometry3D, IOpenShape
    {
    }
public interface IClosedShape3D: IGeometry3D, IClosedShape
    {
    }
public interface ICurve<TRange>: IProcedural<Number, TRange>, IOpenClosedShape
    {
    }
public interface IDistanceField2D: IProcedural<Vector2, Number>
    {
        Number Distance(Vector2 p);
    }
public interface IDistanceField3D: IProcedural<Vector3, Number>
    {
        Number Distance(Vector3 p);
    }
public interface ICurve1D: ICurve<Number>
    {
    }
public interface ICurve2D: IGeometry2D, ICurve<Vector2>
    {
    }
public interface IClosedCurve2D: ICurve2D, IClosedShape2D
    {
    }
public interface IOpenCurve2D: ICurve2D, IOpenShape2D
    {
    }
public interface ICurve3D: IGeometry3D, ICurve<Vector3>
    {
    }
public interface IClosedCurve3D: ICurve3D, IClosedShape3D
    {
    }
public interface IOpenCurve3D: ICurve3D, IOpenShape3D
    {
    }
public interface ISurface: IGeometry3D
    {
    }
public interface IProceduralSurface: IProcedural<Vector2, Vector3>, ISurface
    {
        Boolean ClosedX { get; }
        Boolean ClosedY { get; }
    }
public interface IExplicitSurface: IProcedural<Vector2, Number>, ISurface
    {
    }
public interface IImplicitProcedural<TDomain>: IProcedural<TDomain, Boolean>
    {
    }
public interface IImplicitSurface: ISurface, IImplicitProcedural<Vector3>
    {
    }
public interface IImplicitCurve2D: IGeometry2D, IImplicitProcedural<Vector2>
    {
    }
public interface IImplicitVolume: IGeometry3D, IImplicitProcedural<Vector3>
    {
    }
public interface IPolyLine2D: IPointGeometry2D, IOpenClosedShape, ICurve2D
    {
    }
public interface IPolyLine3D: IPointGeometry3D, IOpenClosedShape, ICurve3D
    {
    }
public interface IPolygon2D: IPolyLine2D, IClosedShape2D
    {
    }
public interface IPolygon3D: IPolyLine3D, IClosedShape3D
    {
    }
public interface ISolid: IProceduralSurface
    {
    }
public interface IPrimitiveGeometry
    {
        Integer PrimitiveSize { get; }
        Integer NumPrimitives { get; }
    }
public interface IPointGeometry: IPrimitiveGeometry
    {
    }
public interface ILineGeometry: IPrimitiveGeometry
    {
    }
public interface ITriangleGeometry: IPrimitiveGeometry
    {
    }
public interface IQuadGeometry: IPrimitiveGeometry
    {
    }
public interface IPrimitiveGeometry2D: IPrimitiveGeometry
    {
        IArray<Vector2> Corners { get; }
    }
public interface IPrimitiveGeometry3D: IPrimitiveGeometry
    {
        IArray<Vector3> Corners { get; }
    }
public interface IPointGeometry2D: IPrimitiveGeometry2D
    {
        IArray<Vector2> Points { get; }
    }
public interface IPointGeometry3D: IPrimitiveGeometry3D
    {
        IArray<Vector3> Points { get; }
    }
public interface ILineGeometry2D: IPrimitiveGeometry2D, ILineGeometry
    {
        IArray<Line2D> Lines { get; }
    }
public interface ILineGeometry3D: IPrimitiveGeometry3D, ILineGeometry
    {
        IArray<Line3D> Lines { get; }
    }
public interface ITriangleGeometry2D: IPrimitiveGeometry2D, ITriangleGeometry
    {
        IArray<Triangle2D> Triangles { get; }
    }
public interface ITriangleGeometry3D: IPrimitiveGeometry3D, ITriangleGeometry
    {
        IArray<Triangle3D> Triangles { get; }
    }
public interface IQuadGeometry2D: IPrimitiveGeometry2D, IQuadGeometry
    {
        IArray<Quad2D> Quads { get; }
    }
public interface IQuadGeometry3D: IPrimitiveGeometry3D, IQuadGeometry
    {
        IArray<Quad3D> Quads { get; }
    }
public interface IIndexedGeometry: IPrimitiveGeometry
    {
        IArray<Integer> Indices { get; }
    }
public interface IIndexedGeometry2D: IIndexedGeometry, IPrimitiveGeometry2D
    {
    }
public interface IIndexedGeometry3D: IIndexedGeometry, IPrimitiveGeometry3D
    {
    }
public interface ILineMesh2D: IIndexedGeometry2D, ILineGeometry2D
    {
    }
public interface ILineMesh3D: IIndexedGeometry3D, ILineGeometry3D
    {
    }
public interface ITriangleMesh2D: IIndexedGeometry2D, ITriangleGeometry2D
    {
    }
public interface ITriangleMesh3D: IIndexedGeometry3D, ITriangleGeometry3D
    {
    }
public interface IQuadMesh2D: IIndexedGeometry2D, IQuadGeometry2D
    {
    }
public interface IQuadMesh3D: IIndexedGeometry3D, IQuadGeometry3D
    {
    }
public interface IPointArray2D: IPointGeometry2D
    {
    }
public interface IPointArray3D: IPointGeometry3D
    {
    }
public interface ILineArray2D: ILineMesh2D
    {
    }
public interface ILineArray3D: ILineMesh3D
    {
    }
public interface ITriangleArray2D: ITriangleMesh2D
    {
    }
public interface ITriangleArray3D: ITriangleMesh3D
    {
    }
public interface IQuadArray2D: IQuadMesh2D
    {
    }
public interface IQuadArray3D: IQuadMesh3D
    {
    }
public interface IQuadGrid3D: IQuadMesh3D
    {
        IArray2D<Vector3> PointGrid { get; }
        Boolean ClosedX { get; }
        Boolean ClosedY { get; }
    }
public interface IProcedural<TIn, TOut>
    {
        TOut Eval(TIn t);
    }
public interface ITransform3D
    {
        Vector3 Transform(Vector3 v);
        Vector3 TransformNormal(Vector3 v);
        Matrix4x4 Matrix { get; }
    }
public interface IRigidTransform3D: ITransform3D
    {
        Translation3D Translation { get; }
        Rotation3D Rotation { get; }
    }
public interface IRotationalTransform3D: IRigidTransform3D
    {
        Quaternion Quaternion { get; }
    }
}
