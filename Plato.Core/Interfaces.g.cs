// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    public interface IAny<Self> where Self : IAny<Self>
    {
        Boolean Equals(Self b);
    }
public interface IValue
    {
    }
public interface IAdditive<Self> where Self : IAdditive<Self>
    {
        Self Add(Self b);
        Self Subtract(Self b);
        Self Negative { get; }
    }
public interface IScalarArithmetic<Self> where Self : IScalarArithmetic<Self>
    {
        Self Modulo(Number other);
        Self Divide(Number other);
        Self Multiply(Number other);
    }
public interface IInterpolatable<Self> where Self : IInterpolatable<Self>
    {
        Self Lerp(Self b, Number t);
    }
public interface IArrayLike<Self, T> where Self : IArrayLike<Self, T>
    {
        IArray<T> Components { get; }
    }
public interface IVectorLike<Self>: IInterpolatable<Self>, IScalarArithmetic<Self>, IArrayLike<Self, Number> where Self : IVectorLike<Self>
    {
    }
public interface IMultiplicative<Self> where Self : IMultiplicative<Self>
    {
        Self Multiply(Self b);
    }
public interface IDivisible<Self> where Self : IDivisible<Self>
    {
        Self Divide(Self b);
    }
public interface IModulo<Self> where Self : IModulo<Self>
    {
        Self Modulo(Self b);
    }
public interface IArithmetic<Self>: IAdditive<Self>, IMultiplicative<Self>, IDivisible<Self>, IModulo<Self> where Self : IArithmetic<Self>
    {
    }
public interface INumerical<Self>: IVectorLike<Self>, IArithmetic<Self> where Self : INumerical<Self>
    {
    }
public interface IVector<Self>: INumerical<Self> where Self : IVector<Self>
    {
    }
public interface IOrderable<Self> where Self : IOrderable<Self>
    {
        Boolean LessThanOrEquals(Self y);
    }
public interface IInvertible<Self> where Self : IInvertible<Self>
    {
        Self Inverse { get; }
    }
public interface IMultiplicativeWithInverse<Self>: IMultiplicative<Self>, IInvertible<Self> where Self : IMultiplicativeWithInverse<Self>
    {
    }
public interface IRealNumber<Self>: INumerical<Self>, IOrderable<Self> where Self : IRealNumber<Self>
    {
    }
public interface IWholeNumber<Self>: IOrderable<Self>, IArithmetic<Self>, IInterpolatable<Self> where Self : IWholeNumber<Self>
    {
    }
public interface IMeasure<Self>: IVectorLike<Self>, IOrderable<Self> where Self : IMeasure<Self>
    {
    }
public interface ICoordinate
    {
    }
public interface IDifference<Self, T> where Self : IDifference<Self, T>
    {
        Self Add(T amount);
        Self Subtract(T amount);
        T Subtract(Self y);
    }
public interface IBoolean<Self> where Self : IBoolean<Self>
    {
        Self And(Self b);
        Self Or(Self b);
        Self Not { get; }
    }
public interface IInterval<T>: IValue
    {
        T Start { get; }
        T End { get; }
    }
public interface IBounds<TValue, TDelta>: IValue
    {
        TValue Min { get; }
        TValue Max { get; }
    }
public interface IRealFunction
    {
        Number Eval(Number x);
    }
public interface IAngularCurve2D: ICurve2D
    {
        Point2D Eval(Angle t);
    }
public interface IPolarCurve: IAngularCurve2D
    {
        Number GetRadius(Angle t);
    }
public interface IAngularCurve3D: ICurve3D
    {
        Point3D Eval(Angle t);
    }
public interface IGeometry
    {
    }
public interface IGeometry2D: IGeometry
    {
    }
public interface IGeometry3D: IGeometry
    {
    }
public interface IBounded2D
    {
        Bounds2D Bounds { get; }
    }
public interface IBounded3D
    {
        Bounds3D Bounds { get; }
    }
public interface IDeformable2D<Self> where Self : IDeformable2D<Self>
    {
        Self Deform(System.Func<Point2D, Point2D> f);
    }
public interface IDeformable3D<Self> where Self : IDeformable3D<Self>
    {
        Self Deform(System.Func<Point3D, Point3D> f);
    }
public interface IShape: IGeometry
    {
    }
public interface IShape2D: IShape, IGeometry2D
    {
    }
public interface IShape3D: IShape, IGeometry3D
    {
    }
public interface IOpenClosedShape: IShape
    {
        Boolean Closed { get; }
    }
public interface IOpenShape: IOpenClosedShape
    {
    }
public interface IClosedShape: IOpenClosedShape
    {
    }
public interface IOpenShape2D: IGeometry2D, IOpenShape
    {
    }
public interface IClosedShape2D: IGeometry2D, IClosedShape
    {
    }
public interface IOpenShape3D: IGeometry3D, IOpenShape
    {
    }
public interface IClosedShape3D: IGeometry3D, IClosedShape
    {
    }
public interface ICurve<TRange>: IProcedural<Number, TRange>, IOpenClosedShape
    {
    }
public interface IDistanceField2D: IProcedural<Vector2, Number>
    {
        Number Distance(Point2D p);
    }
public interface IDistanceField3D: IProcedural<Vector3, Number>
    {
        Number Distance(Point3D p);
    }
public interface ICurve1D: ICurve<Number>
    {
    }
public interface ICurve2D: IGeometry2D, ICurve<Point2D>
    {
    }
public interface IClosedCurve2D: ICurve2D, IClosedShape2D
    {
    }
public interface IOpenCurve2D: ICurve2D, IOpenShape2D
    {
    }
public interface ICurve3D: IGeometry3D, ICurve<Point3D>
    {
    }
public interface IClosedCurve3D: ICurve3D, IClosedShape3D
    {
    }
public interface IOpenCurve3D: ICurve3D, IOpenShape3D
    {
    }
public interface ISurface: IGeometry3D
    {
    }
public interface IProceduralSurface: IProcedural<Vector2, Point3D>, ISurface
    {
        Boolean ClosedX { get; }
        Boolean ClosedY { get; }
    }
public interface IExplicitSurface: IProcedural<Vector2, Number>, ISurface
    {
    }
public interface IImplicitProcedural<TDomain>: IProcedural<TDomain, Boolean>
    {
    }
public interface IImplicitSurface: ISurface, IImplicitProcedural<Point3D>
    {
    }
public interface IImplicitCurve2D: IGeometry2D, IImplicitProcedural<Point2D>
    {
    }
public interface IImplicitVolume: IGeometry3D, IImplicitProcedural<Point3D>
    {
    }
public interface IPolyLine2D<Self>: IPointGeometry2D<Self>, IOpenClosedShape, ICurve2D where Self : IPolyLine2D<Self>
    {
    }
public interface IPolyLine3D<Self>: IPointGeometry3D<Self>, IOpenClosedShape, ICurve3D where Self : IPolyLine3D<Self>
    {
    }
public interface IPolygon2D<Self>: IPolyLine2D<Self>, IClosedShape2D where Self : IPolygon2D<Self>
    {
    }
public interface IPolygon3D<Self>: IPolyLine3D<Self>, IClosedShape3D where Self : IPolygon3D<Self>
    {
    }
public interface ISolid: IProceduralSurface
    {
    }
public interface IPointGeometry2D<Self>: IGeometry2D, IDeformable2D<Self>, IBounded2D where Self : IPointGeometry2D<Self>
    {
        IArray<Point2D> Points { get; }
    }
public interface IPointGeometry3D<Self>: IGeometry3D, IDeformable3D<Self>, IBounded3D where Self : IPointGeometry3D<Self>
    {
        IArray<Point3D> Points { get; }
    }
public interface IPrimitiveGeometry
    {
        Integer PrimitiveSize { get; }
        Integer NumPrimitives { get; }
    }
public interface ILineGeometry: IPrimitiveGeometry
    {
    }
public interface ITriangleGeometry: IPrimitiveGeometry
    {
    }
public interface IQuadGeometry: IPrimitiveGeometry
    {
    }
public interface IGeometricPrimitive2D<Self>: IPointGeometry2D<Self>, IDeformable2D<Self> where Self : IGeometricPrimitive2D<Self>
    {
    }
public interface IGeometricPrimitive3D<Self>: IPointGeometry3D<Self>, IDeformable3D<Self> where Self : IGeometricPrimitive3D<Self>
    {
    }
public interface IPrimitiveGeometry2D<Self, T>: IPrimitiveGeometry, IDeformable2D<Self> where Self : IPrimitiveGeometry2D<Self, T>
    {
        IArray<T> Primitives { get; }
    }
public interface IPrimitiveGeometry3D<Self, T>: IPrimitiveGeometry, IDeformable3D<Self> where Self : IPrimitiveGeometry3D<Self, T>
    {
        IArray<T> Primitives { get; }
    }
public interface ILineGeometry2D<Self>: IPrimitiveGeometry2D<Self, Line2D>, ILineGeometry where Self : ILineGeometry2D<Self>
    {
    }
public interface ILineGeometry3D<Self>: IPrimitiveGeometry3D<Self, Line3D>, ILineGeometry where Self : ILineGeometry3D<Self>
    {
    }
public interface ITriangleGeometry2D<Self>: IPrimitiveGeometry2D<Self, Triangle2D>, ITriangleGeometry where Self : ITriangleGeometry2D<Self>
    {
    }
public interface ITriangleGeometry3D<Self>: IPrimitiveGeometry3D<Self, Triangle3D>, ITriangleGeometry where Self : ITriangleGeometry3D<Self>
    {
    }
public interface IQuadGeometry2D<Self>: IPrimitiveGeometry2D<Self, Quad2D>, IQuadGeometry where Self : IQuadGeometry2D<Self>
    {
    }
public interface IQuadGeometry3D<Self>: IPrimitiveGeometry3D<Self, Quad3D>, IQuadGeometry where Self : IQuadGeometry3D<Self>
    {
    }
public interface IIndexedGeometry: IPrimitiveGeometry
    {
        IArray<Integer> Indices { get; }
    }
public interface IPointArray2D<Self>: IPointGeometry2D<Self> where Self : IPointArray2D<Self>
    {
    }
public interface IPointArray3D<Self>: IPointGeometry3D<Self> where Self : IPointArray3D<Self>
    {
    }
public interface IIndexedGeometry2D<Self>: IIndexedGeometry, IPointGeometry2D<Self> where Self : IIndexedGeometry2D<Self>
    {
    }
public interface IIndexedGeometry3D<Self>: IIndexedGeometry, IPointGeometry3D<Self> where Self : IIndexedGeometry3D<Self>
    {
    }
public interface ILineMesh2D<Self>: IIndexedGeometry2D<Self>, ILineGeometry2D<Self> where Self : ILineMesh2D<Self>
    {
    }
public interface ILineMesh3D<Self>: IIndexedGeometry3D<Self>, ILineGeometry3D<Self> where Self : ILineMesh3D<Self>
    {
    }
public interface ILineArray2D<Self>: ILineGeometry2D<Self> where Self : ILineArray2D<Self>
    {
    }
public interface ILineArray3D<Self>: ILineGeometry3D<Self> where Self : ILineArray3D<Self>
    {
    }
public interface ITriangleMesh2D<Self>: IIndexedGeometry2D<Self>, ITriangleGeometry2D<Self> where Self : ITriangleMesh2D<Self>
    {
    }
public interface ITriangleMesh3D<Self>: IIndexedGeometry3D<Self>, ITriangleGeometry3D<Self> where Self : ITriangleMesh3D<Self>
    {
    }
public interface ITriangleArray2D<Self>: ITriangleGeometry2D<Self> where Self : ITriangleArray2D<Self>
    {
    }
public interface ITriangleArray3D<Self>: ITriangleGeometry3D<Self> where Self : ITriangleArray3D<Self>
    {
    }
public interface IQuadMesh2D<Self>: IIndexedGeometry2D<Self>, IQuadGeometry2D<Self> where Self : IQuadMesh2D<Self>
    {
    }
public interface IQuadMesh3D<Self>: IIndexedGeometry3D<Self>, IQuadGeometry3D<Self> where Self : IQuadMesh3D<Self>
    {
    }
public interface IQuadArray2D<Self>: IQuadGeometry2D<Self> where Self : IQuadArray2D<Self>
    {
    }
public interface IQuadArray3D<Self>: IQuadGeometry3D<Self> where Self : IQuadArray3D<Self>
    {
    }
public interface IQuadGrid2D<Self>: IQuadMesh2D<Self> where Self : IQuadGrid2D<Self>
    {
        IArray2D<Point2D> PointGrid { get; }
    }
public interface IQuadGrid3D<Self>: IQuadMesh3D<Self> where Self : IQuadGrid3D<Self>
    {
        IArray2D<Point3D> PointGrid { get; }
        Boolean ClosedX { get; }
        Boolean ClosedY { get; }
    }
public interface IProcedural<TIn, TOut>
    {
        TOut Eval(TIn t);
    }
public interface ITransform2D
    {
        Matrix3x2 Matrix { get; }
    }
public interface IRigidTransform2D: ITransform2D
    {
    }
public interface ITransform3D
    {
        Matrix4x4 Matrix { get; }
    }
public interface IRigidTransform3D: ITransform3D
    {
    }
public interface IRotation3D: IRigidTransform3D
    {
        Quaternion Quaternion { get; }
    }
}
