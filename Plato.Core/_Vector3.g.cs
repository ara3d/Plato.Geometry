// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Vector3: IVector<Vector3>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Vector3 Create(Number x, Number y, Number z) => new Vector3(x, y, z);

        // Static default implementation
        public static readonly Vector3 Default = default;

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number)(Vector3 self) => (self.X, self.Y, self.Z);
        [MethodImpl(AggressiveInlining)] public static implicit operator Vector3((Number, Number, Number) value) => new Vector3(value.Item1, value.Item2, value.Item3);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y, out Number z) { x = X; y = Y; z = Z;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Vector3 other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Vector3 other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Vector3 other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Vector3 a, Vector3 b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Vector3 a, Vector3 b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 3; }
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y, Z); }
        [MethodImpl(AggressiveInlining)] public static Vector3 CreateFromComponents(IArray<Number> numbers) => new Vector3(numbers[0], numbers[1], numbers[2]);

        [MethodImpl(AggressiveInlining)] public static Vector3 CreateFromComponent(Number x) => new Vector3(x, x, x);

        // Implemented interface functions
        public Point3D Point3D { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y, this.Z); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Point3D(Vector3 x) => x.Point3D;
        public Ray3D Ray3D { [MethodImpl(AggressiveInlining)] get  => (Constants.Origin3D, this); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Ray3D(Vector3 v) => v.Ray3D;
        [MethodImpl(AggressiveInlining)]  public Vector3 Add(Vector3 right) => this + right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Subtract(Vector3 right) => this - right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Multiply(Vector3 right) => this * right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Multiply(Number scalar) => this * scalar;
        [MethodImpl(AggressiveInlining)]  public Vector3 Divide(Vector3 right) => this / right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Divide(Number scalar) => this / scalar;
        public Vector3 Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)]  public AxisAngle Rotation(Angle a) => (this, a);
public Vector4 Vector4 { [MethodImpl(AggressiveInlining)] get  => this.ToVector4(((Number)0)); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Vector4(Vector3 v) => v.Vector4;
        [MethodImpl(AggressiveInlining)]  public Vector4 ToVector4(Number w) => (this.X, this.Y, this.Z, w);
public Vector3 XZY { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Z, this.Y); } 
public Vector3 YXZ { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.X, this.Z); } 
public Vector3 YZX { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.Z, this.X); } 
public Vector3 ZXY { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.X, this.Y); } 
public Vector3 ZYX { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.Y, this.X); } 
public Vector2 XY { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y); } 
public Vector2 YX { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.X); } 
public Vector2 XZ { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Z); } 
public Vector2 ZX { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.X); } 
public Vector2 YZ { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.Z); } 
public Vector2 ZY { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.Y); } 
public Vector2 XX { [MethodImpl(AggressiveInlining)] get  => (this.X, this.X); } 
public Vector2 YY { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.Y); } 
public Vector2 ZZ { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.Z); } 
[MethodImpl(AggressiveInlining)]  public Vector3 Project(Plane p) => this.Subtract(p.Normal.Multiply(p.Normal.Dot(this)));
[MethodImpl(AggressiveInlining)]  public Number MixedProduct(Vector3 b, Vector3 c) => this.Cross(b).Dot(c);
public Vector2 To2D { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y); } 
public static Vector3 UnitX { [MethodImpl(AggressiveInlining)] get  => (((Number)1), ((Number)0), ((Number)0)); } 
public static Vector3 UnitY { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)1), ((Number)0)); } 
public static Vector3 UnitZ { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)0), ((Number)1)); } 
[MethodImpl(AggressiveInlining)]  public Vector3 Project(Vector3 other) => other.Multiply(this.Dot(other));
[MethodImpl(AggressiveInlining)]  public Angle Angle(Vector3 b) => this.Dot(b).Divide(this.Magnitude.Multiply(b.Magnitude)).Acos;
[MethodImpl(AggressiveInlining)]  public Boolean IsParallel(Vector3 b) => this.Dot(b).Abs.GreaterThanOrEquals(((Number)1).Subtract(Constants.Epsilon));
public Vector3 PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One); } 
public Vector3 MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(One); } 
// AMBIGUOUS FUNCTIONS 2
        public Vector3 FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One).Negative; } 
[MethodImpl(AggressiveInlining)]  public Vector3 Barycentric(Vector3 v2, Vector3 v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
[MethodImpl(AggressiveInlining)]  public Vector3 Linear(Vector3 b, Number x) => this.Multiply(x).Add(b);
[MethodImpl(AggressiveInlining)]  public Vector3 Quadratic(Vector3 b, Vector3 c, Number x) => this.Multiply(x.Sqr).Add(b.Multiply(x).Add(c));
[MethodImpl(AggressiveInlining)]  public Vector3 Cubic(Vector3 b, Vector3 c, Vector3 d, Number x) => this.Multiply(x.Pow3).Add(b.Multiply(x.Sqr).Add(c.Multiply(x).Add(d)));
[MethodImpl(AggressiveInlining)]  public Vector3 Quartic(Vector3 b, Vector3 c, Vector3 d, Vector3 e, Number x) => this.Multiply(x.Pow(((Integer)4))).Add(b.Multiply(x.Pow3).Add(c.Multiply(x.Sqr).Add(d.Multiply(x).Add(e))));
[MethodImpl(AggressiveInlining)]  public Vector3 LinearDerivative(Vector3 b, Number x) => this;
[MethodImpl(AggressiveInlining)]  public Vector3 LinearSecondDerivative(Vector3 b, Number x) => default;
[MethodImpl(AggressiveInlining)]  public Vector3 QuadraticDerivative(Vector3 b, Vector3 c, Number x) => this.Multiply(((Number)2)).Multiply(x).Add(b);
[MethodImpl(AggressiveInlining)]  public Vector3 QuadraticSecondDerivative(Vector3 b, Vector3 c, Number x) => this.Multiply(((Number)2));
[MethodImpl(AggressiveInlining)]  public Vector3 CubicDerivative(Vector3 b, Vector3 c, Vector3 d, Number x) => this.Multiply(((Number)3)).Multiply(x.Sqr).Add(b.Multiply(((Number)2)).Multiply(x).Add(c));
[MethodImpl(AggressiveInlining)]  public Vector3 CubicSecondDerivative(Vector3 b, Vector3 c, Vector3 d, Number x) => this.Multiply(((Number)6)).Multiply(x).Add(b.Multiply(((Number)2)));
[MethodImpl(AggressiveInlining)]  public Vector3 QuarticSecondDerivative(Vector3 b, Vector3 c, Vector3 d, Vector3 e, Number x) => this.Multiply(((Number)12)).Multiply(x.Sqr).Add(b.Multiply(((Number)6)).Multiply(x).Add(c.Multiply(((Number)2))));
[MethodImpl(AggressiveInlining)]  public Vector3 CubicBezier(Vector3 b, Vector3 c, Vector3 d, Number t) => this.Multiply(((Number)1).Subtract(t).Pow3).Add(b.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr.Multiply(t))).Add(c.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Multiply(t.Sqr))).Add(d.Multiply(t.Pow3))));
[MethodImpl(AggressiveInlining)]  public Vector3 CubicBezierDerivative(Vector3 b, Vector3 c, Vector3 d, Number t) => b.Subtract(this).Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr)).Add(c.Subtract(b).Multiply(((Number)6).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(d.Subtract(c).Multiply(((Number)3).Multiply(t.Sqr))));
[MethodImpl(AggressiveInlining)]  public Vector3 CubicBezierSecondDerivative(Vector3 b, Vector3 c, Vector3 d, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(((Number)1).Subtract(t))).Add(d.Subtract(c.Multiply(((Number)2)).Add(b)).Multiply(((Number)6).Multiply(t)));
[MethodImpl(AggressiveInlining)]  public Vector3 QuadraticBezier(Vector3 b, Vector3 c, Number t) => this.Multiply(((Number)1).Subtract(t).Sqr).Add(b.Multiply(((Number)2).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(c.Multiply(t.Sqr)));
[MethodImpl(AggressiveInlining)]  public Vector3 QuadraticBezierDerivative(Vector3 b, Vector3 c, Number t) => b.Subtract(this).Multiply(((Number)2).Multiply(((Number)1).Subtract(t))).Add(c.Subtract(b).Multiply(((Number)2).Multiply(t)));
[MethodImpl(AggressiveInlining)]  public Vector3 QuadraticBezierSecondDerivative(Vector3 b, Vector3 c, Number t) => ((Number)2).Multiply(this.Subtract(b.Multiply(((Number)2)).Add(c)));
[MethodImpl(AggressiveInlining)]  public Vector3 Hermite(Vector3 p1, Vector3 m0, Vector3 m1, Number t) => this.Multiply(((Number)2).Multiply(t.Pow3).Subtract(((Number)3).Multiply(t.Sqr).Add(((Number)1)))).Add(m0.Multiply(t.Pow3.Subtract(((Number)2).Multiply(t.Sqr).Add(t))).Add(p1.Multiply(((Number)2).Multiply(t.Pow3).Add(((Number)3).Multiply(t.Sqr)).Negative).Add(m1.Multiply(t.Pow3.Subtract(t.Sqr)))));
[MethodImpl(AggressiveInlining)]  public Vector3 HermiteDerivative(Vector3 p1, Vector3 m0, Vector3 m1, Number t) => this.Multiply(((Number)6).Multiply(t.Sqr).Subtract(((Number)6).Multiply(t))).Add(m0.Multiply(((Number)3).Multiply(t.Sqr).Subtract(((Number)4).Multiply(t).Add(((Number)1)))).Add(p1.Multiply(((Number)6).Multiply(t.Sqr).Add(((Number)6).Multiply(t)).Negative).Add(m1.Multiply(((Number)3).Multiply(t.Sqr).Subtract(((Number)2).Multiply(t))))));
[MethodImpl(AggressiveInlining)]  public Vector3 CatmullRom(Vector3 p1, Vector3 p2, Vector3 p3, Number t) => ((Number)0.5).Multiply(p1.Multiply(((Number)2)).Add(p2.Subtract(this).Multiply(t).Add(this.Multiply(((Number)2)).Subtract(p1.Multiply(((Number)5)).Add(p2.Multiply(((Number)4)).Subtract(p3))).Multiply(t.Sqr).Add(this.Add(p1.Multiply(((Number)3)).Subtract(p2.Multiply(((Number)3)).Add(p3))).Negative.Multiply(t.Pow3)))));
[MethodImpl(AggressiveInlining)]  public Vector3 CatmullRomDerivative(Vector3 p1, Vector3 p2, Vector3 p3, Number t) => ((Number)0.5).Multiply(p2.Subtract(this).Add(((Number)2).Multiply(this.Multiply(((Number)2)).Subtract(p1.Multiply(((Number)5)).Add(p2.Multiply(((Number)4)).Subtract(p3))).Multiply(t)).Add(((Number)3).Multiply(this.Add(p1.Multiply(((Number)3)).Subtract(p2.Multiply(((Number)3)).Add(p3))).Negative.Multiply(t.Sqr)))));
public Vector3 SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Multiply(this.Twice.Add(((Number)3)).Negative); } 
public Vector3 SmootherStep { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this.Multiply(((Number)6)).Subtract(((Number)15))).Add(((Number)10)); } 
public static Vector3 Zero { [MethodImpl(AggressiveInlining)] get  => Vector3.CreateFromComponent(((Number)0)); } 
public static Vector3 One { [MethodImpl(AggressiveInlining)] get  => Vector3.CreateFromComponent(((Number)1)); } 
public static Vector3 MinValue { [MethodImpl(AggressiveInlining)] get  => Vector3.CreateFromComponent(Number.MinValue); } 
public static Vector3 MaxValue { [MethodImpl(AggressiveInlining)] get  => Vector3.CreateFromComponent(Number.MaxValue); } 
[MethodImpl(AggressiveInlining)]  public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Vector3 BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Vector3 BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Vector3 Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
[MethodImpl(AggressiveInlining)]  public Vector3 CopySign(Vector3 y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
[MethodImpl(AggressiveInlining)]  public Vector3 FusedMultiplyAdd(Vector3 y, Vector3 z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Vector3 ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)]  public Vector3 IEEERemainder(Vector3 y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Vector3 Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
[MethodImpl(AggressiveInlining)]  public Vector3 MinMagnitude(Vector3 other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)]  public Vector3 MaxMagnitude(Vector3 other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Vector3 NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)]  public Vector3 Pow(Vector3 power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Vector3 Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Reciprocal); } 
public Vector3 ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Vector3 ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)]  public Vector3 RoundToZero(Integer digits){
            var _var199 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var199));
        }

[MethodImpl(AggressiveInlining)]  public Vector3 ScaleB(Integer n){
            var _var200 = n;
            return this.MapComponents((x)  => x.ScaleB(_var200));
        }

public Vector3 Square { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Sqr); } 
[MethodImpl(AggressiveInlining)]  public Boolean AlmostEqual(Vector3 y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        [MethodImpl(AggressiveInlining)]  public Vector3 Average(Vector3 y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)]  public Boolean Between(Vector3 a, Vector3 b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Vector3 ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Vector3 Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
[MethodImpl(AggressiveInlining)]  public Vector3 InversePow(Vector3 y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)]  public Vector3 Lerp(Vector3 b, Number t){
            var _var201 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var201));
        }

[MethodImpl(AggressiveInlining)]  public Vector3 MultiplyEpsilon(Vector3 y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Vector3 Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Vector3 Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Vector3 Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Vector3 Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
public Vector3 Sqr { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqr); } 
[MethodImpl(AggressiveInlining)]  public IArray<Vector3> Sample(Vector3 b, Integer n){
            var _var203 = b;
            {
                var _var202 = this;
                return n.LinearSpace.Map((i)  => _var202.Lerp(_var203, i));
            }
        }

public Vector3 Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Vector3 Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Vector3 Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Vector3 Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Vector3 Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Vector3 Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Vector3 Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Vector3 Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Vector3 Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Vector3 Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Vector3 Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Vector3 Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Vector3 Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Vector3 Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)]  public Number At(Integer n) => this.Components.At(n);
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Vector3 MapComponents(System.Func<Number, Number> f) => Vector3.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Vector3 ZipComponents(Vector3 b, System.Func<Number, Number, Number> f) => Vector3.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Vector3 ZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Number> f) => Vector3.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector3 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector3 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)]  public Vector3 Modulo(Vector3 b) => this % b;
        [MethodImpl(AggressiveInlining)]  public Vector3 Modulo(Number other) => this % other;
    }
}
