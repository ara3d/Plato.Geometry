// Autogenerated file: DO NOT EDIT
// Created on 2025-03-14 12:36:59 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Vector3: IVector<Vector3>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Vector3 Create(Number x, Number y, Number z) => new Vector3(x, y, z);

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number)(Vector3 self) => (self.X, self.Y, self.Z);
        [MethodImpl(AggressiveInlining)] public static implicit operator Vector3((Number, Number, Number) value) => new(value.Item1, value.Item2, value.Item3);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y, out Number z) { x = X; y = Y; z = Z;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Vector3 other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Vector3 other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Vector3 other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Vector3 a, Vector3 b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Vector3 a, Vector3 b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // Array predefined functions
        [MethodImpl(AggressiveInlining)] public Vector3(IReadOnlyList<Number> xs) : this(xs[0], xs[1], xs[2]) { }
        [MethodImpl(AggressiveInlining)] public Vector3(Number[] xs) : this(xs[0], xs[1], xs[2]) { }
        [MethodImpl(AggressiveInlining)] public static Vector3 Create(IReadOnlyList<Number> xs) => new Vector3(xs);
        // Implementation of IReadOnlyList
        [MethodImpl(AggressiveInlining)] public System.Collections.Generic.IEnumerator<Number> GetEnumerator() => new ArrayEnumerator<Number>(this);
        [MethodImpl(AggressiveInlining)] System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
        Number System.Collections.Generic.IReadOnlyList<Number>.this[int n] { [MethodImpl(AggressiveInlining)] get => At(n); }
        int System.Collections.Generic.IReadOnlyCollection<Number>.Count { [MethodImpl(AggressiveInlining)] get => this.Count; }

        // IVectorSpace predefined functions
        public static readonly int NumComponents = 3;
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y, Z); }
        [MethodImpl(AggressiveInlining)] public static Vector3 CreateFromComponents(IArray<Number> numbers) => new Vector3(numbers[0], numbers[1], numbers[2]);

        // Implemented interface functions
        [MethodImpl(AggressiveInlining)]  public Vector3 Add(Vector3 right) => this + right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Subtract(Vector3 right) => this - right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Multiply(Vector3 right) => this * right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Multiply(Number scalar) => this * scalar;
        [MethodImpl(AggressiveInlining)]  public Vector3 Divide(Vector3 right) => this / right;
        [MethodImpl(AggressiveInlining)]  public Vector3 Divide(Number scalar) => this / scalar;
        public Vector3 Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        // Deform(Vector3, Function1<Vector3, Vector3>):Vector3; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 Deform(System.Func<Vector3, Vector3> f) => f.Invoke(this);
// XZY(Vector3):Vector3; [Self=Vector3;]; <>
        public Vector3 XZY { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Z, this.Y); } 
// YXZ(Vector3):Vector3; [Self=Vector3;]; <>
        public Vector3 YXZ { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.X, this.Z); } 
// YZX(Vector3):Vector3; [Self=Vector3;]; <>
        public Vector3 YZX { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.Z, this.X); } 
// ZXY(Vector3):Vector3; [Self=Vector3;]; <>
        public Vector3 ZXY { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.X, this.Y); } 
// ZYX(Vector3):Vector3; [Self=Vector3;]; <>
        public Vector3 ZYX { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.Y, this.X); } 
// XY(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 XY { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y); } 
// YX(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 YX { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.X); } 
// XZ(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 XZ { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Z); } 
// ZX(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 ZX { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.X); } 
// YZ(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 YZ { [MethodImpl(AggressiveInlining)] get  => (this.Y, this.Z); } 
// ZY(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 ZY { [MethodImpl(AggressiveInlining)] get  => (this.Z, this.Y); } 
// Line(Vector3, Vector3):Line3D; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Line3D Line(Vector3 b) => (this, b);
// Ray(Vector3, Vector3):Ray3D; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Ray3D Ray(Vector3 b) => (this, b);
// RayTo(Vector3, Vector3):Ray3D; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Ray3D RayTo(Vector3 b) => (this, b.Subtract(this));
// Project(Vector3, Plane):Vector3; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 Project(Plane p) => this.Subtract(p.Normal.Multiply(p.Normal.Dot(this)));
// To2D(Vector3):Vector2; [Self=Vector3;]; <>
        public Vector2 To2D { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y); } 
// MixedProduct(Vector3, Vector3, Vector3):Number; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Number MixedProduct(Vector3 b, Vector3 c) => this.Cross(b).Dot(c);
// Vector4(Vector3, Number):Vector4; [Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector4 Vector4(Number w) => (this.X, this.Y, this.Z, w);
// UnitX(Vector3):Vector3; [Self=Vector3;]; <>
        public static Vector3 UnitX { [MethodImpl(AggressiveInlining)] get  => (((Number)1), ((Number)0), ((Number)0)); } 
// UnitY(Vector3):Vector3; [Self=Vector3;]; <>
        public static Vector3 UnitY { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)1), ((Number)0)); } 
// UnitZ(Vector3):Vector3; [Self=Vector3;]; <>
        public static Vector3 UnitZ { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)0), ((Number)1)); } 
// MidPoint(Vector3, Vector3):Vector3; [IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 MidPoint(Vector3 b) => this.Add(b).Half;
// Sum(Vector3):Number; [IVector=Vector3;Self=Vector3;]; <>
        public Number Sum { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
// SumSquares(Vector3):Number; [IVector=Vector3;Self=Vector3;]; <>
        public Number SumSquares { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Sum; } 
// MagnitudeSquared(Vector3):Number; [IVector=Vector3;Self=Vector3;]; <>
        public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSquares; } 
// Magnitude(Vector3):Number; [IVector=Vector3;Self=Vector3;]; <>
        public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
// Project(Vector3, Vector3):Vector3; [IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 Project(Vector3 other) => other.Multiply(this.Dot(other));
// Angle(Vector3, Vector3):Angle; [IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Angle Angle(Vector3 b) => this.Dot(b).Divide(this.Magnitude.Multiply(b.Magnitude)).Acos;
// IsParallel(Vector3, Vector3):Boolean; [IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean IsParallel(Vector3 b) => this.Dot(b).Abs.GreaterThanOrEquals(Constants.One.Subtract(Constants.Epsilon));
// Lerp(Vector3, Vector3, Number):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 Lerp(Vector3 b, Number t) => this.Multiply(t.FromOne).Add(b.Multiply(t));
// SmoothStep(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Multiply(this.Twice.Add(((Number)3)).Negative); } 
// SmootherStep(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 SmootherStep { [MethodImpl(AggressiveInlining)] get  => this.Cube.Multiply(this.Multiply(((Number)6)).Subtract(((Number)15))).Add(((Number)10)); } 
// Pow2(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Pow2 { [MethodImpl(AggressiveInlining)] get  => this.Multiply(this); } 
// Pow3(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Pow3 { [MethodImpl(AggressiveInlining)] get  => this.Pow2.Multiply(this); } 
// Pow4(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Pow4 { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this); } 
// Pow5(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Pow5 { [MethodImpl(AggressiveInlining)] get  => this.Pow4.Multiply(this); } 
// Sqr(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Sqr { [MethodImpl(AggressiveInlining)] get  => this.Pow2; } 
// Cube(Vector3):Vector3; [INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Cube { [MethodImpl(AggressiveInlining)] get  => this.Pow3; } 
// PlusOne(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One); } 
// MinusOne(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(Constants.One); } 
// FromOne(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One).Negative; } 
// Component(Vector3, Integer):Number; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
// MaxComponent(Vector3):Number; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(NumComponents))
                {
                    r = r.Max(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
// MinComponent(Vector3):Number; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(NumComponents))
                {
                    r = r.Min(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
// MapComponents(Vector3, Function1<Number, Number>):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 MapComponents(System.Func<Number, Number> f) => Vector3.CreateFromComponents(this.Components.Map(f));
// ZipComponents(Vector3, Vector3, Function2<Number, Number, Number>):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 ZipComponents(Vector3 b, System.Func<Number, Number, Number> f) => Vector3.CreateFromComponents(this.Components.Zip(b.Components, f));
// ZipComponents(Vector3, Vector3, Vector3, Function3<Number, Number, Number, Number>):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 ZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Number> f) => Vector3.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
// AllZipComponents(Vector3, Vector3, Function2<Number, Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector3 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
// AllZipComponents(Vector3, Vector3, Vector3, Function3<Number, Number, Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
// AnyZipComponents(Vector3, Vector3, Function2<Number, Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector3 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
// AnyZipComponents(Vector3, Vector3, Vector3, Function3<Number, Number, Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector3 b, Vector3 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
// AllComponents(Vector3, Function1<Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
// AnyComponent(Vector3, Function1<Number, Boolean>):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
// InversePow(Vector3, Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 InversePow(Vector3 n) => this.Pow(n.Reciprocal);
// Fract(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Fract { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.Floor); } 
// ClampZeroOne(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(Constants.Zero, Constants.One); } 
// Between(Vector3, Vector3, Vector3):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Boolean Between(Vector3 a, Vector3 b) => this.AllZipComponents(a, b, (x0, a0, b0)  => x0.Between(a0, b0));
// BetweenZeroOne(Vector3):Boolean; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Boolean BetweenZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Between(Constants.Zero, Constants.One); } 
// Pow(Vector3, Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        [MethodImpl(AggressiveInlining)]  public Vector3 Pow(Vector3 y) => this.ZipComponents(y, (a, b)  => a.Pow(b));
// Reciprocal(Vector3):Vector3; [IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((n)  => n.Reciprocal); } 
// Half(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
// Quarter(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
// Eight(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
// Sixteenth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
// Tenth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
// Twice(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
// Hundred(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
// Thousand(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
// Million(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
// Billion(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
// Hundredth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
// Thousandth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
// Millionth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
// Billionth(Vector3):Vector3; [IScalarArithmetic=Vector3;IVectorSpace=Vector3;INumerical=Vector3;IVector=Vector3;Self=Vector3;]; <>
        public Vector3 Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 

        // Unimplemented concept functions
        public Integer Count { [MethodImpl(AggressiveInlining)] get => 3; }
        [MethodImpl(AggressiveInlining)]  public Number At(Integer n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : throw new System.IndexOutOfRangeException();
        public Number this[Integer n] { [MethodImpl(AggressiveInlining)] get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Vector3 Modulo(Vector3 b) => this % b;
        [MethodImpl(AggressiveInlining)]  public Vector3 Modulo(Number other) => this % other;
    }
}
