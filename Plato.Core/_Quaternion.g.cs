// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Quaternion: IValue, IArrayLike<Quaternion, Number>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Quaternion Create(Number x, Number y, Number z, Number w) => new Quaternion(x, y, z, w);

        // Static default implementation
        public static readonly Quaternion Default = default;

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number, Number)(Quaternion self) => (self.X, self.Y, self.Z, self.W);
        [MethodImpl(AggressiveInlining)] public static implicit operator Quaternion((Number, Number, Number, Number) value) => new Quaternion(value.Item1, value.Item2, value.Item3, value.Item4);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y, out Number z, out Number w) { x = X; y = Y; z = Z; w = W;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Quaternion other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Quaternion other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Quaternion other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Quaternion a, Quaternion b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Quaternion a, Quaternion b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 4; }
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y, Z, W); }
        [MethodImpl(AggressiveInlining)] public static Quaternion CreateFromComponents(IArray<Number> numbers) => new Quaternion(numbers[0], numbers[1], numbers[2], numbers[3]);

        [MethodImpl(AggressiveInlining)] public static Quaternion CreateFromComponent(Number x) => new Quaternion(x, x, x, x);

        // Implemented interface functions
        [MethodImpl(AggressiveInlining)]  public Quaternion Add(Quaternion b) => this + b;
        [MethodImpl(AggressiveInlining)]  public Quaternion Subtract(Quaternion b) => this - b;
        public Quaternion Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)]  public Quaternion Multiply(Quaternion b) => this * b;
        [MethodImpl(AggressiveInlining)]  public Quaternion Multiply(Number scalar) => this * scalar;
        [MethodImpl(AggressiveInlining)]  public Quaternion Divide(Quaternion b) => this / b;
        [MethodImpl(AggressiveInlining)]  public Vector3 Transform(Vector3 v) => v.Transform(this);
[MethodImpl(AggressiveInlining)]  public Vector3 Multiply(Vector3 v) => this.Transform(v);
public Matrix4x4 Matrix { [MethodImpl(AggressiveInlining)] get  => this; } 
public Matrix4x4 Matrix4x4 { [MethodImpl(AggressiveInlining)] get  => Matrix4x4.CreateFromQuaternion(this); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Matrix4x4(Quaternion q) => q.Matrix4x4;
        public static Quaternion Identity { [MethodImpl(AggressiveInlining)] get  => (((Number)0), ((Number)0), ((Number)0), ((Number)1)); } 
[MethodImpl(AggressiveInlining)]  public Number At(Integer n) => this.Components.At(n);
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Quaternion MapComponents(System.Func<Number, Number> f) => Quaternion.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Quaternion ZipComponents(Quaternion b, System.Func<Number, Number, Number> f) => Quaternion.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Quaternion ZipComponents(Quaternion b, Quaternion c, System.Func<Number, Number, Number, Number> f) => Quaternion.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Quaternion b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Quaternion b, Quaternion c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Quaternion b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Quaternion b, Quaternion c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);

        // Unimplemented interface functions
    }
}
