// Autogenerated file: DO NOT EDIT
// Created on 2025-01-20 10:41:00 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Angle: IMeasure<Angle>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Angle Create() => new Angle();

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Angle other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Angle other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Angle other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Angle a, Angle b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Angle a, Angle b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // Numerical predefined functions
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(); }
        [MethodImpl(AggressiveInlining)] public Angle FromComponents(IArray<Number> numbers) => new Angle();

        // Implemented concept functions and type functions
        public static Angle Zero { [MethodImpl(AggressiveInlining)] get  => ((Number)0); } 
        public Number Turns { [MethodImpl(AggressiveInlining)] get  => this.Radians.Divide(Constants.TwoPi); } 
        public Number Degrees { [MethodImpl(AggressiveInlining)] get  => this.Turns.Multiply(((Number)360)); } 
        public Number Gradians { [MethodImpl(AggressiveInlining)] get  => this.Turns.Multiply(((Number)400)); } 
        public Number Radians { [MethodImpl(AggressiveInlining)] get  => this; } 
        public Number Sec { [MethodImpl(AggressiveInlining)] get  => this.Cos.Reciprocal; } 
        public Number Csc { [MethodImpl(AggressiveInlining)] get  => this.Sin.Reciprocal; } 
        public Number Cot { [MethodImpl(AggressiveInlining)] get  => this.Tan.Reciprocal; } 
        public Vector2 UnitCircle { [MethodImpl(AggressiveInlining)] get  => (this.Cos, this.Sin); } 
        [MethodImpl(AggressiveInlining)]  public Vector2 Circle(Vector2 center, Number radius) => this.UnitCircle.Multiply(radius).Add(center);
        [MethodImpl(AggressiveInlining)]  public Vector2 Ellipse(Vector2 center, Vector2 size) => this.UnitCircle.Multiply(size).Add(center);
        [MethodImpl(AggressiveInlining)]  public Vector2 Epicycloid(Number R, Number r) => (R.Add(r).Multiply(this.Cos).Subtract(r.Multiply(R.Add(r).Multiply(this.Divide(r).Cos))), R.Add(r).Multiply(this.Sin).Subtract(r.Multiply(R.Add(r).Multiply(this.Divide(r).Sin))));
        [MethodImpl(AggressiveInlining)]  public Vector2 Hypocycloid(Number R, Number r) => (R.Subtract(r).Multiply(this.Cos).Add(r.Multiply(R.Subtract(r).Multiply(this.Divide(r).Cos))), R.Subtract(r).Multiply(this.Sin).Subtract(r.Multiply(R.Subtract(r).Multiply(this.Divide(r).Sin))));
        [MethodImpl(AggressiveInlining)]  public Vector2 Epitrochoid(Number R, Number r, Number d) => (R.Add(r).Multiply(this.Cos).Subtract(d.Multiply(R.Add(r).Multiply(this.Divide(r).Cos))), R.Add(r).Multiply(this.Sin).Subtract(d.Multiply(R.Add(r).Multiply(this.Divide(r).Sin))));
        [MethodImpl(AggressiveInlining)]  public Vector2 Hypotrochoid(Number R, Number r, Number d) => (R.Subtract(r).Multiply(this.Cos).Add(d.Multiply(R.Subtract(r).Multiply(this.Divide(r).Cos))), R.Subtract(r).Multiply(this.Sin).Subtract(d.Multiply(R.Subtract(r).Multiply(this.Divide(r).Sin))));
        public Vector2 ButterflyCurve { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)6)).ButterflyCurveSection; } 
        public Vector2 ButterflyCurveSection { [MethodImpl(AggressiveInlining)] get  => (this.Multiply(this.Cos.Exp.Subtract(((Number)2).Multiply(this.Multiply(((Number)4)).Cos).Subtract(this.Divide(((Number)12)).Sin.Pow(((Number)5))))).Sin, this.Multiply(this.Cos.Exp.Subtract(((Number)2).Multiply(this.Multiply(((Number)4)).Cos).Subtract(this.Divide(((Number)12)).Sin.Pow(((Number)5))))).Cos); } 
        [MethodImpl(AggressiveInlining)]  public Vector2 Lissajous(Number a, Number b, Angle d) => (this.Add(d).Sin, b.Sin);
        public Number CycloidOfCeva { [MethodImpl(AggressiveInlining)] get  => ((Number)1).Add(this.Multiply(((Number)2)).Cos.Multiply(((Number)2))); } 
        [MethodImpl(AggressiveInlining)]  public Number Limacon(Number a, Number b) => a.Multiply(this.Cos).Add(b);
        public Number Cardoid { [MethodImpl(AggressiveInlining)] get  => ((Number)1).Add(this.Cos); } 
        [MethodImpl(AggressiveInlining)]  public Number TschirnhausenCubic(Number a) => a.Multiply(this.Divide(((Number)3)).Sec.Cube);
        [MethodImpl(AggressiveInlining)]  public Number Rose(Number k) => k.Multiply(this.Cos);
        [MethodImpl(AggressiveInlining)]  public Number ArchimedeanSpiral(Number a, Number b) => a.Add(b.Multiply(this.Turns));
        [MethodImpl(AggressiveInlining)]  public Number ConicSection(Number semiLatusRectum, Number eccentricity) => semiLatusRectum.Divide(((Number)1).Subtract(eccentricity.Multiply(this.Cos)));
        [MethodImpl(AggressiveInlining)]  public Number LemniscateOfBernoulli(Number a) => a.Sqr.Multiply(this.Multiply(((Number)2)).Cos).Sqrt;
        [MethodImpl(AggressiveInlining)]  public Number TrisectrixOfMaclaurin(Number a) => ((Number)2).Multiply(a).Divide(this.Divide(((Number)3)).Cos);
        [MethodImpl(AggressiveInlining)]  public Number ConchoidOfDeSluze(Number a) => this.Sec.Add(a.Multiply(this.Cos));
        [MethodImpl(AggressiveInlining)]  public Number SinusoidalSpiral(Number a, Number n) => a.Pow(n).Multiply(this.Multiply(n).Cos).InversePow(a);
        [MethodImpl(AggressiveInlining)]  public Number FermatsSpiral(Number a) => a.Multiply(this.Turns.Sqr).Sqrt;
        [MethodImpl(AggressiveInlining)]  public Number LogarithmicSpiral(Number a, Number k) => a.Multiply(this.Radians.Multiply(k).Exp);
        [MethodImpl(AggressiveInlining)]  public Vector3 TorusKnot(Number p, Number q){
            var r = this.Multiply(q).Cos.Add(((Number)2));
            var x = r.Multiply(this.Multiply(p).Cos);
            var y = r.Multiply(this.Multiply(p).Sin);
            var z = this.Multiply(q).Sin.Negative;
            return (x, y, z);
        }

        public Vector3 TrefoilKnot { [MethodImpl(AggressiveInlining)] get  => (this.Sin.Add(this.Multiply(((Number)2)).Sin.Multiply(((Number)2))), this.Cos.Add(this.Multiply(((Number)2)).Cos.Multiply(((Number)2))), this.Multiply(((Number)3)).Sin.Negative); } 
        public Vector3 FigureEightKnot { [MethodImpl(AggressiveInlining)] get  => (((Number)2).Add(this.Multiply(((Number)2)).Cos).Multiply(this.Multiply(((Number)3)).Cos), ((Number)2).Add(this.Multiply(((Number)2)).Cos).Multiply(this.Multiply(((Number)3)).Sin), this.Multiply(((Number)4)).Sin); } 
        [MethodImpl(AggressiveInlining)]  public Vector3 Helix(Number revs) => (this.Multiply(revs).Sin, this.Multiply(revs).Cos, this.Turns);
        [MethodImpl(AggressiveInlining)]  public Angle Add(Angle b) => this + b;
        [MethodImpl(AggressiveInlining)]  public Angle Subtract(Angle b) => this - b;
        [MethodImpl(AggressiveInlining)]  public Angle Multiply(Angle b) => this * b;
        [MethodImpl(AggressiveInlining)]  public Angle Divide(Angle b) => this / b;
        [MethodImpl(AggressiveInlining)]  public Angle Multiply(Number x) => this * x;
        [MethodImpl(AggressiveInlining)]  public Angle Divide(Number x) => this / x;
        public Angle Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)]  public Boolean LessThan(Angle b) => this < b;
        [MethodImpl(AggressiveInlining)]  public Boolean LessThanOrEquals(Angle b) => this <= b;
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThan(Angle b) => this > b;
        [MethodImpl(AggressiveInlining)]  public Boolean GreaterThanOrEquals(Angle b) => this >= b;
        public Rotation3D RotateX { [MethodImpl(AggressiveInlining)] get  => Quaternion.CreateFromAxisAngle(Vector3.UnitX, this); } 
        public Rotation3D RotateY { [MethodImpl(AggressiveInlining)] get  => Quaternion.CreateFromAxisAngle(Vector3.UnitY, this); } 
        public Rotation3D RotateZ { [MethodImpl(AggressiveInlining)] get  => Quaternion.CreateFromAxisAngle(Vector3.UnitZ, this); } 
        [MethodImpl(AggressiveInlining)]  public Angle Lesser(Angle b) => this.LessThanOrEquals(b) ? this : b;
        [MethodImpl(AggressiveInlining)]  public Angle Greater(Angle b) => this.GreaterThanOrEquals(b) ? this : b;
        [MethodImpl(AggressiveInlining)]  public Angle Lerp(Angle b, Number t) => this.Multiply(t.FromOne).Add(b.Multiply(t));
        [MethodImpl(AggressiveInlining)]  public Angle Barycentric(Angle v2, Angle v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
        public Angle PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One); } 
        public Angle MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(One); } 
        public Angle FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One).Negative; } 
        [MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
        public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(this.NumComponents))
                {
                    r = r.Max(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
            var r = this.Component(((Integer)0));
            {
                var i = ((Integer)1);
                while (i.LessThan(this.NumComponents))
                {
                    r = r.Min(this.Component(i));
                    i = i.Add(((Integer)1));
                }

            }
            return r;
        }
         } 
        [MethodImpl(AggressiveInlining)]  public Angle MapComponents(System.Func<Number, Number> f) => this.Components.Map(f).Create();
        [MethodImpl(AggressiveInlining)]  public Angle ZipComponents(Angle b, System.Func<Number, Number, Number> f) => this.Components.Zip(b.Components, f).Create();
        [MethodImpl(AggressiveInlining)]  public Angle ZipComponents(Angle b, Angle c, System.Func<Number, Number, Number, Number> f) => this.Components.Zip(b.Components, c.Components, f).Create();
        [MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
        [MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
        [MethodImpl(AggressiveInlining)]  public Angle Clamp(Angle a, Angle b) => this.ZipComponents(a, b, (x0, a0, b0) => x0.Clamp(a0, b0)).Create();
        public Angle Sqrt { [MethodImpl(AggressiveInlining)] get  => this.SquareRoot; } 
        [MethodImpl(AggressiveInlining)]  public Angle InversePow(Angle n) => this.Pow(n.Reciprocal);
        public Angle SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Square.Multiply(((Number)3).Subtract(this.Twice)); } 
        [MethodImpl(AggressiveInlining)]  public Angle MultiplyEpsilon(Angle y) => this.Abs.Greater(y.Abs).Multiply(Constants.Epsilon);
        public Angle Fract { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.Floor); } 
        public Angle Pow2 { [MethodImpl(AggressiveInlining)] get  => this.Multiply(this); } 
        public Angle Pow3 { [MethodImpl(AggressiveInlining)] get  => this.Pow2.Multiply(this); } 
        public Angle Pow4 { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this); } 
        public Angle Pow5 { [MethodImpl(AggressiveInlining)] get  => this.Pow4.Multiply(this); } 
        public Angle Sqr { [MethodImpl(AggressiveInlining)] get  => this.Square; } 
        public Angle Cube { [MethodImpl(AggressiveInlining)] get  => this.Pow3; } 
        public Angle ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(this.Zero, this.One); } 
        public Angle Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
        public Angle Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
        public Angle Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
        public Angle Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
        public Angle Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
        public Angle Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
        public Angle Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
        public Angle Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
        public Angle Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
        public Angle Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
        public Angle Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
        public Angle Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
        public Angle Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
        public Angle Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 

        // Unimplemented concept functions
        [MethodImpl(AggressiveInlining)]  public Angle Modulo(Number other) => this % other;
    }
}
