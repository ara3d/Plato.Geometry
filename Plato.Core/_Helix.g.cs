// Autogenerated file: DO NOT EDIT
// Created on 2025-03-09 8:08:08 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
public partial struct Helix: IAngularCurve3D, IOpenShape
{
    // Fields
    [DataMember] public readonly Number Radius;
    [DataMember] public readonly Number Height;
    [DataMember] public readonly Number NumTurns;

    // With functions 
    [MethodImpl(AggressiveInlining)] public Helix WithRadius(Number radius) => new Helix(radius, Height, NumTurns);
    [MethodImpl(AggressiveInlining)] public Helix WithHeight(Number height) => new Helix(Radius, height, NumTurns);
    [MethodImpl(AggressiveInlining)] public Helix WithNumTurns(Number numTurns) => new Helix(Radius, Height, numTurns);

    // Regular Constructor
    [MethodImpl(AggressiveInlining)] public Helix(Number radius, Number height, Number numTurns) { Radius = radius; Height = height; NumTurns = numTurns; }

    // Static factory function
    [MethodImpl(AggressiveInlining)] public static Helix Create(Number radius, Number height, Number numTurns) => new Helix(radius, height, numTurns);

    // Implicit converters to/from value-tuples and deconstructor
    [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number)(Helix self) => (self.Radius, self.Height, self.NumTurns);
    [MethodImpl(AggressiveInlining)] public static implicit operator Helix((Number, Number, Number) value) => new(value.Item1, value.Item2, value.Item3);
    [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number radius, out Number height, out Number numTurns) { radius = Radius; height = Height; numTurns = NumTurns;  }

    // Object virtual function overrides: Equals, GetHashCode, ToString
    [MethodImpl(AggressiveInlining)] public Boolean Equals(Helix other) => Radius.Equals(other.Radius) && Height.Equals(other.Height) && NumTurns.Equals(other.NumTurns);
    [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Helix other) => !Radius.Equals(other.Radius) && Height.Equals(other.Height) && NumTurns.Equals(other.NumTurns);
    [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Helix other ? Equals(other) : false;
    [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(Radius, Height, NumTurns);
    [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"Radius\" = {Radius}, \"Height\" = {Height}, \"NumTurns\" = {NumTurns} }}";

    // Explicit implementation of interfaces by forwarding properties to fields

    // Implemented concept functions and type functions
    [MethodImpl(AggressiveInlining)]  public Vector3 Eval(Angle t) => t.Helix(this.NumTurns).Multiply((this.Radius, this.Radius, this.Height));
[MethodImpl(AggressiveInlining)]  public Vector3 Eval(Number t) => this.Eval(t.Turns);
[MethodImpl(AggressiveInlining)]  public IArray<Vector3> Sample(Integer numPoints){
    var _var545 = this;
    return numPoints.LinearSpace.Map((x) =>  => _var545.Eval(x);
;
}

[MethodImpl(AggressiveInlining)]  public PolyLine3D ToPolyLine3D(Integer numPoints) => (this.Sample(numPoints), this.Closed);
[MethodImpl(AggressiveInlining)]  public Procedural<Number, TR> Combine<TR>(Helix b, System.Func<TR, TR, TR> f){
    var _var548 = b;
    {
        var _var547 = this;
        {
            var _var546 = f;
            return (x) =>  => _var546.Invoke(_var547.Eval(x), _var548.Eval(x));
;
        }
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<TR, Vector3> MapDomain<T0, TR>(System.Func<T0, TR> f){
    var _var550 = f;
    {
        var _var549 = this;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var549.Eval(_var550.Invoke(x));
;
    }
}

public System.Func<Number, Vector3> Function { [MethodImpl(AggressiveInlining)] get {
    var _var551 = this;
    return (x) =>  => _var551.Eval(x);
;
}
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Number, Vector3> Compose(Helix b){
    var _var553 = this;
    {
        var _var552 = b;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var552.Eval(_var553.Eval(x));
;
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, TR> Combine<TR>(Helix b, System.Func<TR, TR, TR> f){
    var _var556 = b;
    {
        var _var555 = this;
        {
            var _var554 = f;
            return (x) =>  => _var554.Invoke(_var555.Eval(x), _var556.Eval(x));
;
        }
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<TR, Number> MapDomain<T0, TR>(System.Func<T0, TR> f){
    var _var558 = f;
    {
        var _var557 = this;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var557.Eval(_var558.Invoke(x));
;
    }
}

public System.Func<Vector3, Number> Function { [MethodImpl(AggressiveInlining)] get {
    var _var559 = this;
    return (x) =>  => _var559.Eval(x);
;
}
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, Number> Compose(Helix b){
    var _var561 = this;
    {
        var _var560 = b;
        return new Procedural<$TIn2,$TOut>((x) =>  => _var560.Eval(_var561.Eval(x));
;
    }
}

[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, $TOut> Union(Helix b) => this.Combine(b, (a, b) =>  => a.Max(b);

[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, $TOut> Intersection(Helix b) => this.Combine(b, (a, b) =>  => a.Min(b);

[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, $TOut> Difference(Helix b) => this.Combine(b, (a, b) =>  => a.Max(b.Negative);

public Procedural<Vector3, Number> Inverse { [MethodImpl(AggressiveInlining)] get  => this.Map((x) =>  => x.Negative;
 } 
[MethodImpl(AggressiveInlining)]  public Procedural<Vector3, Boolean> Threshold(Number threshold){
    var _var562 = threshold;
    return this.Map((x) =>  => x.GreaterThanOrEquals(_var562);
;
}

public Boolean Closed { [MethodImpl(AggressiveInlining)] get  => ((Boolean)false); } 

    // Unimplemented concept functions
    [MethodImpl(AggressiveInlining)]  public Number Distance(Vector3 p) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public Number Eval(Vector3 t) => throw new NotImplementedException();
}
Plato.CSharpWriter.CSharpConcreteTypeWriter}
