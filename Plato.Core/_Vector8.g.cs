// Autogenerated file: DO NOT EDIT
// Created on 2025-03-09 8:08:08 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
public partial struct Vector8: IVector<Vector8>
{
    // Static factory function
    [MethodImpl(AggressiveInlining)] public static Vector8 Create(Number x0, Number x1, Number x2, Number x3, Number x4, Number x5, Number x6, Number x7) => new Vector8(x0, x1, x2, x3, x4, x5, x6, x7);

    // Implicit converters to/from value-tuples and deconstructor
    [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number, Number, Number, Number, Number, Number)(Vector8 self) => (self.X0, self.X1, self.X2, self.X3, self.X4, self.X5, self.X6, self.X7);
    [MethodImpl(AggressiveInlining)] public static implicit operator Vector8((Number, Number, Number, Number, Number, Number, Number, Number) value) => new(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5, value.Item6, value.Item7, value.Item8);
    [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x0, out Number x1, out Number x2, out Number x3, out Number x4, out Number x5, out Number x6, out Number x7) { x0 = X0; x1 = X1; x2 = X2; x3 = X3; x4 = X4; x5 = X5; x6 = X6; x7 = X7;  }

    // Object virtual function overrides: Equals, GetHashCode, ToString
    [MethodImpl(AggressiveInlining)] public Boolean Equals(Vector8 other) => Value.Equals(other.Value);
    [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Vector8 other) => !Value.Equals(other.Value);
    [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Vector8 other ? Equals(other) : false;
    [MethodImpl(AggressiveInlining)] public static Boolean operator==(Vector8 a, Vector8 b) => a.Equals(b);
    [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Vector8 a, Vector8 b) => !a.Equals(b);
    [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
    [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

    // Explicit implementation of interfaces by forwarding properties to fields

    // Array predefined functions
    [MethodImpl(AggressiveInlining)] public Vector8(IReadOnlyList<Number> xs) : this(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]) { }
    [MethodImpl(AggressiveInlining)] public Vector8(Number[] xs) : this(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]) { }
    [MethodImpl(AggressiveInlining)] public static Vector8 Create(IReadOnlyList<Number> xs) => new Vector8(xs);
    // Implementation of IReadOnlyList
    [MethodImpl(AggressiveInlining)] public System.Collections.Generic.IEnumerator<Number> GetEnumerator() => new ArrayEnumerator<Number>(this);
    [MethodImpl(AggressiveInlining)] System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
    Number System.Collections.Generic.IReadOnlyList<Number>.this[int n] { [MethodImpl(AggressiveInlining)] get => At(n); }
    int System.Collections.Generic.IReadOnlyCollection<Number>.Count { [MethodImpl(AggressiveInlining)] get => this.Count; }

    // IVectorSpace predefined functions
    public static readonly int NumComponents = 8;
    public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X0, X1, X2, X3, X4, X5, X6, X7); }
    [MethodImpl(AggressiveInlining)] public static Vector8 CreateFromComponents(IArray<Number> numbers) => new Vector8(numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], numbers[5], numbers[6], numbers[7]);

    // Implemented concept functions and type functions
    [MethodImpl(AggressiveInlining)]  public Vector8 Add(Vector8 right) => this + right;
    [MethodImpl(AggressiveInlining)]  public Vector8 Subtract(Vector8 right) => this - right;
    [MethodImpl(AggressiveInlining)]  public Vector8 Multiply(Vector8 right) => this * right;
    [MethodImpl(AggressiveInlining)]  public Vector8 Multiply(Number scalar) => this * scalar;
    [MethodImpl(AggressiveInlining)]  public Vector8 Divide(Vector8 right) => this / right;
    [MethodImpl(AggressiveInlining)]  public Vector8 Divide(Number scalar) => this / scalar;
    public Vector8 Negative { [MethodImpl(AggressiveInlining)] get => -this; }
    [MethodImpl(AggressiveInlining)]  public Vector8 BitwiseAnd(Vector8 b) => this & b;
    [MethodImpl(AggressiveInlining)]  public Vector8 BitwiseOr(Vector8 b) => this | b;
    public Vector8 Complement { [MethodImpl(AggressiveInlining)] get => ~this; }
    [MethodImpl(AggressiveInlining)]  public Vector8 LessThan(Vector8 b) => this < b;
    [MethodImpl(AggressiveInlining)]  public Vector8 LessThanOrEquals(Vector8 b) => this <= b;
    [MethodImpl(AggressiveInlining)]  public Vector8 GreaterThan(Vector8 b) => this > b;
    [MethodImpl(AggressiveInlining)]  public Vector8 GreaterThanOrEquals(Vector8 b) => this >= b;
    [MethodImpl(AggressiveInlining)]  public Vector8 MidPoint(Vector8 b) => this.Add(b).Half;
public Number Length { [MethodImpl(AggressiveInlining)] get  => this.Magnitude; } 
public Number LengthSquared { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared; } 
public Number SumSquares { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Sum; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSquares; } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Vector8 Normalize { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.GreaterThan(((Integer)0)) ? this.Divide(this.Magnitude) : Constants.Zero; } 
[MethodImpl(AggressiveInlining)]  public Vector8 Reflect(Vector8 normal) => this.Subtract(normal.Multiply(this.Dot(normal).Multiply(((Number)2))));
[MethodImpl(AggressiveInlining)]  public Vector8 Project(Vector8 other) => other.Multiply(this.Dot(other));
[MethodImpl(AggressiveInlining)]  public Number Distance(Vector8 b) => b.Subtract(this).Magnitude;
[MethodImpl(AggressiveInlining)]  public Number DistanceSquared(Vector8 b) => b.Subtract(this).MagnitudeSquared;
[MethodImpl(AggressiveInlining)]  public Angle Angle(Vector8 b) => this.Dot(b).Divide(this.Magnitude.Multiply(b.Magnitude)).Acos;
[MethodImpl(AggressiveInlining)]  public Boolean IsParallel(Vector8 b) => this.Dot(b).Abs.GreaterThanOrEquals(Constants.One.Subtract(Constants.Epsilon));
[MethodImpl(AggressiveInlining)]  public Vector8 Lerp(Vector8 b, Number t) => this.Multiply(t.FromOne).Add(b.Multiply(t));
[MethodImpl(AggressiveInlining)]  public Vector8 Barycentric(Vector8 v2, Vector8 v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
public Vector8 SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Multiply(this.Twice.Add(((Number)3)).Negative); } 
public Vector8 SmootherStep { [MethodImpl(AggressiveInlining)] get  => this.Cube.Multiply(this.Multiply(((Number)6)).Subtract(((Number)15))).Add(((Number)10)); } 
public Vector8 Pow2 { [MethodImpl(AggressiveInlining)] get  => this.Multiply(this); } 
public Vector8 Pow3 { [MethodImpl(AggressiveInlining)] get  => this.Pow2.Multiply(this); } 
public Vector8 Pow4 { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this); } 
public Vector8 Pow5 { [MethodImpl(AggressiveInlining)] get  => this.Pow4.Multiply(this); } 
public Vector8 Cube { [MethodImpl(AggressiveInlining)] get  => this.Pow3; } 
public Vector8 PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One); } 
public Vector8 MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(Constants.One); } 
public Vector8 FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(Constants.One).Negative; } 
[MethodImpl(AggressiveInlining)]  public Number Component(Integer n) => this.Components.At(n);
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get {
    var r = this.Component(((Integer)0));
    {
        var i = ((Integer)1);
        while (i.LessThan(NumComponents))
        {
            r = r.Max(this.Component(i));
            i = i.Add(((Integer)1));
        }

    }
    return r;
}
 } 
public Number MinComponent { [MethodImpl(AggressiveInlining)] get {
    var r = this.Component(((Integer)0));
    {
        var i = ((Integer)1);
        while (i.LessThan(NumComponents))
        {
            r = r.Min(this.Component(i));
            i = i.Add(((Integer)1));
        }

    }
    return r;
}
 } 
[MethodImpl(AggressiveInlining)]  public Vector8 MapComponents(System.Func<Number, Number> f) => Vector8.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Vector8 ZipComponents(Vector8 b, System.Func<Number, Number, Number> f) => Vector8.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Vector8 ZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Number> f) => Vector8.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector8 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x) =>  => x;

[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x) =>  => x;

[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector8 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x) =>  => x;

[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x) =>  => x;

[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
[MethodImpl(AggressiveInlining)]  public Vector8 InversePow(Vector8 n) => this.Pow(n.Reciprocal);
public Vector8 Fract { [MethodImpl(AggressiveInlining)] get  => this.Subtract(this.Floor); } 
public Vector8 ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Clamp(Constants.Zero, Constants.One); } 
[MethodImpl(AggressiveInlining)]  public Boolean Between(Vector8 a, Vector8 b) => this.AllZipComponents(a, b, (x0, a0, b0) =>  => x0.Between(a0, b0);

public Boolean BetweenZeroOne { [MethodImpl(AggressiveInlining)] get  => this.Between(Constants.Zero, Constants.One); } 
[MethodImpl(AggressiveInlining)]  public Vector8 Pow(Vector8 y) => this.ZipComponents(y, (a, b) =>  => a.Pow(b);

public Vector8 Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Vector8 Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Vector8 Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Vector8 Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Vector8 Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Vector8 Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Vector8 Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Vector8 Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Vector8 Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Vector8 Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Vector8 Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Vector8 Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Vector8 Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Vector8 Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 

    // Unimplemented concept functions
    [MethodImpl(AggressiveInlining)]  public Vector8 Modulo(Vector8 b) => this % b;
    [MethodImpl(AggressiveInlining)]  public Vector8 Modulo(Number other) => this % other;
    public Integer Count { [MethodImpl(AggressiveInlining)] get => 8; }
    [MethodImpl(AggressiveInlining)]  public Number At(Integer n) => n == 0 ? X0 : n == 1 ? X1 : n == 2 ? X2 : n == 3 ? X3 : n == 4 ? X4 : n == 5 ? X5 : n == 6 ? X6 : n == 7 ? X7 : throw new System.IndexOutOfRangeException();
    public Number this[Integer n] { [MethodImpl(AggressiveInlining)] get => At(n); }
}
Plato.CSharpWriter.CSharpConcreteTypeWriter}
