// Autogenerated file: DO NOT EDIT
// Created on 2025-04-08 12:25:04 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;

namespace Plato
{
    [DataContract, StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Point2D: ICoordinate, IVectorLike<Point2D>, IGeometricPrimitive2D<Point2D>, IDifference<Point2D, Vector2>
    {
        // Fields
        [DataMember] public readonly Number X;
        [DataMember] public readonly Number Y;

        // With functions 
        [MethodImpl(AggressiveInlining)] public Point2D WithX(Number x) => new Point2D(x, Y);
        [MethodImpl(AggressiveInlining)] public Point2D WithY(Number y) => new Point2D(X, y);

        // Regular Constructor
        [MethodImpl(AggressiveInlining)] public Point2D(Number x, Number y) { X = x; Y = y; }

        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Point2D Create(Number x, Number y) => new Point2D(x, y);

        // Static default implementation
        public static readonly Point2D Default = default;

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number)(Point2D self) => (self.X, self.Y);
        [MethodImpl(AggressiveInlining)] public static implicit operator Point2D((Number, Number) value) => new Point2D(value.Item1, value.Item2);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x, out Number y) { x = X; y = Y;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Point2D other) => X.Equals(other.X) && Y.Equals(other.Y);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Point2D other) => !X.Equals(other.X) && Y.Equals(other.Y);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Point2D other ? Equals(other).Value : false;
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Intrinsics.CombineHashCodes(X, Y);
        [MethodImpl(AggressiveInlining)] public override string ToString() => $"{{ \"X\" = {X}, \"Y\" = {Y} }}";

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 2; }
        public IArray<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X, Y); }
        [MethodImpl(AggressiveInlining)] public static Point2D CreateFromComponents(IArray<Number> numbers) => new Point2D(numbers[0], numbers[1]);

        [MethodImpl(AggressiveInlining)] public static Point2D CreateFromComponent(Number x) => new Point2D(x, x);

        // Implemented interface functions
        public Vector2 Vector2 { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y); } 
[MethodImpl(AggressiveInlining)]  public static implicit operator Vector2(Point2D x) => x.Vector2;
        [MethodImpl(AggressiveInlining)]  public Line2D LineTo(Point2D b) => (this, b);
[MethodImpl(AggressiveInlining)]  public Ray2D RayTo(Point2D b) => (this, b.Subtract(this));
[MethodImpl(AggressiveInlining)]  public Ray2D RayFrom(Vector2 dir) => (this, dir);
[MethodImpl(AggressiveInlining)]  public Vector2 Subtract(Point2D p2) => this.Vector2.Subtract(p2.Vector2);
[MethodImpl(AggressiveInlining)]  public static Vector2 operator -(Point2D p1, Point2D p2) => p1.Subtract(p2);
        [MethodImpl(AggressiveInlining)]  public Point2D Add(Vector2 p2) => this.Vector2.Add(p2);
[MethodImpl(AggressiveInlining)]  public static Point2D operator +(Point2D p1, Vector2 p2) => p1.Add(p2);
        [MethodImpl(AggressiveInlining)]  public Point2D Add(Point2D p2) => this.Vector2.Add(p2.Vector2);
[MethodImpl(AggressiveInlining)]  public static Point2D operator +(Point2D p1, Point2D p2) => p1.Add(p2);
        [MethodImpl(AggressiveInlining)]  public Point2D Multiply(Number n) => (this.X.Multiply(n), this.Y.Multiply(n));
[MethodImpl(AggressiveInlining)]  public static Point2D operator *(Point2D a, Number n) => a.Multiply(n);
        [MethodImpl(AggressiveInlining)]  public Point2D Divide(Number n) => (this.X.Divide(n), this.Y.Divide(n));
[MethodImpl(AggressiveInlining)]  public static Point2D operator /(Point2D a, Number n) => a.Divide(n);
        [MethodImpl(AggressiveInlining)]  public Point2D Multiply(Vector2 v) => this.Vector2.Multiply(v);
[MethodImpl(AggressiveInlining)]  public static Point2D operator *(Point2D a, Vector2 v) => a.Multiply(v);
        public Point3D To3D { [MethodImpl(AggressiveInlining)] get  => (this.X, this.Y, ((Integer)0)); } 
[MethodImpl(AggressiveInlining)]  public Point2D Deform(System.Func<Point2D, Point2D> f) => f.Invoke(this);
public static Point2D Zero { [MethodImpl(AggressiveInlining)] get  => Point2D.CreateFromComponent(((Number)0)); } 
public static Point2D One { [MethodImpl(AggressiveInlining)] get  => Point2D.CreateFromComponent(((Number)1)); } 
public static Point2D MinValue { [MethodImpl(AggressiveInlining)] get  => Point2D.CreateFromComponent(Number.MinValue); } 
public static Point2D MaxValue { [MethodImpl(AggressiveInlining)] get  => Point2D.CreateFromComponent(Number.MaxValue); } 
[MethodImpl(AggressiveInlining)]  public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this.At(((Integer)0)), (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Point2D Abs { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Abs); } 
public Point2D BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Point2D BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Point2D Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
public Point2D Ceiling { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Ceiling); } 
[MethodImpl(AggressiveInlining)]  public Point2D Clamp(Point2D min, Point2D max) => this.ZipComponents(min, max, (a, b, c)  => a.Clamp(b, c));
[MethodImpl(AggressiveInlining)]  public Point2D CopySign(Point2D y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
public Point2D Exp { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Exp); } 
public Point2D Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Floor); } 
[MethodImpl(AggressiveInlining)]  public Point2D FusedMultiplyAdd(Point2D y, Point2D z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Point2D ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)]  public Point2D IEEERemainder(Point2D y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Point2D Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
public Point2D Log2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log2); } 
[MethodImpl(AggressiveInlining)]  public Point2D Min(Point2D other) => this.ZipComponents(other, (a, b)  => a.Min(b));
[MethodImpl(AggressiveInlining)]  public Point2D MinMagnitude(Point2D other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)]  public Point2D Max(Point2D other) => this.ZipComponents(other, (a, b)  => a.Max(b));
[MethodImpl(AggressiveInlining)]  public Point2D MaxMagnitude(Point2D other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Point2D NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)]  public Point2D Pow(Point2D power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Point2D Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Reciprocal); } 
public Point2D ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Point2D ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)]  public Point2D RoundToZero(Integer digits){
            var _var88 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var88));
        }

[MethodImpl(AggressiveInlining)]  public Point2D ScaleB(Integer n){
            var _var89 = n;
            return this.MapComponents((x)  => x.ScaleB(_var89));
        }

public Point2D Square { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Sqr); } 
public Point2D Truncate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Truncate); } 
[MethodImpl(AggressiveInlining)]  public Boolean AlmostEqual(Point2D y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        [MethodImpl(AggressiveInlining)]  public Point2D Average(Point2D y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)]  public Boolean Between(Point2D a, Point2D b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Point2D ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Point2D Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
public Point2D FromOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.FromOne); } 
[MethodImpl(AggressiveInlining)]  public Point2D InversePow(Point2D y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)]  public Point2D Lerp(Point2D b, Number t){
            var _var90 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var90));
        }

[MethodImpl(AggressiveInlining)]  public Point2D MultiplyEpsilon(Point2D y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Point2D Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Point2D Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Point2D Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Point2D Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
public Point2D Sqr { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqr); } 
public Point2D Sqrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqrt); } 
[MethodImpl(AggressiveInlining)]  public IArray<Point2D> Sample(Point2D b, Integer n){
            var _var92 = b;
            {
                var _var91 = this;
                return n.LinearSpace.Map((i)  => _var91.Lerp(_var92, i));
            }
        }

public Point2D Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Point2D Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Point2D Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Point2D Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Point2D Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Point2D Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Point2D Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Point2D Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Point2D Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Point2D Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Point2D Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Point2D Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Point2D Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Point2D Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)]  public Number At(Integer n) => this.Components.At(n);
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)]  public Point2D MapComponents(System.Func<Number, Number> f) => Point2D.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)]  public Point2D ZipComponents(Point2D b, System.Func<Number, Number, Number> f) => Point2D.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)]  public Point2D ZipComponents(Point2D b, Point2D c, System.Func<Number, Number, Number, Number> f) => Point2D.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Point2D b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllZipComponents(Point2D b, Point2D c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Point2D b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AnyZipComponents(Point2D b, Point2D c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)]  public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)]  public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
[MethodImpl(AggressiveInlining)]  public Point2D Point(Integer index) => this.Points.At(index);
[MethodImpl(AggressiveInlining)]  public Triangle2D Triangle(Integer3 f) => (this.Point(f.A), this.Point(f.B), this.Point(f.C));
[MethodImpl(AggressiveInlining)]  public Quad2D Quad(Integer4 f) => (this.Point(f.A), this.Point(f.B), this.Point(f.C), this.Point(f.D));
public Bounds2D Bounds { [MethodImpl(AggressiveInlining)] get  => this.Points.Bounds(); } 

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)]  public Point2D Subtract(Vector2 amount) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Point2D operator -(Point2D x, Vector2 amount) => x.Subtract(amount);
        public IArray<Point2D> Points => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public Point2D Modulo(Number other) => throw new NotImplementedException();
[MethodImpl(AggressiveInlining)]  public static Point2D operator %(Point2D self, Number other) => self.Modulo(other);
    }
}
